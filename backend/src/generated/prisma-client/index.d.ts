
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Bill
 * 
 */
export type Bill = $Result.DefaultSelection<Prisma.$BillPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Request
 * 
 */
export type Request = $Result.DefaultSelection<Prisma.$RequestPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model AirtimeTransaction
 * 
 */
export type AirtimeTransaction = $Result.DefaultSelection<Prisma.$AirtimeTransactionPayload>
/**
 * Model Subaccount
 * 
 */
export type Subaccount = $Result.DefaultSelection<Prisma.$SubaccountPayload>
/**
 * Model SubaccountSplit
 * 
 */
export type SubaccountSplit = $Result.DefaultSelection<Prisma.$SubaccountSplitPayload>
/**
 * Model SplitGroup
 * 
 */
export type SplitGroup = $Result.DefaultSelection<Prisma.$SplitGroupPayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model BulkTransfer
 * 
 */
export type BulkTransfer = $Result.DefaultSelection<Prisma.$BulkTransferPayload>
/**
 * Model Recipient
 * 
 */
export type Recipient = $Result.DefaultSelection<Prisma.$RecipientPayload>
/**
 * Model CryptoWallet
 * 
 */
export type CryptoWallet = $Result.DefaultSelection<Prisma.$CryptoWalletPayload>
/**
 * Model BlockchainRequest
 * 
 */
export type BlockchainRequest = $Result.DefaultSelection<Prisma.$BlockchainRequestPayload>
/**
 * Model BlockchainTransaction
 * 
 */
export type BlockchainTransaction = $Result.DefaultSelection<Prisma.$BlockchainTransactionPayload>
/**
 * Model SplitPayment
 * 
 */
export type SplitPayment = $Result.DefaultSelection<Prisma.$SplitPaymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  BENEFACTOR: 'BENEFACTOR',
  BENEFACTEE: 'BENEFACTEE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const BillStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  PAID: 'PAID'
};

export type BillStatus = (typeof BillStatus)[keyof typeof BillStatus]


export const RequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const BlockchainTxStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  FAILED: 'FAILED',
  REJECTED: 'REJECTED'
};

export type BlockchainTxStatus = (typeof BlockchainTxStatus)[keyof typeof BlockchainTxStatus]


export const PaymentType: {
  NATIVE: 'NATIVE',
  U2K_TOKEN: 'U2K_TOKEN'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type BillStatus = $Enums.BillStatus

export const BillStatus: typeof $Enums.BillStatus

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type BlockchainTxStatus = $Enums.BlockchainTxStatus

export const BlockchainTxStatus: typeof $Enums.BlockchainTxStatus

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.request`: Exposes CRUD operations for the **Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.request.findMany()
    * ```
    */
  get request(): Prisma.RequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.airtimeTransaction`: Exposes CRUD operations for the **AirtimeTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AirtimeTransactions
    * const airtimeTransactions = await prisma.airtimeTransaction.findMany()
    * ```
    */
  get airtimeTransaction(): Prisma.AirtimeTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subaccount`: Exposes CRUD operations for the **Subaccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subaccounts
    * const subaccounts = await prisma.subaccount.findMany()
    * ```
    */
  get subaccount(): Prisma.SubaccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subaccountSplit`: Exposes CRUD operations for the **SubaccountSplit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubaccountSplits
    * const subaccountSplits = await prisma.subaccountSplit.findMany()
    * ```
    */
  get subaccountSplit(): Prisma.SubaccountSplitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.splitGroup`: Exposes CRUD operations for the **SplitGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SplitGroups
    * const splitGroups = await prisma.splitGroup.findMany()
    * ```
    */
  get splitGroup(): Prisma.SplitGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bulkTransfer`: Exposes CRUD operations for the **BulkTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BulkTransfers
    * const bulkTransfers = await prisma.bulkTransfer.findMany()
    * ```
    */
  get bulkTransfer(): Prisma.BulkTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipient`: Exposes CRUD operations for the **Recipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipients
    * const recipients = await prisma.recipient.findMany()
    * ```
    */
  get recipient(): Prisma.RecipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cryptoWallet`: Exposes CRUD operations for the **CryptoWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoWallets
    * const cryptoWallets = await prisma.cryptoWallet.findMany()
    * ```
    */
  get cryptoWallet(): Prisma.CryptoWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockchainRequest`: Exposes CRUD operations for the **BlockchainRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockchainRequests
    * const blockchainRequests = await prisma.blockchainRequest.findMany()
    * ```
    */
  get blockchainRequest(): Prisma.BlockchainRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockchainTransaction`: Exposes CRUD operations for the **BlockchainTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockchainTransactions
    * const blockchainTransactions = await prisma.blockchainTransaction.findMany()
    * ```
    */
  get blockchainTransaction(): Prisma.BlockchainTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.splitPayment`: Exposes CRUD operations for the **SplitPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SplitPayments
    * const splitPayments = await prisma.splitPayment.findMany()
    * ```
    */
  get splitPayment(): Prisma.SplitPaymentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Provider: 'Provider',
    Bill: 'Bill',
    Transaction: 'Transaction',
    Wallet: 'Wallet',
    Request: 'Request',
    Payment: 'Payment',
    AirtimeTransaction: 'AirtimeTransaction',
    Subaccount: 'Subaccount',
    SubaccountSplit: 'SubaccountSplit',
    SplitGroup: 'SplitGroup',
    Transfer: 'Transfer',
    Batch: 'Batch',
    BulkTransfer: 'BulkTransfer',
    Recipient: 'Recipient',
    CryptoWallet: 'CryptoWallet',
    BlockchainRequest: 'BlockchainRequest',
    BlockchainTransaction: 'BlockchainTransaction',
    SplitPayment: 'SplitPayment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "provider" | "bill" | "transaction" | "wallet" | "request" | "payment" | "airtimeTransaction" | "subaccount" | "subaccountSplit" | "splitGroup" | "transfer" | "batch" | "bulkTransfer" | "recipient" | "cryptoWallet" | "blockchainRequest" | "blockchainTransaction" | "splitPayment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Bill: {
        payload: Prisma.$BillPayload<ExtArgs>
        fields: Prisma.BillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findFirst: {
            args: Prisma.BillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          findMany: {
            args: Prisma.BillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          create: {
            args: Prisma.BillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          createMany: {
            args: Prisma.BillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          delete: {
            args: Prisma.BillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          update: {
            args: Prisma.BillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          deleteMany: {
            args: Prisma.BillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>[]
          }
          upsert: {
            args: Prisma.BillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillPayload>
          }
          aggregate: {
            args: Prisma.BillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBill>
          }
          groupBy: {
            args: Prisma.BillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillCountArgs<ExtArgs>
            result: $Utils.Optional<BillCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Request: {
        payload: Prisma.$RequestPayload<ExtArgs>
        fields: Prisma.RequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findFirst: {
            args: Prisma.RequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findMany: {
            args: Prisma.RequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          create: {
            args: Prisma.RequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          createMany: {
            args: Prisma.RequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          delete: {
            args: Prisma.RequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          update: {
            args: Prisma.RequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          deleteMany: {
            args: Prisma.RequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          upsert: {
            args: Prisma.RequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          aggregate: {
            args: Prisma.RequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequest>
          }
          groupBy: {
            args: Prisma.RequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestCountArgs<ExtArgs>
            result: $Utils.Optional<RequestCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      AirtimeTransaction: {
        payload: Prisma.$AirtimeTransactionPayload<ExtArgs>
        fields: Prisma.AirtimeTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AirtimeTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AirtimeTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>
          }
          findFirst: {
            args: Prisma.AirtimeTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AirtimeTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>
          }
          findMany: {
            args: Prisma.AirtimeTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>[]
          }
          create: {
            args: Prisma.AirtimeTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>
          }
          createMany: {
            args: Prisma.AirtimeTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AirtimeTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>[]
          }
          delete: {
            args: Prisma.AirtimeTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>
          }
          update: {
            args: Prisma.AirtimeTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>
          }
          deleteMany: {
            args: Prisma.AirtimeTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AirtimeTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AirtimeTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>[]
          }
          upsert: {
            args: Prisma.AirtimeTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirtimeTransactionPayload>
          }
          aggregate: {
            args: Prisma.AirtimeTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirtimeTransaction>
          }
          groupBy: {
            args: Prisma.AirtimeTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirtimeTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AirtimeTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<AirtimeTransactionCountAggregateOutputType> | number
          }
        }
      }
      Subaccount: {
        payload: Prisma.$SubaccountPayload<ExtArgs>
        fields: Prisma.SubaccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubaccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubaccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>
          }
          findFirst: {
            args: Prisma.SubaccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubaccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>
          }
          findMany: {
            args: Prisma.SubaccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>[]
          }
          create: {
            args: Prisma.SubaccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>
          }
          createMany: {
            args: Prisma.SubaccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubaccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>[]
          }
          delete: {
            args: Prisma.SubaccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>
          }
          update: {
            args: Prisma.SubaccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>
          }
          deleteMany: {
            args: Prisma.SubaccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubaccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubaccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>[]
          }
          upsert: {
            args: Prisma.SubaccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountPayload>
          }
          aggregate: {
            args: Prisma.SubaccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubaccount>
          }
          groupBy: {
            args: Prisma.SubaccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubaccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubaccountCountArgs<ExtArgs>
            result: $Utils.Optional<SubaccountCountAggregateOutputType> | number
          }
        }
      }
      SubaccountSplit: {
        payload: Prisma.$SubaccountSplitPayload<ExtArgs>
        fields: Prisma.SubaccountSplitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubaccountSplitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubaccountSplitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>
          }
          findFirst: {
            args: Prisma.SubaccountSplitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubaccountSplitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>
          }
          findMany: {
            args: Prisma.SubaccountSplitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>[]
          }
          create: {
            args: Prisma.SubaccountSplitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>
          }
          createMany: {
            args: Prisma.SubaccountSplitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubaccountSplitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>[]
          }
          delete: {
            args: Prisma.SubaccountSplitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>
          }
          update: {
            args: Prisma.SubaccountSplitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>
          }
          deleteMany: {
            args: Prisma.SubaccountSplitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubaccountSplitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubaccountSplitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>[]
          }
          upsert: {
            args: Prisma.SubaccountSplitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubaccountSplitPayload>
          }
          aggregate: {
            args: Prisma.SubaccountSplitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubaccountSplit>
          }
          groupBy: {
            args: Prisma.SubaccountSplitGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubaccountSplitGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubaccountSplitCountArgs<ExtArgs>
            result: $Utils.Optional<SubaccountSplitCountAggregateOutputType> | number
          }
        }
      }
      SplitGroup: {
        payload: Prisma.$SplitGroupPayload<ExtArgs>
        fields: Prisma.SplitGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SplitGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SplitGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>
          }
          findFirst: {
            args: Prisma.SplitGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SplitGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>
          }
          findMany: {
            args: Prisma.SplitGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>[]
          }
          create: {
            args: Prisma.SplitGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>
          }
          createMany: {
            args: Prisma.SplitGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SplitGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>[]
          }
          delete: {
            args: Prisma.SplitGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>
          }
          update: {
            args: Prisma.SplitGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>
          }
          deleteMany: {
            args: Prisma.SplitGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SplitGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SplitGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>[]
          }
          upsert: {
            args: Prisma.SplitGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitGroupPayload>
          }
          aggregate: {
            args: Prisma.SplitGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSplitGroup>
          }
          groupBy: {
            args: Prisma.SplitGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<SplitGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.SplitGroupCountArgs<ExtArgs>
            result: $Utils.Optional<SplitGroupCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      BulkTransfer: {
        payload: Prisma.$BulkTransferPayload<ExtArgs>
        fields: Prisma.BulkTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BulkTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BulkTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>
          }
          findFirst: {
            args: Prisma.BulkTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BulkTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>
          }
          findMany: {
            args: Prisma.BulkTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>[]
          }
          create: {
            args: Prisma.BulkTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>
          }
          createMany: {
            args: Prisma.BulkTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BulkTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>[]
          }
          delete: {
            args: Prisma.BulkTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>
          }
          update: {
            args: Prisma.BulkTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>
          }
          deleteMany: {
            args: Prisma.BulkTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BulkTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BulkTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>[]
          }
          upsert: {
            args: Prisma.BulkTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkTransferPayload>
          }
          aggregate: {
            args: Prisma.BulkTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBulkTransfer>
          }
          groupBy: {
            args: Prisma.BulkTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<BulkTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.BulkTransferCountArgs<ExtArgs>
            result: $Utils.Optional<BulkTransferCountAggregateOutputType> | number
          }
        }
      }
      Recipient: {
        payload: Prisma.$RecipientPayload<ExtArgs>
        fields: Prisma.RecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          findFirst: {
            args: Prisma.RecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          findMany: {
            args: Prisma.RecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>[]
          }
          create: {
            args: Prisma.RecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          createMany: {
            args: Prisma.RecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>[]
          }
          delete: {
            args: Prisma.RecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          update: {
            args: Prisma.RecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          deleteMany: {
            args: Prisma.RecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>[]
          }
          upsert: {
            args: Prisma.RecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipientPayload>
          }
          aggregate: {
            args: Prisma.RecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipient>
          }
          groupBy: {
            args: Prisma.RecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipientCountArgs<ExtArgs>
            result: $Utils.Optional<RecipientCountAggregateOutputType> | number
          }
        }
      }
      CryptoWallet: {
        payload: Prisma.$CryptoWalletPayload<ExtArgs>
        fields: Prisma.CryptoWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findFirst: {
            args: Prisma.CryptoWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          findMany: {
            args: Prisma.CryptoWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          create: {
            args: Prisma.CryptoWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          createMany: {
            args: Prisma.CryptoWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          delete: {
            args: Prisma.CryptoWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          update: {
            args: Prisma.CryptoWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          deleteMany: {
            args: Prisma.CryptoWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CryptoWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>[]
          }
          upsert: {
            args: Prisma.CryptoWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoWalletPayload>
          }
          aggregate: {
            args: Prisma.CryptoWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoWallet>
          }
          groupBy: {
            args: Prisma.CryptoWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoWalletCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoWalletCountAggregateOutputType> | number
          }
        }
      }
      BlockchainRequest: {
        payload: Prisma.$BlockchainRequestPayload<ExtArgs>
        fields: Prisma.BlockchainRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockchainRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockchainRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>
          }
          findFirst: {
            args: Prisma.BlockchainRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockchainRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>
          }
          findMany: {
            args: Prisma.BlockchainRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>[]
          }
          create: {
            args: Prisma.BlockchainRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>
          }
          createMany: {
            args: Prisma.BlockchainRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockchainRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>[]
          }
          delete: {
            args: Prisma.BlockchainRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>
          }
          update: {
            args: Prisma.BlockchainRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>
          }
          deleteMany: {
            args: Prisma.BlockchainRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockchainRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockchainRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>[]
          }
          upsert: {
            args: Prisma.BlockchainRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainRequestPayload>
          }
          aggregate: {
            args: Prisma.BlockchainRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockchainRequest>
          }
          groupBy: {
            args: Prisma.BlockchainRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockchainRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockchainRequestCountArgs<ExtArgs>
            result: $Utils.Optional<BlockchainRequestCountAggregateOutputType> | number
          }
        }
      }
      BlockchainTransaction: {
        payload: Prisma.$BlockchainTransactionPayload<ExtArgs>
        fields: Prisma.BlockchainTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockchainTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          findFirst: {
            args: Prisma.BlockchainTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockchainTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          findMany: {
            args: Prisma.BlockchainTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>[]
          }
          create: {
            args: Prisma.BlockchainTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          createMany: {
            args: Prisma.BlockchainTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockchainTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>[]
          }
          delete: {
            args: Prisma.BlockchainTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          update: {
            args: Prisma.BlockchainTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BlockchainTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockchainTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockchainTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>[]
          }
          upsert: {
            args: Prisma.BlockchainTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockchainTransactionPayload>
          }
          aggregate: {
            args: Prisma.BlockchainTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockchainTransaction>
          }
          groupBy: {
            args: Prisma.BlockchainTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockchainTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockchainTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BlockchainTransactionCountAggregateOutputType> | number
          }
        }
      }
      SplitPayment: {
        payload: Prisma.$SplitPaymentPayload<ExtArgs>
        fields: Prisma.SplitPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SplitPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SplitPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>
          }
          findFirst: {
            args: Prisma.SplitPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SplitPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>
          }
          findMany: {
            args: Prisma.SplitPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>[]
          }
          create: {
            args: Prisma.SplitPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>
          }
          createMany: {
            args: Prisma.SplitPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SplitPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>[]
          }
          delete: {
            args: Prisma.SplitPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>
          }
          update: {
            args: Prisma.SplitPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SplitPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SplitPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SplitPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>[]
          }
          upsert: {
            args: Prisma.SplitPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SplitPaymentPayload>
          }
          aggregate: {
            args: Prisma.SplitPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSplitPayment>
          }
          groupBy: {
            args: Prisma.SplitPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SplitPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SplitPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SplitPaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    provider?: ProviderOmit
    bill?: BillOmit
    transaction?: TransactionOmit
    wallet?: WalletOmit
    request?: RequestOmit
    payment?: PaymentOmit
    airtimeTransaction?: AirtimeTransactionOmit
    subaccount?: SubaccountOmit
    subaccountSplit?: SubaccountSplitOmit
    splitGroup?: SplitGroupOmit
    transfer?: TransferOmit
    batch?: BatchOmit
    bulkTransfer?: BulkTransferOmit
    recipient?: RecipientOmit
    cryptoWallet?: CryptoWalletOmit
    blockchainRequest?: BlockchainRequestOmit
    blockchainTransaction?: BlockchainTransactionOmit
    splitPayment?: SplitPaymentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bills: number
    requests: number
    supports: number
    sponsoredBills: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | UserCountOutputTypeCountBillsArgs
    requests?: boolean | UserCountOutputTypeCountRequestsArgs
    supports?: boolean | UserCountOutputTypeCountSupportsArgs
    sponsoredBills?: boolean | UserCountOutputTypeCountSponsoredBillsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSponsoredBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }


  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    bills: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | ProviderCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }


  /**
   * Count Type BillCountOutputType
   */

  export type BillCountOutputType = {
    sponsors: number
    transactions: number
  }

  export type BillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sponsors?: boolean | BillCountOutputTypeCountSponsorsArgs
    transactions?: boolean | BillCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillCountOutputType
     */
    select?: BillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountSponsorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BillCountOutputType without action
   */
  export type BillCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type RequestCountOutputType
   */

  export type RequestCountOutputType = {
    bills: number
  }

  export type RequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | RequestCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * RequestCountOutputType without action
   */
  export type RequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestCountOutputType
     */
    select?: RequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequestCountOutputType without action
   */
  export type RequestCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
  }


  /**
   * Count Type SubaccountCountOutputType
   */

  export type SubaccountCountOutputType = {
    subaccountSplits: number
  }

  export type SubaccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccountSplits?: boolean | SubaccountCountOutputTypeCountSubaccountSplitsArgs
  }

  // Custom InputTypes
  /**
   * SubaccountCountOutputType without action
   */
  export type SubaccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountCountOutputType
     */
    select?: SubaccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubaccountCountOutputType without action
   */
  export type SubaccountCountOutputTypeCountSubaccountSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubaccountSplitWhereInput
  }


  /**
   * Count Type SplitGroupCountOutputType
   */

  export type SplitGroupCountOutputType = {
    subaccounts: number
  }

  export type SplitGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccounts?: boolean | SplitGroupCountOutputTypeCountSubaccountsArgs
  }

  // Custom InputTypes
  /**
   * SplitGroupCountOutputType without action
   */
  export type SplitGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroupCountOutputType
     */
    select?: SplitGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SplitGroupCountOutputType without action
   */
  export type SplitGroupCountOutputTypeCountSubaccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubaccountSplitWhereInput
  }


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    transfers: number
    bulkTransfers: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfers?: boolean | BatchCountOutputTypeCountTransfersArgs
    bulkTransfers?: boolean | BatchCountOutputTypeCountBulkTransfersArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountBulkTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkTransferWhereInput
  }


  /**
   * Count Type CryptoWalletCountOutputType
   */

  export type CryptoWalletCountOutputType = {
    transactions: number
  }

  export type CryptoWalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CryptoWalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CryptoWalletCountOutputType without action
   */
  export type CryptoWalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWalletCountOutputType
     */
    select?: CryptoWalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CryptoWalletCountOutputType without action
   */
  export type CryptoWalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockchainTransactionWhereInput
  }


  /**
   * Count Type BlockchainRequestCountOutputType
   */

  export type BlockchainRequestCountOutputType = {
    transactions: number
  }

  export type BlockchainRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BlockchainRequestCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BlockchainRequestCountOutputType without action
   */
  export type BlockchainRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequestCountOutputType
     */
    select?: BlockchainRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlockchainRequestCountOutputType without action
   */
  export type BlockchainRequestCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockchainTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    password: string | null
    googleId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    password: string | null
    googleId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    phone: number
    password: number
    googleId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    password?: true
    googleId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    password?: true
    googleId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    password?: true
    googleId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    phone: string | null
    password: string | null
    googleId: string | null
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bills?: boolean | User$billsArgs<ExtArgs>
    requests?: boolean | User$requestsArgs<ExtArgs>
    supports?: boolean | User$supportsArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    cryptoWallet?: boolean | User$cryptoWalletArgs<ExtArgs>
    sponsoredBills?: boolean | User$sponsoredBillsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    googleId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "phone" | "password" | "googleId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | User$billsArgs<ExtArgs>
    requests?: boolean | User$requestsArgs<ExtArgs>
    supports?: boolean | User$supportsArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    cryptoWallet?: boolean | User$cryptoWalletArgs<ExtArgs>
    sponsoredBills?: boolean | User$sponsoredBillsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      bills: Prisma.$BillPayload<ExtArgs>[]
      requests: Prisma.$RequestPayload<ExtArgs>[]
      supports: Prisma.$RequestPayload<ExtArgs>[]
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      cryptoWallet: Prisma.$CryptoWalletPayload<ExtArgs> | null
      sponsoredBills: Prisma.$BillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      phone: string | null
      password: string | null
      googleId: string | null
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bills<T extends User$billsArgs<ExtArgs> = {}>(args?: Subset<T, User$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requests<T extends User$requestsArgs<ExtArgs> = {}>(args?: Subset<T, User$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supports<T extends User$supportsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallet<T extends User$walletArgs<ExtArgs> = {}>(args?: Subset<T, User$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cryptoWallet<T extends User$cryptoWalletArgs<ExtArgs> = {}>(args?: Subset<T, User$cryptoWalletArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sponsoredBills<T extends User$sponsoredBillsArgs<ExtArgs> = {}>(args?: Subset<T, User$sponsoredBillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bills
   */
  export type User$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * User.requests
   */
  export type User$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * User.supports
   */
  export type User$supportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * User.wallet
   */
  export type User$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * User.cryptoWallet
   */
  export type User$cryptoWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    where?: CryptoWalletWhereInput
  }

  /**
   * User.sponsoredBills
   */
  export type User$sponsoredBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    accountNumber: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    accountNumber: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    name: number
    email: number
    accountNumber: number
    verified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProviderMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    accountNumber?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    accountNumber?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    accountNumber?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: string
    name: string
    email: string | null
    accountNumber: string | null
    verified: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    accountNumber?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bills?: boolean | Provider$billsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    accountNumber?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    accountNumber?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    accountNumber?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "accountNumber" | "verified" | "createdAt" | "updatedAt", ExtArgs["result"]["provider"]>
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | Provider$billsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      bills: Prisma.$BillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      accountNumber: string | null
      verified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderFindManyArgs>(args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
     */
    create<T extends ProviderCreateArgs>(args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCreateManyArgs>(args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {ProviderCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
     */
    delete<T extends ProviderDeleteArgs>(args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderUpdateArgs>(args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderDeleteManyArgs>(args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderUpdateManyArgs>(args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {ProviderUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bills<T extends Provider$billsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'String'>
    readonly name: FieldRef<"Provider", 'String'>
    readonly email: FieldRef<"Provider", 'String'>
    readonly accountNumber: FieldRef<"Provider", 'String'>
    readonly verified: FieldRef<"Provider", 'Boolean'>
    readonly createdAt: FieldRef<"Provider", 'DateTime'>
    readonly updatedAt: FieldRef<"Provider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider createManyAndReturn
   */
  export type ProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider updateManyAndReturn
   */
  export type ProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to delete.
     */
    limit?: number
  }

  /**
   * Provider.bills
   */
  export type Provider$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Bill
   */

  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillSumAggregateOutputType = {
    amount: number | null
  }

  export type BillMinAggregateOutputType = {
    id: string | null
    billName: string | null
    description: string | null
    type: string | null
    note: string | null
    amount: number | null
    priority: $Enums.Priority | null
    status: $Enums.BillStatus | null
    category: string | null
    dueDate: Date | null
    paymentMethod: string | null
    userId: string | null
    providerId: string | null
    requestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillMaxAggregateOutputType = {
    id: string | null
    billName: string | null
    description: string | null
    type: string | null
    note: string | null
    amount: number | null
    priority: $Enums.Priority | null
    status: $Enums.BillStatus | null
    category: string | null
    dueDate: Date | null
    paymentMethod: string | null
    userId: string | null
    providerId: string | null
    requestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    billName: number
    description: number
    type: number
    note: number
    amount: number
    priority: number
    status: number
    category: number
    dueDate: number
    paymentMethod: number
    userId: number
    providerId: number
    requestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    amount?: true
  }

  export type BillSumAggregateInputType = {
    amount?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    billName?: true
    description?: true
    type?: true
    note?: true
    amount?: true
    priority?: true
    status?: true
    category?: true
    dueDate?: true
    paymentMethod?: true
    userId?: true
    providerId?: true
    requestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    billName?: true
    description?: true
    type?: true
    note?: true
    amount?: true
    priority?: true
    status?: true
    category?: true
    dueDate?: true
    paymentMethod?: true
    userId?: true
    providerId?: true
    requestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    billName?: true
    description?: true
    type?: true
    note?: true
    amount?: true
    priority?: true
    status?: true
    category?: true
    dueDate?: true
    paymentMethod?: true
    userId?: true
    providerId?: true
    requestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bill to aggregate.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }




  export type BillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillWhereInput
    orderBy?: BillOrderByWithAggregationInput | BillOrderByWithAggregationInput[]
    by: BillScalarFieldEnum[] | BillScalarFieldEnum
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }

  export type BillGroupByOutputType = {
    id: string
    billName: string
    description: string
    type: string
    note: string | null
    amount: number
    priority: $Enums.Priority
    status: $Enums.BillStatus
    category: string | null
    dueDate: Date | null
    paymentMethod: string | null
    userId: string
    providerId: string | null
    requestId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillGroupByOutputType[P]>
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      >
    >


  export type BillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billName?: boolean
    description?: boolean
    type?: boolean
    note?: boolean
    amount?: boolean
    priority?: boolean
    status?: boolean
    category?: boolean
    dueDate?: boolean
    paymentMethod?: boolean
    userId?: boolean
    providerId?: boolean
    requestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Bill$providerArgs<ExtArgs>
    request?: boolean | Bill$requestArgs<ExtArgs>
    sponsors?: boolean | Bill$sponsorsArgs<ExtArgs>
    transactions?: boolean | Bill$transactionsArgs<ExtArgs>
    blockchainRequest?: boolean | Bill$blockchainRequestArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billName?: boolean
    description?: boolean
    type?: boolean
    note?: boolean
    amount?: boolean
    priority?: boolean
    status?: boolean
    category?: boolean
    dueDate?: boolean
    paymentMethod?: boolean
    userId?: boolean
    providerId?: boolean
    requestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Bill$providerArgs<ExtArgs>
    request?: boolean | Bill$requestArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billName?: boolean
    description?: boolean
    type?: boolean
    note?: boolean
    amount?: boolean
    priority?: boolean
    status?: boolean
    category?: boolean
    dueDate?: boolean
    paymentMethod?: boolean
    userId?: boolean
    providerId?: boolean
    requestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Bill$providerArgs<ExtArgs>
    request?: boolean | Bill$requestArgs<ExtArgs>
  }, ExtArgs["result"]["bill"]>

  export type BillSelectScalar = {
    id?: boolean
    billName?: boolean
    description?: boolean
    type?: boolean
    note?: boolean
    amount?: boolean
    priority?: boolean
    status?: boolean
    category?: boolean
    dueDate?: boolean
    paymentMethod?: boolean
    userId?: boolean
    providerId?: boolean
    requestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billName" | "description" | "type" | "note" | "amount" | "priority" | "status" | "category" | "dueDate" | "paymentMethod" | "userId" | "providerId" | "requestId" | "createdAt" | "updatedAt", ExtArgs["result"]["bill"]>
  export type BillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Bill$providerArgs<ExtArgs>
    request?: boolean | Bill$requestArgs<ExtArgs>
    sponsors?: boolean | Bill$sponsorsArgs<ExtArgs>
    transactions?: boolean | Bill$transactionsArgs<ExtArgs>
    blockchainRequest?: boolean | Bill$blockchainRequestArgs<ExtArgs>
    _count?: boolean | BillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Bill$providerArgs<ExtArgs>
    request?: boolean | Bill$requestArgs<ExtArgs>
  }
  export type BillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Bill$providerArgs<ExtArgs>
    request?: boolean | Bill$requestArgs<ExtArgs>
  }

  export type $BillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bill"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs> | null
      request: Prisma.$RequestPayload<ExtArgs> | null
      sponsors: Prisma.$UserPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      blockchainRequest: Prisma.$BlockchainRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billName: string
      description: string
      type: string
      note: string | null
      amount: number
      priority: $Enums.Priority
      status: $Enums.BillStatus
      category: string | null
      dueDate: Date | null
      paymentMethod: string | null
      userId: string
      providerId: string | null
      requestId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bill"]>
    composites: {}
  }

  type BillGetPayload<S extends boolean | null | undefined | BillDefaultArgs> = $Result.GetResult<Prisma.$BillPayload, S>

  type BillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillCountAggregateInputType | true
    }

  export interface BillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bill'], meta: { name: 'Bill' } }
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillFindUniqueArgs>(args: SelectSubset<T, BillFindUniqueArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillFindUniqueOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillFindUniqueOrThrowArgs>(args: SelectSubset<T, BillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillFindFirstArgs>(args?: SelectSubset<T, BillFindFirstArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstOrThrowArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillFindFirstOrThrowArgs>(args?: SelectSubset<T, BillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillFindManyArgs>(args?: SelectSubset<T, BillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
     */
    create<T extends BillCreateArgs>(args: SelectSubset<T, BillCreateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bills.
     * @param {BillCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillCreateManyArgs>(args?: SelectSubset<T, BillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bill = await prisma.bill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillCreateManyAndReturnArgs>(args?: SelectSubset<T, BillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
     */
    delete<T extends BillDeleteArgs>(args: SelectSubset<T, BillDeleteArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillUpdateArgs>(args: SelectSubset<T, BillUpdateArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillDeleteManyArgs>(args?: SelectSubset<T, BillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillUpdateManyArgs>(args: SelectSubset<T, BillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills and returns the data updated in the database.
     * @param {BillUpdateManyAndReturnArgs} args - Arguments to update many Bills.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bills and only return the `id`
     * const billWithIdOnly = await prisma.bill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillUpdateManyAndReturnArgs>(args: SelectSubset<T, BillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
     */
    upsert<T extends BillUpsertArgs>(args: SelectSubset<T, BillUpsertArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): Prisma.PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bill model
   */
  readonly fields: BillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends Bill$providerArgs<ExtArgs> = {}>(args?: Subset<T, Bill$providerArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    request<T extends Bill$requestArgs<ExtArgs> = {}>(args?: Subset<T, Bill$requestArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sponsors<T extends Bill$sponsorsArgs<ExtArgs> = {}>(args?: Subset<T, Bill$sponsorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Bill$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Bill$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockchainRequest<T extends Bill$blockchainRequestArgs<ExtArgs> = {}>(args?: Subset<T, Bill$blockchainRequestArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bill model
   */
  interface BillFieldRefs {
    readonly id: FieldRef<"Bill", 'String'>
    readonly billName: FieldRef<"Bill", 'String'>
    readonly description: FieldRef<"Bill", 'String'>
    readonly type: FieldRef<"Bill", 'String'>
    readonly note: FieldRef<"Bill", 'String'>
    readonly amount: FieldRef<"Bill", 'Float'>
    readonly priority: FieldRef<"Bill", 'Priority'>
    readonly status: FieldRef<"Bill", 'BillStatus'>
    readonly category: FieldRef<"Bill", 'String'>
    readonly dueDate: FieldRef<"Bill", 'DateTime'>
    readonly paymentMethod: FieldRef<"Bill", 'String'>
    readonly userId: FieldRef<"Bill", 'String'>
    readonly providerId: FieldRef<"Bill", 'String'>
    readonly requestId: FieldRef<"Bill", 'String'>
    readonly createdAt: FieldRef<"Bill", 'DateTime'>
    readonly updatedAt: FieldRef<"Bill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findUniqueOrThrow
   */
  export type BillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findFirstOrThrow
   */
  export type BillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bill to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill findMany
   */
  export type BillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Bill create
   */
  export type BillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to create a Bill.
     */
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }

  /**
   * Bill createMany
   */
  export type BillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bill createManyAndReturn
   */
  export type BillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillCreateManyInput | BillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill update
   */
  export type BillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The data needed to update a Bill.
     */
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
  }

  /**
   * Bill updateManyAndReturn
   */
  export type BillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * The data used to update Bills.
     */
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bill upsert
   */
  export type BillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * The filter to search for the Bill to update in case it exists.
     */
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     */
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }

  /**
   * Bill delete
   */
  export type BillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    /**
     * Filter which Bill to delete.
     */
    where: BillWhereUniqueInput
  }

  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillWhereInput
    /**
     * Limit how many Bills to delete.
     */
    limit?: number
  }

  /**
   * Bill.provider
   */
  export type Bill$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
  }

  /**
   * Bill.request
   */
  export type Bill$requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
  }

  /**
   * Bill.sponsors
   */
  export type Bill$sponsorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Bill.transactions
   */
  export type Bill$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Bill.blockchainRequest
   */
  export type Bill$blockchainRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    where?: BlockchainRequestWhereInput
  }

  /**
   * Bill without action
   */
  export type BillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    amount: number | null
    status: string | null
    billId: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    status: string | null
    billId: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    amount: number
    status: number
    billId: number
    reference: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    billId?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    billId?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    billId?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    amount: number
    status: string
    billId: string
    reference: string
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    billId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    billId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    billId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    amount?: boolean
    status?: boolean
    billId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "status" | "billId" | "reference" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      status: string
      billId: string
      reference: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly billId: FieldRef<"Transaction", 'String'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type WalletSumAggregateOutputType = {
    balance: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    balance: number | null
    userId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    balance: number | null
    userId: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    balance: number
    userId: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    updatedAt?: true
    createdAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    balance: number
    userId: string
    updatedAt: Date
    createdAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    userId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    userId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    userId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    balance?: boolean
    userId?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "balance" | "userId" | "updatedAt" | "createdAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      balance: number
      userId: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Float'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Request
   */

  export type AggregateRequest = {
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  export type RequestMinAggregateOutputType = {
    id: string | null
    name: string | null
    notes: string | null
    status: $Enums.RequestStatus | null
    feedback: string | null
    publicLinkId: string | null
    requesterId: string | null
    supporterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    notes: string | null
    status: $Enums.RequestStatus | null
    feedback: string | null
    publicLinkId: string | null
    requesterId: string | null
    supporterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCountAggregateOutputType = {
    id: number
    name: number
    notes: number
    status: number
    feedback: number
    publicLinkId: number
    requesterId: number
    supporterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestMinAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    status?: true
    feedback?: true
    publicLinkId?: true
    requesterId?: true
    supporterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestMaxAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    status?: true
    feedback?: true
    publicLinkId?: true
    requesterId?: true
    supporterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestCountAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    status?: true
    feedback?: true
    publicLinkId?: true
    requesterId?: true
    supporterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Request to aggregate.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requests
    **/
    _count?: true | RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMaxAggregateInputType
  }

  export type GetRequestAggregateType<T extends RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest[P]>
      : GetScalarType<T[P], AggregateRequest[P]>
  }




  export type RequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithAggregationInput | RequestOrderByWithAggregationInput[]
    by: RequestScalarFieldEnum[] | RequestScalarFieldEnum
    having?: RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCountAggregateInputType | true
    _min?: RequestMinAggregateInputType
    _max?: RequestMaxAggregateInputType
  }

  export type RequestGroupByOutputType = {
    id: string
    name: string
    notes: string | null
    status: $Enums.RequestStatus
    feedback: string | null
    publicLinkId: string
    requesterId: string
    supporterId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RequestCountAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  type GetRequestGroupByPayload<T extends RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestGroupByOutputType[P]>
            : GetScalarType<T[P], RequestGroupByOutputType[P]>
        }
      >
    >


  export type RequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
    publicLinkId?: boolean
    requesterId?: boolean
    supporterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    supporter?: boolean | Request$supporterArgs<ExtArgs>
    bills?: boolean | Request$billsArgs<ExtArgs>
    _count?: boolean | RequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
    publicLinkId?: boolean
    requesterId?: boolean
    supporterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    supporter?: boolean | Request$supporterArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
    publicLinkId?: boolean
    requesterId?: boolean
    supporterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    supporter?: boolean | Request$supporterArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectScalar = {
    id?: boolean
    name?: boolean
    notes?: boolean
    status?: boolean
    feedback?: boolean
    publicLinkId?: boolean
    requesterId?: boolean
    supporterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "notes" | "status" | "feedback" | "publicLinkId" | "requesterId" | "supporterId" | "createdAt" | "updatedAt", ExtArgs["result"]["request"]>
  export type RequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    supporter?: boolean | Request$supporterArgs<ExtArgs>
    bills?: boolean | Request$billsArgs<ExtArgs>
    _count?: boolean | RequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    supporter?: boolean | Request$supporterArgs<ExtArgs>
  }
  export type RequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    supporter?: boolean | Request$supporterArgs<ExtArgs>
  }

  export type $RequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Request"
    objects: {
      requester: Prisma.$UserPayload<ExtArgs>
      supporter: Prisma.$UserPayload<ExtArgs> | null
      bills: Prisma.$BillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      notes: string | null
      status: $Enums.RequestStatus
      feedback: string | null
      publicLinkId: string
      requesterId: string
      supporterId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["request"]>
    composites: {}
  }

  type RequestGetPayload<S extends boolean | null | undefined | RequestDefaultArgs> = $Result.GetResult<Prisma.$RequestPayload, S>

  type RequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestCountAggregateInputType | true
    }

  export interface RequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Request'], meta: { name: 'Request' } }
    /**
     * Find zero or one Request that matches the filter.
     * @param {RequestFindUniqueArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestFindUniqueArgs>(args: SelectSubset<T, RequestFindUniqueArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Request that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestFindUniqueOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestFindFirstArgs>(args?: SelectSubset<T, RequestFindFirstArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.request.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestWithIdOnly = await prisma.request.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestFindManyArgs>(args?: SelectSubset<T, RequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Request.
     * @param {RequestCreateArgs} args - Arguments to create a Request.
     * @example
     * // Create one Request
     * const Request = await prisma.request.create({
     *   data: {
     *     // ... data to create a Request
     *   }
     * })
     * 
     */
    create<T extends RequestCreateArgs>(args: SelectSubset<T, RequestCreateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requests.
     * @param {RequestCreateManyArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestCreateManyArgs>(args?: SelectSubset<T, RequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requests and returns the data saved in the database.
     * @param {RequestCreateManyAndReturnArgs} args - Arguments to create many Requests.
     * @example
     * // Create many Requests
     * const request = await prisma.request.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Request.
     * @param {RequestDeleteArgs} args - Arguments to delete one Request.
     * @example
     * // Delete one Request
     * const Request = await prisma.request.delete({
     *   where: {
     *     // ... filter to delete one Request
     *   }
     * })
     * 
     */
    delete<T extends RequestDeleteArgs>(args: SelectSubset<T, RequestDeleteArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Request.
     * @param {RequestUpdateArgs} args - Arguments to update one Request.
     * @example
     * // Update one Request
     * const request = await prisma.request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestUpdateArgs>(args: SelectSubset<T, RequestUpdateArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requests.
     * @param {RequestDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestDeleteManyArgs>(args?: SelectSubset<T, RequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestUpdateManyArgs>(args: SelectSubset<T, RequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests and returns the data updated in the database.
     * @param {RequestUpdateManyAndReturnArgs} args - Arguments to update many Requests.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requests and only return the `id`
     * const requestWithIdOnly = await prisma.request.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Request.
     * @param {RequestUpsertArgs} args - Arguments to update or create a Request.
     * @example
     * // Update or create a Request
     * const request = await prisma.request.upsert({
     *   create: {
     *     // ... data to create a Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request we want to update
     *   }
     * })
     */
    upsert<T extends RequestUpsertArgs>(args: SelectSubset<T, RequestUpsertArgs<ExtArgs>>): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.request.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends RequestCountArgs>(
      args?: Subset<T, RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregateArgs>(args: Subset<T, RequestAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregateType<T>>

    /**
     * Group by Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestGroupByArgs['orderBy'] }
        : { orderBy?: RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Request model
   */
  readonly fields: RequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supporter<T extends Request$supporterArgs<ExtArgs> = {}>(args?: Subset<T, Request$supporterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bills<T extends Request$billsArgs<ExtArgs> = {}>(args?: Subset<T, Request$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Request model
   */
  interface RequestFieldRefs {
    readonly id: FieldRef<"Request", 'String'>
    readonly name: FieldRef<"Request", 'String'>
    readonly notes: FieldRef<"Request", 'String'>
    readonly status: FieldRef<"Request", 'RequestStatus'>
    readonly feedback: FieldRef<"Request", 'String'>
    readonly publicLinkId: FieldRef<"Request", 'String'>
    readonly requesterId: FieldRef<"Request", 'String'>
    readonly supporterId: FieldRef<"Request", 'String'>
    readonly createdAt: FieldRef<"Request", 'DateTime'>
    readonly updatedAt: FieldRef<"Request", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Request findUnique
   */
  export type RequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findUniqueOrThrow
   */
  export type RequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findFirst
   */
  export type RequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findFirstOrThrow
   */
  export type RequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request findMany
   */
  export type RequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }

  /**
   * Request create
   */
  export type RequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to create a Request.
     */
    data: XOR<RequestCreateInput, RequestUncheckedCreateInput>
  }

  /**
   * Request createMany
   */
  export type RequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Request createManyAndReturn
   */
  export type RequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request update
   */
  export type RequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to update a Request.
     */
    data: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
    /**
     * Choose, which Request to update.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request updateMany
   */
  export type RequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
  }

  /**
   * Request updateManyAndReturn
   */
  export type RequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Request upsert
   */
  export type RequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The filter to search for the Request to update in case it exists.
     */
    where: RequestWhereUniqueInput
    /**
     * In case the Request found by the `where` argument doesn't exist, create a new Request with this data.
     */
    create: XOR<RequestCreateInput, RequestUncheckedCreateInput>
    /**
     * In case the Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
  }

  /**
   * Request delete
   */
  export type RequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter which Request to delete.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request deleteMany
   */
  export type RequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestWhereInput
    /**
     * Limit how many Requests to delete.
     */
    limit?: number
  }

  /**
   * Request.supporter
   */
  export type Request$supporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Request.bills
   */
  export type Request$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bill
     */
    select?: BillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bill
     */
    omit?: BillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillInclude<ExtArgs> | null
    where?: BillWhereInput
    orderBy?: BillOrderByWithRelationInput | BillOrderByWithRelationInput[]
    cursor?: BillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillScalarFieldEnum | BillScalarFieldEnum[]
  }

  /**
   * Request without action
   */
  export type RequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Request
     */
    omit?: RequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequestInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    email: string | null
    amount: number | null
    reference: string | null
    status: string | null
    splitCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    email: string | null
    amount: number | null
    reference: string | null
    status: string | null
    splitCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    email: number
    amount: number
    reference: number
    status: number
    splitCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    email?: true
    amount?: true
    reference?: true
    status?: true
    splitCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    email?: true
    amount?: true
    reference?: true
    status?: true
    splitCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    email?: true
    amount?: true
    reference?: true
    status?: true
    splitCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    email: string
    amount: number
    reference: string
    status: string
    splitCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    splitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    splitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    splitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    email?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    splitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "amount" | "reference" | "status" | "splitCode" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      amount: number
      reference: string
      status: string
      splitCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly email: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly splitCode: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
  }


  /**
   * Model AirtimeTransaction
   */

  export type AggregateAirtimeTransaction = {
    _count: AirtimeTransactionCountAggregateOutputType | null
    _avg: AirtimeTransactionAvgAggregateOutputType | null
    _sum: AirtimeTransactionSumAggregateOutputType | null
    _min: AirtimeTransactionMinAggregateOutputType | null
    _max: AirtimeTransactionMaxAggregateOutputType | null
  }

  export type AirtimeTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type AirtimeTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type AirtimeTransactionMinAggregateOutputType = {
    id: string | null
    phone: string | null
    amount: number | null
    network: string | null
    reference: string | null
    createdAt: Date | null
  }

  export type AirtimeTransactionMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    amount: number | null
    network: string | null
    reference: string | null
    createdAt: Date | null
  }

  export type AirtimeTransactionCountAggregateOutputType = {
    id: number
    phone: number
    amount: number
    network: number
    reference: number
    createdAt: number
    _all: number
  }


  export type AirtimeTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type AirtimeTransactionSumAggregateInputType = {
    amount?: true
  }

  export type AirtimeTransactionMinAggregateInputType = {
    id?: true
    phone?: true
    amount?: true
    network?: true
    reference?: true
    createdAt?: true
  }

  export type AirtimeTransactionMaxAggregateInputType = {
    id?: true
    phone?: true
    amount?: true
    network?: true
    reference?: true
    createdAt?: true
  }

  export type AirtimeTransactionCountAggregateInputType = {
    id?: true
    phone?: true
    amount?: true
    network?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type AirtimeTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AirtimeTransaction to aggregate.
     */
    where?: AirtimeTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirtimeTransactions to fetch.
     */
    orderBy?: AirtimeTransactionOrderByWithRelationInput | AirtimeTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AirtimeTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirtimeTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirtimeTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AirtimeTransactions
    **/
    _count?: true | AirtimeTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirtimeTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirtimeTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirtimeTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirtimeTransactionMaxAggregateInputType
  }

  export type GetAirtimeTransactionAggregateType<T extends AirtimeTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateAirtimeTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirtimeTransaction[P]>
      : GetScalarType<T[P], AggregateAirtimeTransaction[P]>
  }




  export type AirtimeTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirtimeTransactionWhereInput
    orderBy?: AirtimeTransactionOrderByWithAggregationInput | AirtimeTransactionOrderByWithAggregationInput[]
    by: AirtimeTransactionScalarFieldEnum[] | AirtimeTransactionScalarFieldEnum
    having?: AirtimeTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirtimeTransactionCountAggregateInputType | true
    _avg?: AirtimeTransactionAvgAggregateInputType
    _sum?: AirtimeTransactionSumAggregateInputType
    _min?: AirtimeTransactionMinAggregateInputType
    _max?: AirtimeTransactionMaxAggregateInputType
  }

  export type AirtimeTransactionGroupByOutputType = {
    id: string
    phone: string
    amount: number
    network: string
    reference: string
    createdAt: Date
    _count: AirtimeTransactionCountAggregateOutputType | null
    _avg: AirtimeTransactionAvgAggregateOutputType | null
    _sum: AirtimeTransactionSumAggregateOutputType | null
    _min: AirtimeTransactionMinAggregateOutputType | null
    _max: AirtimeTransactionMaxAggregateOutputType | null
  }

  type GetAirtimeTransactionGroupByPayload<T extends AirtimeTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirtimeTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirtimeTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirtimeTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], AirtimeTransactionGroupByOutputType[P]>
        }
      >
    >


  export type AirtimeTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    amount?: boolean
    network?: boolean
    reference?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["airtimeTransaction"]>

  export type AirtimeTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    amount?: boolean
    network?: boolean
    reference?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["airtimeTransaction"]>

  export type AirtimeTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    amount?: boolean
    network?: boolean
    reference?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["airtimeTransaction"]>

  export type AirtimeTransactionSelectScalar = {
    id?: boolean
    phone?: boolean
    amount?: boolean
    network?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type AirtimeTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "amount" | "network" | "reference" | "createdAt", ExtArgs["result"]["airtimeTransaction"]>

  export type $AirtimeTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AirtimeTransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      amount: number
      network: string
      reference: string
      createdAt: Date
    }, ExtArgs["result"]["airtimeTransaction"]>
    composites: {}
  }

  type AirtimeTransactionGetPayload<S extends boolean | null | undefined | AirtimeTransactionDefaultArgs> = $Result.GetResult<Prisma.$AirtimeTransactionPayload, S>

  type AirtimeTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AirtimeTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirtimeTransactionCountAggregateInputType | true
    }

  export interface AirtimeTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AirtimeTransaction'], meta: { name: 'AirtimeTransaction' } }
    /**
     * Find zero or one AirtimeTransaction that matches the filter.
     * @param {AirtimeTransactionFindUniqueArgs} args - Arguments to find a AirtimeTransaction
     * @example
     * // Get one AirtimeTransaction
     * const airtimeTransaction = await prisma.airtimeTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AirtimeTransactionFindUniqueArgs>(args: SelectSubset<T, AirtimeTransactionFindUniqueArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AirtimeTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AirtimeTransactionFindUniqueOrThrowArgs} args - Arguments to find a AirtimeTransaction
     * @example
     * // Get one AirtimeTransaction
     * const airtimeTransaction = await prisma.airtimeTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AirtimeTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, AirtimeTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AirtimeTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirtimeTransactionFindFirstArgs} args - Arguments to find a AirtimeTransaction
     * @example
     * // Get one AirtimeTransaction
     * const airtimeTransaction = await prisma.airtimeTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AirtimeTransactionFindFirstArgs>(args?: SelectSubset<T, AirtimeTransactionFindFirstArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AirtimeTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirtimeTransactionFindFirstOrThrowArgs} args - Arguments to find a AirtimeTransaction
     * @example
     * // Get one AirtimeTransaction
     * const airtimeTransaction = await prisma.airtimeTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AirtimeTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, AirtimeTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AirtimeTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirtimeTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AirtimeTransactions
     * const airtimeTransactions = await prisma.airtimeTransaction.findMany()
     * 
     * // Get first 10 AirtimeTransactions
     * const airtimeTransactions = await prisma.airtimeTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airtimeTransactionWithIdOnly = await prisma.airtimeTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AirtimeTransactionFindManyArgs>(args?: SelectSubset<T, AirtimeTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AirtimeTransaction.
     * @param {AirtimeTransactionCreateArgs} args - Arguments to create a AirtimeTransaction.
     * @example
     * // Create one AirtimeTransaction
     * const AirtimeTransaction = await prisma.airtimeTransaction.create({
     *   data: {
     *     // ... data to create a AirtimeTransaction
     *   }
     * })
     * 
     */
    create<T extends AirtimeTransactionCreateArgs>(args: SelectSubset<T, AirtimeTransactionCreateArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AirtimeTransactions.
     * @param {AirtimeTransactionCreateManyArgs} args - Arguments to create many AirtimeTransactions.
     * @example
     * // Create many AirtimeTransactions
     * const airtimeTransaction = await prisma.airtimeTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AirtimeTransactionCreateManyArgs>(args?: SelectSubset<T, AirtimeTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AirtimeTransactions and returns the data saved in the database.
     * @param {AirtimeTransactionCreateManyAndReturnArgs} args - Arguments to create many AirtimeTransactions.
     * @example
     * // Create many AirtimeTransactions
     * const airtimeTransaction = await prisma.airtimeTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AirtimeTransactions and only return the `id`
     * const airtimeTransactionWithIdOnly = await prisma.airtimeTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AirtimeTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, AirtimeTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AirtimeTransaction.
     * @param {AirtimeTransactionDeleteArgs} args - Arguments to delete one AirtimeTransaction.
     * @example
     * // Delete one AirtimeTransaction
     * const AirtimeTransaction = await prisma.airtimeTransaction.delete({
     *   where: {
     *     // ... filter to delete one AirtimeTransaction
     *   }
     * })
     * 
     */
    delete<T extends AirtimeTransactionDeleteArgs>(args: SelectSubset<T, AirtimeTransactionDeleteArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AirtimeTransaction.
     * @param {AirtimeTransactionUpdateArgs} args - Arguments to update one AirtimeTransaction.
     * @example
     * // Update one AirtimeTransaction
     * const airtimeTransaction = await prisma.airtimeTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AirtimeTransactionUpdateArgs>(args: SelectSubset<T, AirtimeTransactionUpdateArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AirtimeTransactions.
     * @param {AirtimeTransactionDeleteManyArgs} args - Arguments to filter AirtimeTransactions to delete.
     * @example
     * // Delete a few AirtimeTransactions
     * const { count } = await prisma.airtimeTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AirtimeTransactionDeleteManyArgs>(args?: SelectSubset<T, AirtimeTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AirtimeTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirtimeTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AirtimeTransactions
     * const airtimeTransaction = await prisma.airtimeTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AirtimeTransactionUpdateManyArgs>(args: SelectSubset<T, AirtimeTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AirtimeTransactions and returns the data updated in the database.
     * @param {AirtimeTransactionUpdateManyAndReturnArgs} args - Arguments to update many AirtimeTransactions.
     * @example
     * // Update many AirtimeTransactions
     * const airtimeTransaction = await prisma.airtimeTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AirtimeTransactions and only return the `id`
     * const airtimeTransactionWithIdOnly = await prisma.airtimeTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AirtimeTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, AirtimeTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AirtimeTransaction.
     * @param {AirtimeTransactionUpsertArgs} args - Arguments to update or create a AirtimeTransaction.
     * @example
     * // Update or create a AirtimeTransaction
     * const airtimeTransaction = await prisma.airtimeTransaction.upsert({
     *   create: {
     *     // ... data to create a AirtimeTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AirtimeTransaction we want to update
     *   }
     * })
     */
    upsert<T extends AirtimeTransactionUpsertArgs>(args: SelectSubset<T, AirtimeTransactionUpsertArgs<ExtArgs>>): Prisma__AirtimeTransactionClient<$Result.GetResult<Prisma.$AirtimeTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AirtimeTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirtimeTransactionCountArgs} args - Arguments to filter AirtimeTransactions to count.
     * @example
     * // Count the number of AirtimeTransactions
     * const count = await prisma.airtimeTransaction.count({
     *   where: {
     *     // ... the filter for the AirtimeTransactions we want to count
     *   }
     * })
    **/
    count<T extends AirtimeTransactionCountArgs>(
      args?: Subset<T, AirtimeTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirtimeTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AirtimeTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirtimeTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirtimeTransactionAggregateArgs>(args: Subset<T, AirtimeTransactionAggregateArgs>): Prisma.PrismaPromise<GetAirtimeTransactionAggregateType<T>>

    /**
     * Group by AirtimeTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirtimeTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirtimeTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirtimeTransactionGroupByArgs['orderBy'] }
        : { orderBy?: AirtimeTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirtimeTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirtimeTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AirtimeTransaction model
   */
  readonly fields: AirtimeTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AirtimeTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AirtimeTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AirtimeTransaction model
   */
  interface AirtimeTransactionFieldRefs {
    readonly id: FieldRef<"AirtimeTransaction", 'String'>
    readonly phone: FieldRef<"AirtimeTransaction", 'String'>
    readonly amount: FieldRef<"AirtimeTransaction", 'Float'>
    readonly network: FieldRef<"AirtimeTransaction", 'String'>
    readonly reference: FieldRef<"AirtimeTransaction", 'String'>
    readonly createdAt: FieldRef<"AirtimeTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AirtimeTransaction findUnique
   */
  export type AirtimeTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * Filter, which AirtimeTransaction to fetch.
     */
    where: AirtimeTransactionWhereUniqueInput
  }

  /**
   * AirtimeTransaction findUniqueOrThrow
   */
  export type AirtimeTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * Filter, which AirtimeTransaction to fetch.
     */
    where: AirtimeTransactionWhereUniqueInput
  }

  /**
   * AirtimeTransaction findFirst
   */
  export type AirtimeTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * Filter, which AirtimeTransaction to fetch.
     */
    where?: AirtimeTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirtimeTransactions to fetch.
     */
    orderBy?: AirtimeTransactionOrderByWithRelationInput | AirtimeTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AirtimeTransactions.
     */
    cursor?: AirtimeTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirtimeTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirtimeTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AirtimeTransactions.
     */
    distinct?: AirtimeTransactionScalarFieldEnum | AirtimeTransactionScalarFieldEnum[]
  }

  /**
   * AirtimeTransaction findFirstOrThrow
   */
  export type AirtimeTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * Filter, which AirtimeTransaction to fetch.
     */
    where?: AirtimeTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirtimeTransactions to fetch.
     */
    orderBy?: AirtimeTransactionOrderByWithRelationInput | AirtimeTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AirtimeTransactions.
     */
    cursor?: AirtimeTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirtimeTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirtimeTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AirtimeTransactions.
     */
    distinct?: AirtimeTransactionScalarFieldEnum | AirtimeTransactionScalarFieldEnum[]
  }

  /**
   * AirtimeTransaction findMany
   */
  export type AirtimeTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * Filter, which AirtimeTransactions to fetch.
     */
    where?: AirtimeTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirtimeTransactions to fetch.
     */
    orderBy?: AirtimeTransactionOrderByWithRelationInput | AirtimeTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AirtimeTransactions.
     */
    cursor?: AirtimeTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirtimeTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirtimeTransactions.
     */
    skip?: number
    distinct?: AirtimeTransactionScalarFieldEnum | AirtimeTransactionScalarFieldEnum[]
  }

  /**
   * AirtimeTransaction create
   */
  export type AirtimeTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a AirtimeTransaction.
     */
    data: XOR<AirtimeTransactionCreateInput, AirtimeTransactionUncheckedCreateInput>
  }

  /**
   * AirtimeTransaction createMany
   */
  export type AirtimeTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AirtimeTransactions.
     */
    data: AirtimeTransactionCreateManyInput | AirtimeTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AirtimeTransaction createManyAndReturn
   */
  export type AirtimeTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many AirtimeTransactions.
     */
    data: AirtimeTransactionCreateManyInput | AirtimeTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AirtimeTransaction update
   */
  export type AirtimeTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a AirtimeTransaction.
     */
    data: XOR<AirtimeTransactionUpdateInput, AirtimeTransactionUncheckedUpdateInput>
    /**
     * Choose, which AirtimeTransaction to update.
     */
    where: AirtimeTransactionWhereUniqueInput
  }

  /**
   * AirtimeTransaction updateMany
   */
  export type AirtimeTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AirtimeTransactions.
     */
    data: XOR<AirtimeTransactionUpdateManyMutationInput, AirtimeTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AirtimeTransactions to update
     */
    where?: AirtimeTransactionWhereInput
    /**
     * Limit how many AirtimeTransactions to update.
     */
    limit?: number
  }

  /**
   * AirtimeTransaction updateManyAndReturn
   */
  export type AirtimeTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * The data used to update AirtimeTransactions.
     */
    data: XOR<AirtimeTransactionUpdateManyMutationInput, AirtimeTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AirtimeTransactions to update
     */
    where?: AirtimeTransactionWhereInput
    /**
     * Limit how many AirtimeTransactions to update.
     */
    limit?: number
  }

  /**
   * AirtimeTransaction upsert
   */
  export type AirtimeTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the AirtimeTransaction to update in case it exists.
     */
    where: AirtimeTransactionWhereUniqueInput
    /**
     * In case the AirtimeTransaction found by the `where` argument doesn't exist, create a new AirtimeTransaction with this data.
     */
    create: XOR<AirtimeTransactionCreateInput, AirtimeTransactionUncheckedCreateInput>
    /**
     * In case the AirtimeTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AirtimeTransactionUpdateInput, AirtimeTransactionUncheckedUpdateInput>
  }

  /**
   * AirtimeTransaction delete
   */
  export type AirtimeTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
    /**
     * Filter which AirtimeTransaction to delete.
     */
    where: AirtimeTransactionWhereUniqueInput
  }

  /**
   * AirtimeTransaction deleteMany
   */
  export type AirtimeTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AirtimeTransactions to delete
     */
    where?: AirtimeTransactionWhereInput
    /**
     * Limit how many AirtimeTransactions to delete.
     */
    limit?: number
  }

  /**
   * AirtimeTransaction without action
   */
  export type AirtimeTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirtimeTransaction
     */
    select?: AirtimeTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirtimeTransaction
     */
    omit?: AirtimeTransactionOmit<ExtArgs> | null
  }


  /**
   * Model Subaccount
   */

  export type AggregateSubaccount = {
    _count: SubaccountCountAggregateOutputType | null
    _avg: SubaccountAvgAggregateOutputType | null
    _sum: SubaccountSumAggregateOutputType | null
    _min: SubaccountMinAggregateOutputType | null
    _max: SubaccountMaxAggregateOutputType | null
  }

  export type SubaccountAvgAggregateOutputType = {
    percentageCharge: number | null
  }

  export type SubaccountSumAggregateOutputType = {
    percentageCharge: number | null
  }

  export type SubaccountMinAggregateOutputType = {
    id: string | null
    businessName: string | null
    bankCode: string | null
    accountNumber: string | null
    percentageCharge: number | null
    subaccountCode: string | null
    createdAt: Date | null
    lastPaidAt: Date | null
  }

  export type SubaccountMaxAggregateOutputType = {
    id: string | null
    businessName: string | null
    bankCode: string | null
    accountNumber: string | null
    percentageCharge: number | null
    subaccountCode: string | null
    createdAt: Date | null
    lastPaidAt: Date | null
  }

  export type SubaccountCountAggregateOutputType = {
    id: number
    businessName: number
    bankCode: number
    accountNumber: number
    percentageCharge: number
    subaccountCode: number
    createdAt: number
    lastPaidAt: number
    _all: number
  }


  export type SubaccountAvgAggregateInputType = {
    percentageCharge?: true
  }

  export type SubaccountSumAggregateInputType = {
    percentageCharge?: true
  }

  export type SubaccountMinAggregateInputType = {
    id?: true
    businessName?: true
    bankCode?: true
    accountNumber?: true
    percentageCharge?: true
    subaccountCode?: true
    createdAt?: true
    lastPaidAt?: true
  }

  export type SubaccountMaxAggregateInputType = {
    id?: true
    businessName?: true
    bankCode?: true
    accountNumber?: true
    percentageCharge?: true
    subaccountCode?: true
    createdAt?: true
    lastPaidAt?: true
  }

  export type SubaccountCountAggregateInputType = {
    id?: true
    businessName?: true
    bankCode?: true
    accountNumber?: true
    percentageCharge?: true
    subaccountCode?: true
    createdAt?: true
    lastPaidAt?: true
    _all?: true
  }

  export type SubaccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subaccount to aggregate.
     */
    where?: SubaccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subaccounts to fetch.
     */
    orderBy?: SubaccountOrderByWithRelationInput | SubaccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubaccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subaccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subaccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subaccounts
    **/
    _count?: true | SubaccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubaccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubaccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubaccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubaccountMaxAggregateInputType
  }

  export type GetSubaccountAggregateType<T extends SubaccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSubaccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubaccount[P]>
      : GetScalarType<T[P], AggregateSubaccount[P]>
  }




  export type SubaccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubaccountWhereInput
    orderBy?: SubaccountOrderByWithAggregationInput | SubaccountOrderByWithAggregationInput[]
    by: SubaccountScalarFieldEnum[] | SubaccountScalarFieldEnum
    having?: SubaccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubaccountCountAggregateInputType | true
    _avg?: SubaccountAvgAggregateInputType
    _sum?: SubaccountSumAggregateInputType
    _min?: SubaccountMinAggregateInputType
    _max?: SubaccountMaxAggregateInputType
  }

  export type SubaccountGroupByOutputType = {
    id: string
    businessName: string
    bankCode: string
    accountNumber: string
    percentageCharge: number
    subaccountCode: string
    createdAt: Date
    lastPaidAt: Date | null
    _count: SubaccountCountAggregateOutputType | null
    _avg: SubaccountAvgAggregateOutputType | null
    _sum: SubaccountSumAggregateOutputType | null
    _min: SubaccountMinAggregateOutputType | null
    _max: SubaccountMaxAggregateOutputType | null
  }

  type GetSubaccountGroupByPayload<T extends SubaccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubaccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubaccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubaccountGroupByOutputType[P]>
            : GetScalarType<T[P], SubaccountGroupByOutputType[P]>
        }
      >
    >


  export type SubaccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    percentageCharge?: boolean
    subaccountCode?: boolean
    createdAt?: boolean
    lastPaidAt?: boolean
    subaccountSplits?: boolean | Subaccount$subaccountSplitsArgs<ExtArgs>
    _count?: boolean | SubaccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subaccount"]>

  export type SubaccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    percentageCharge?: boolean
    subaccountCode?: boolean
    createdAt?: boolean
    lastPaidAt?: boolean
  }, ExtArgs["result"]["subaccount"]>

  export type SubaccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    percentageCharge?: boolean
    subaccountCode?: boolean
    createdAt?: boolean
    lastPaidAt?: boolean
  }, ExtArgs["result"]["subaccount"]>

  export type SubaccountSelectScalar = {
    id?: boolean
    businessName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    percentageCharge?: boolean
    subaccountCode?: boolean
    createdAt?: boolean
    lastPaidAt?: boolean
  }

  export type SubaccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessName" | "bankCode" | "accountNumber" | "percentageCharge" | "subaccountCode" | "createdAt" | "lastPaidAt", ExtArgs["result"]["subaccount"]>
  export type SubaccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccountSplits?: boolean | Subaccount$subaccountSplitsArgs<ExtArgs>
    _count?: boolean | SubaccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubaccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubaccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubaccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subaccount"
    objects: {
      subaccountSplits: Prisma.$SubaccountSplitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessName: string
      bankCode: string
      accountNumber: string
      percentageCharge: number
      subaccountCode: string
      createdAt: Date
      lastPaidAt: Date | null
    }, ExtArgs["result"]["subaccount"]>
    composites: {}
  }

  type SubaccountGetPayload<S extends boolean | null | undefined | SubaccountDefaultArgs> = $Result.GetResult<Prisma.$SubaccountPayload, S>

  type SubaccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubaccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubaccountCountAggregateInputType | true
    }

  export interface SubaccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subaccount'], meta: { name: 'Subaccount' } }
    /**
     * Find zero or one Subaccount that matches the filter.
     * @param {SubaccountFindUniqueArgs} args - Arguments to find a Subaccount
     * @example
     * // Get one Subaccount
     * const subaccount = await prisma.subaccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubaccountFindUniqueArgs>(args: SelectSubset<T, SubaccountFindUniqueArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subaccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubaccountFindUniqueOrThrowArgs} args - Arguments to find a Subaccount
     * @example
     * // Get one Subaccount
     * const subaccount = await prisma.subaccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubaccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SubaccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subaccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountFindFirstArgs} args - Arguments to find a Subaccount
     * @example
     * // Get one Subaccount
     * const subaccount = await prisma.subaccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubaccountFindFirstArgs>(args?: SelectSubset<T, SubaccountFindFirstArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subaccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountFindFirstOrThrowArgs} args - Arguments to find a Subaccount
     * @example
     * // Get one Subaccount
     * const subaccount = await prisma.subaccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubaccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SubaccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subaccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subaccounts
     * const subaccounts = await prisma.subaccount.findMany()
     * 
     * // Get first 10 Subaccounts
     * const subaccounts = await prisma.subaccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subaccountWithIdOnly = await prisma.subaccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubaccountFindManyArgs>(args?: SelectSubset<T, SubaccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subaccount.
     * @param {SubaccountCreateArgs} args - Arguments to create a Subaccount.
     * @example
     * // Create one Subaccount
     * const Subaccount = await prisma.subaccount.create({
     *   data: {
     *     // ... data to create a Subaccount
     *   }
     * })
     * 
     */
    create<T extends SubaccountCreateArgs>(args: SelectSubset<T, SubaccountCreateArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subaccounts.
     * @param {SubaccountCreateManyArgs} args - Arguments to create many Subaccounts.
     * @example
     * // Create many Subaccounts
     * const subaccount = await prisma.subaccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubaccountCreateManyArgs>(args?: SelectSubset<T, SubaccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subaccounts and returns the data saved in the database.
     * @param {SubaccountCreateManyAndReturnArgs} args - Arguments to create many Subaccounts.
     * @example
     * // Create many Subaccounts
     * const subaccount = await prisma.subaccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subaccounts and only return the `id`
     * const subaccountWithIdOnly = await prisma.subaccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubaccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SubaccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subaccount.
     * @param {SubaccountDeleteArgs} args - Arguments to delete one Subaccount.
     * @example
     * // Delete one Subaccount
     * const Subaccount = await prisma.subaccount.delete({
     *   where: {
     *     // ... filter to delete one Subaccount
     *   }
     * })
     * 
     */
    delete<T extends SubaccountDeleteArgs>(args: SelectSubset<T, SubaccountDeleteArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subaccount.
     * @param {SubaccountUpdateArgs} args - Arguments to update one Subaccount.
     * @example
     * // Update one Subaccount
     * const subaccount = await prisma.subaccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubaccountUpdateArgs>(args: SelectSubset<T, SubaccountUpdateArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subaccounts.
     * @param {SubaccountDeleteManyArgs} args - Arguments to filter Subaccounts to delete.
     * @example
     * // Delete a few Subaccounts
     * const { count } = await prisma.subaccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubaccountDeleteManyArgs>(args?: SelectSubset<T, SubaccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subaccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subaccounts
     * const subaccount = await prisma.subaccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubaccountUpdateManyArgs>(args: SelectSubset<T, SubaccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subaccounts and returns the data updated in the database.
     * @param {SubaccountUpdateManyAndReturnArgs} args - Arguments to update many Subaccounts.
     * @example
     * // Update many Subaccounts
     * const subaccount = await prisma.subaccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subaccounts and only return the `id`
     * const subaccountWithIdOnly = await prisma.subaccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubaccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SubaccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subaccount.
     * @param {SubaccountUpsertArgs} args - Arguments to update or create a Subaccount.
     * @example
     * // Update or create a Subaccount
     * const subaccount = await prisma.subaccount.upsert({
     *   create: {
     *     // ... data to create a Subaccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subaccount we want to update
     *   }
     * })
     */
    upsert<T extends SubaccountUpsertArgs>(args: SelectSubset<T, SubaccountUpsertArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subaccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountCountArgs} args - Arguments to filter Subaccounts to count.
     * @example
     * // Count the number of Subaccounts
     * const count = await prisma.subaccount.count({
     *   where: {
     *     // ... the filter for the Subaccounts we want to count
     *   }
     * })
    **/
    count<T extends SubaccountCountArgs>(
      args?: Subset<T, SubaccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubaccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subaccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubaccountAggregateArgs>(args: Subset<T, SubaccountAggregateArgs>): Prisma.PrismaPromise<GetSubaccountAggregateType<T>>

    /**
     * Group by Subaccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubaccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubaccountGroupByArgs['orderBy'] }
        : { orderBy?: SubaccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubaccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubaccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subaccount model
   */
  readonly fields: SubaccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subaccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubaccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subaccountSplits<T extends Subaccount$subaccountSplitsArgs<ExtArgs> = {}>(args?: Subset<T, Subaccount$subaccountSplitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subaccount model
   */
  interface SubaccountFieldRefs {
    readonly id: FieldRef<"Subaccount", 'String'>
    readonly businessName: FieldRef<"Subaccount", 'String'>
    readonly bankCode: FieldRef<"Subaccount", 'String'>
    readonly accountNumber: FieldRef<"Subaccount", 'String'>
    readonly percentageCharge: FieldRef<"Subaccount", 'Float'>
    readonly subaccountCode: FieldRef<"Subaccount", 'String'>
    readonly createdAt: FieldRef<"Subaccount", 'DateTime'>
    readonly lastPaidAt: FieldRef<"Subaccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subaccount findUnique
   */
  export type SubaccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * Filter, which Subaccount to fetch.
     */
    where: SubaccountWhereUniqueInput
  }

  /**
   * Subaccount findUniqueOrThrow
   */
  export type SubaccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * Filter, which Subaccount to fetch.
     */
    where: SubaccountWhereUniqueInput
  }

  /**
   * Subaccount findFirst
   */
  export type SubaccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * Filter, which Subaccount to fetch.
     */
    where?: SubaccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subaccounts to fetch.
     */
    orderBy?: SubaccountOrderByWithRelationInput | SubaccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subaccounts.
     */
    cursor?: SubaccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subaccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subaccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subaccounts.
     */
    distinct?: SubaccountScalarFieldEnum | SubaccountScalarFieldEnum[]
  }

  /**
   * Subaccount findFirstOrThrow
   */
  export type SubaccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * Filter, which Subaccount to fetch.
     */
    where?: SubaccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subaccounts to fetch.
     */
    orderBy?: SubaccountOrderByWithRelationInput | SubaccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subaccounts.
     */
    cursor?: SubaccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subaccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subaccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subaccounts.
     */
    distinct?: SubaccountScalarFieldEnum | SubaccountScalarFieldEnum[]
  }

  /**
   * Subaccount findMany
   */
  export type SubaccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * Filter, which Subaccounts to fetch.
     */
    where?: SubaccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subaccounts to fetch.
     */
    orderBy?: SubaccountOrderByWithRelationInput | SubaccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subaccounts.
     */
    cursor?: SubaccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subaccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subaccounts.
     */
    skip?: number
    distinct?: SubaccountScalarFieldEnum | SubaccountScalarFieldEnum[]
  }

  /**
   * Subaccount create
   */
  export type SubaccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Subaccount.
     */
    data: XOR<SubaccountCreateInput, SubaccountUncheckedCreateInput>
  }

  /**
   * Subaccount createMany
   */
  export type SubaccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subaccounts.
     */
    data: SubaccountCreateManyInput | SubaccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subaccount createManyAndReturn
   */
  export type SubaccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * The data used to create many Subaccounts.
     */
    data: SubaccountCreateManyInput | SubaccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subaccount update
   */
  export type SubaccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Subaccount.
     */
    data: XOR<SubaccountUpdateInput, SubaccountUncheckedUpdateInput>
    /**
     * Choose, which Subaccount to update.
     */
    where: SubaccountWhereUniqueInput
  }

  /**
   * Subaccount updateMany
   */
  export type SubaccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subaccounts.
     */
    data: XOR<SubaccountUpdateManyMutationInput, SubaccountUncheckedUpdateManyInput>
    /**
     * Filter which Subaccounts to update
     */
    where?: SubaccountWhereInput
    /**
     * Limit how many Subaccounts to update.
     */
    limit?: number
  }

  /**
   * Subaccount updateManyAndReturn
   */
  export type SubaccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * The data used to update Subaccounts.
     */
    data: XOR<SubaccountUpdateManyMutationInput, SubaccountUncheckedUpdateManyInput>
    /**
     * Filter which Subaccounts to update
     */
    where?: SubaccountWhereInput
    /**
     * Limit how many Subaccounts to update.
     */
    limit?: number
  }

  /**
   * Subaccount upsert
   */
  export type SubaccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Subaccount to update in case it exists.
     */
    where: SubaccountWhereUniqueInput
    /**
     * In case the Subaccount found by the `where` argument doesn't exist, create a new Subaccount with this data.
     */
    create: XOR<SubaccountCreateInput, SubaccountUncheckedCreateInput>
    /**
     * In case the Subaccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubaccountUpdateInput, SubaccountUncheckedUpdateInput>
  }

  /**
   * Subaccount delete
   */
  export type SubaccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
    /**
     * Filter which Subaccount to delete.
     */
    where: SubaccountWhereUniqueInput
  }

  /**
   * Subaccount deleteMany
   */
  export type SubaccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subaccounts to delete
     */
    where?: SubaccountWhereInput
    /**
     * Limit how many Subaccounts to delete.
     */
    limit?: number
  }

  /**
   * Subaccount.subaccountSplits
   */
  export type Subaccount$subaccountSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    where?: SubaccountSplitWhereInput
    orderBy?: SubaccountSplitOrderByWithRelationInput | SubaccountSplitOrderByWithRelationInput[]
    cursor?: SubaccountSplitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubaccountSplitScalarFieldEnum | SubaccountSplitScalarFieldEnum[]
  }

  /**
   * Subaccount without action
   */
  export type SubaccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subaccount
     */
    select?: SubaccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subaccount
     */
    omit?: SubaccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountInclude<ExtArgs> | null
  }


  /**
   * Model SubaccountSplit
   */

  export type AggregateSubaccountSplit = {
    _count: SubaccountSplitCountAggregateOutputType | null
    _avg: SubaccountSplitAvgAggregateOutputType | null
    _sum: SubaccountSplitSumAggregateOutputType | null
    _min: SubaccountSplitMinAggregateOutputType | null
    _max: SubaccountSplitMaxAggregateOutputType | null
  }

  export type SubaccountSplitAvgAggregateOutputType = {
    share: number | null
  }

  export type SubaccountSplitSumAggregateOutputType = {
    share: number | null
  }

  export type SubaccountSplitMinAggregateOutputType = {
    id: string | null
    subaccountId: string | null
    splitGroupId: string | null
    share: number | null
  }

  export type SubaccountSplitMaxAggregateOutputType = {
    id: string | null
    subaccountId: string | null
    splitGroupId: string | null
    share: number | null
  }

  export type SubaccountSplitCountAggregateOutputType = {
    id: number
    subaccountId: number
    splitGroupId: number
    share: number
    _all: number
  }


  export type SubaccountSplitAvgAggregateInputType = {
    share?: true
  }

  export type SubaccountSplitSumAggregateInputType = {
    share?: true
  }

  export type SubaccountSplitMinAggregateInputType = {
    id?: true
    subaccountId?: true
    splitGroupId?: true
    share?: true
  }

  export type SubaccountSplitMaxAggregateInputType = {
    id?: true
    subaccountId?: true
    splitGroupId?: true
    share?: true
  }

  export type SubaccountSplitCountAggregateInputType = {
    id?: true
    subaccountId?: true
    splitGroupId?: true
    share?: true
    _all?: true
  }

  export type SubaccountSplitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubaccountSplit to aggregate.
     */
    where?: SubaccountSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubaccountSplits to fetch.
     */
    orderBy?: SubaccountSplitOrderByWithRelationInput | SubaccountSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubaccountSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubaccountSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubaccountSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubaccountSplits
    **/
    _count?: true | SubaccountSplitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubaccountSplitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubaccountSplitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubaccountSplitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubaccountSplitMaxAggregateInputType
  }

  export type GetSubaccountSplitAggregateType<T extends SubaccountSplitAggregateArgs> = {
        [P in keyof T & keyof AggregateSubaccountSplit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubaccountSplit[P]>
      : GetScalarType<T[P], AggregateSubaccountSplit[P]>
  }




  export type SubaccountSplitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubaccountSplitWhereInput
    orderBy?: SubaccountSplitOrderByWithAggregationInput | SubaccountSplitOrderByWithAggregationInput[]
    by: SubaccountSplitScalarFieldEnum[] | SubaccountSplitScalarFieldEnum
    having?: SubaccountSplitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubaccountSplitCountAggregateInputType | true
    _avg?: SubaccountSplitAvgAggregateInputType
    _sum?: SubaccountSplitSumAggregateInputType
    _min?: SubaccountSplitMinAggregateInputType
    _max?: SubaccountSplitMaxAggregateInputType
  }

  export type SubaccountSplitGroupByOutputType = {
    id: string
    subaccountId: string
    splitGroupId: string
    share: number
    _count: SubaccountSplitCountAggregateOutputType | null
    _avg: SubaccountSplitAvgAggregateOutputType | null
    _sum: SubaccountSplitSumAggregateOutputType | null
    _min: SubaccountSplitMinAggregateOutputType | null
    _max: SubaccountSplitMaxAggregateOutputType | null
  }

  type GetSubaccountSplitGroupByPayload<T extends SubaccountSplitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubaccountSplitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubaccountSplitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubaccountSplitGroupByOutputType[P]>
            : GetScalarType<T[P], SubaccountSplitGroupByOutputType[P]>
        }
      >
    >


  export type SubaccountSplitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subaccountId?: boolean
    splitGroupId?: boolean
    share?: boolean
    subaccount?: boolean | SubaccountDefaultArgs<ExtArgs>
    splitGroup?: boolean | SplitGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subaccountSplit"]>

  export type SubaccountSplitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subaccountId?: boolean
    splitGroupId?: boolean
    share?: boolean
    subaccount?: boolean | SubaccountDefaultArgs<ExtArgs>
    splitGroup?: boolean | SplitGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subaccountSplit"]>

  export type SubaccountSplitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subaccountId?: boolean
    splitGroupId?: boolean
    share?: boolean
    subaccount?: boolean | SubaccountDefaultArgs<ExtArgs>
    splitGroup?: boolean | SplitGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subaccountSplit"]>

  export type SubaccountSplitSelectScalar = {
    id?: boolean
    subaccountId?: boolean
    splitGroupId?: boolean
    share?: boolean
  }

  export type SubaccountSplitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subaccountId" | "splitGroupId" | "share", ExtArgs["result"]["subaccountSplit"]>
  export type SubaccountSplitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubaccountDefaultArgs<ExtArgs>
    splitGroup?: boolean | SplitGroupDefaultArgs<ExtArgs>
  }
  export type SubaccountSplitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubaccountDefaultArgs<ExtArgs>
    splitGroup?: boolean | SplitGroupDefaultArgs<ExtArgs>
  }
  export type SubaccountSplitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccount?: boolean | SubaccountDefaultArgs<ExtArgs>
    splitGroup?: boolean | SplitGroupDefaultArgs<ExtArgs>
  }

  export type $SubaccountSplitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubaccountSplit"
    objects: {
      subaccount: Prisma.$SubaccountPayload<ExtArgs>
      splitGroup: Prisma.$SplitGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subaccountId: string
      splitGroupId: string
      share: number
    }, ExtArgs["result"]["subaccountSplit"]>
    composites: {}
  }

  type SubaccountSplitGetPayload<S extends boolean | null | undefined | SubaccountSplitDefaultArgs> = $Result.GetResult<Prisma.$SubaccountSplitPayload, S>

  type SubaccountSplitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubaccountSplitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubaccountSplitCountAggregateInputType | true
    }

  export interface SubaccountSplitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubaccountSplit'], meta: { name: 'SubaccountSplit' } }
    /**
     * Find zero or one SubaccountSplit that matches the filter.
     * @param {SubaccountSplitFindUniqueArgs} args - Arguments to find a SubaccountSplit
     * @example
     * // Get one SubaccountSplit
     * const subaccountSplit = await prisma.subaccountSplit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubaccountSplitFindUniqueArgs>(args: SelectSubset<T, SubaccountSplitFindUniqueArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubaccountSplit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubaccountSplitFindUniqueOrThrowArgs} args - Arguments to find a SubaccountSplit
     * @example
     * // Get one SubaccountSplit
     * const subaccountSplit = await prisma.subaccountSplit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubaccountSplitFindUniqueOrThrowArgs>(args: SelectSubset<T, SubaccountSplitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubaccountSplit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountSplitFindFirstArgs} args - Arguments to find a SubaccountSplit
     * @example
     * // Get one SubaccountSplit
     * const subaccountSplit = await prisma.subaccountSplit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubaccountSplitFindFirstArgs>(args?: SelectSubset<T, SubaccountSplitFindFirstArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubaccountSplit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountSplitFindFirstOrThrowArgs} args - Arguments to find a SubaccountSplit
     * @example
     * // Get one SubaccountSplit
     * const subaccountSplit = await prisma.subaccountSplit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubaccountSplitFindFirstOrThrowArgs>(args?: SelectSubset<T, SubaccountSplitFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubaccountSplits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountSplitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubaccountSplits
     * const subaccountSplits = await prisma.subaccountSplit.findMany()
     * 
     * // Get first 10 SubaccountSplits
     * const subaccountSplits = await prisma.subaccountSplit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subaccountSplitWithIdOnly = await prisma.subaccountSplit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubaccountSplitFindManyArgs>(args?: SelectSubset<T, SubaccountSplitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubaccountSplit.
     * @param {SubaccountSplitCreateArgs} args - Arguments to create a SubaccountSplit.
     * @example
     * // Create one SubaccountSplit
     * const SubaccountSplit = await prisma.subaccountSplit.create({
     *   data: {
     *     // ... data to create a SubaccountSplit
     *   }
     * })
     * 
     */
    create<T extends SubaccountSplitCreateArgs>(args: SelectSubset<T, SubaccountSplitCreateArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubaccountSplits.
     * @param {SubaccountSplitCreateManyArgs} args - Arguments to create many SubaccountSplits.
     * @example
     * // Create many SubaccountSplits
     * const subaccountSplit = await prisma.subaccountSplit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubaccountSplitCreateManyArgs>(args?: SelectSubset<T, SubaccountSplitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubaccountSplits and returns the data saved in the database.
     * @param {SubaccountSplitCreateManyAndReturnArgs} args - Arguments to create many SubaccountSplits.
     * @example
     * // Create many SubaccountSplits
     * const subaccountSplit = await prisma.subaccountSplit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubaccountSplits and only return the `id`
     * const subaccountSplitWithIdOnly = await prisma.subaccountSplit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubaccountSplitCreateManyAndReturnArgs>(args?: SelectSubset<T, SubaccountSplitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubaccountSplit.
     * @param {SubaccountSplitDeleteArgs} args - Arguments to delete one SubaccountSplit.
     * @example
     * // Delete one SubaccountSplit
     * const SubaccountSplit = await prisma.subaccountSplit.delete({
     *   where: {
     *     // ... filter to delete one SubaccountSplit
     *   }
     * })
     * 
     */
    delete<T extends SubaccountSplitDeleteArgs>(args: SelectSubset<T, SubaccountSplitDeleteArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubaccountSplit.
     * @param {SubaccountSplitUpdateArgs} args - Arguments to update one SubaccountSplit.
     * @example
     * // Update one SubaccountSplit
     * const subaccountSplit = await prisma.subaccountSplit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubaccountSplitUpdateArgs>(args: SelectSubset<T, SubaccountSplitUpdateArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubaccountSplits.
     * @param {SubaccountSplitDeleteManyArgs} args - Arguments to filter SubaccountSplits to delete.
     * @example
     * // Delete a few SubaccountSplits
     * const { count } = await prisma.subaccountSplit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubaccountSplitDeleteManyArgs>(args?: SelectSubset<T, SubaccountSplitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubaccountSplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountSplitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubaccountSplits
     * const subaccountSplit = await prisma.subaccountSplit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubaccountSplitUpdateManyArgs>(args: SelectSubset<T, SubaccountSplitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubaccountSplits and returns the data updated in the database.
     * @param {SubaccountSplitUpdateManyAndReturnArgs} args - Arguments to update many SubaccountSplits.
     * @example
     * // Update many SubaccountSplits
     * const subaccountSplit = await prisma.subaccountSplit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubaccountSplits and only return the `id`
     * const subaccountSplitWithIdOnly = await prisma.subaccountSplit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubaccountSplitUpdateManyAndReturnArgs>(args: SelectSubset<T, SubaccountSplitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubaccountSplit.
     * @param {SubaccountSplitUpsertArgs} args - Arguments to update or create a SubaccountSplit.
     * @example
     * // Update or create a SubaccountSplit
     * const subaccountSplit = await prisma.subaccountSplit.upsert({
     *   create: {
     *     // ... data to create a SubaccountSplit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubaccountSplit we want to update
     *   }
     * })
     */
    upsert<T extends SubaccountSplitUpsertArgs>(args: SelectSubset<T, SubaccountSplitUpsertArgs<ExtArgs>>): Prisma__SubaccountSplitClient<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubaccountSplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountSplitCountArgs} args - Arguments to filter SubaccountSplits to count.
     * @example
     * // Count the number of SubaccountSplits
     * const count = await prisma.subaccountSplit.count({
     *   where: {
     *     // ... the filter for the SubaccountSplits we want to count
     *   }
     * })
    **/
    count<T extends SubaccountSplitCountArgs>(
      args?: Subset<T, SubaccountSplitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubaccountSplitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubaccountSplit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountSplitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubaccountSplitAggregateArgs>(args: Subset<T, SubaccountSplitAggregateArgs>): Prisma.PrismaPromise<GetSubaccountSplitAggregateType<T>>

    /**
     * Group by SubaccountSplit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubaccountSplitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubaccountSplitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubaccountSplitGroupByArgs['orderBy'] }
        : { orderBy?: SubaccountSplitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubaccountSplitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubaccountSplitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubaccountSplit model
   */
  readonly fields: SubaccountSplitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubaccountSplit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubaccountSplitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subaccount<T extends SubaccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubaccountDefaultArgs<ExtArgs>>): Prisma__SubaccountClient<$Result.GetResult<Prisma.$SubaccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    splitGroup<T extends SplitGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SplitGroupDefaultArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubaccountSplit model
   */
  interface SubaccountSplitFieldRefs {
    readonly id: FieldRef<"SubaccountSplit", 'String'>
    readonly subaccountId: FieldRef<"SubaccountSplit", 'String'>
    readonly splitGroupId: FieldRef<"SubaccountSplit", 'String'>
    readonly share: FieldRef<"SubaccountSplit", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * SubaccountSplit findUnique
   */
  export type SubaccountSplitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * Filter, which SubaccountSplit to fetch.
     */
    where: SubaccountSplitWhereUniqueInput
  }

  /**
   * SubaccountSplit findUniqueOrThrow
   */
  export type SubaccountSplitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * Filter, which SubaccountSplit to fetch.
     */
    where: SubaccountSplitWhereUniqueInput
  }

  /**
   * SubaccountSplit findFirst
   */
  export type SubaccountSplitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * Filter, which SubaccountSplit to fetch.
     */
    where?: SubaccountSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubaccountSplits to fetch.
     */
    orderBy?: SubaccountSplitOrderByWithRelationInput | SubaccountSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubaccountSplits.
     */
    cursor?: SubaccountSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubaccountSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubaccountSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubaccountSplits.
     */
    distinct?: SubaccountSplitScalarFieldEnum | SubaccountSplitScalarFieldEnum[]
  }

  /**
   * SubaccountSplit findFirstOrThrow
   */
  export type SubaccountSplitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * Filter, which SubaccountSplit to fetch.
     */
    where?: SubaccountSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubaccountSplits to fetch.
     */
    orderBy?: SubaccountSplitOrderByWithRelationInput | SubaccountSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubaccountSplits.
     */
    cursor?: SubaccountSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubaccountSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubaccountSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubaccountSplits.
     */
    distinct?: SubaccountSplitScalarFieldEnum | SubaccountSplitScalarFieldEnum[]
  }

  /**
   * SubaccountSplit findMany
   */
  export type SubaccountSplitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * Filter, which SubaccountSplits to fetch.
     */
    where?: SubaccountSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubaccountSplits to fetch.
     */
    orderBy?: SubaccountSplitOrderByWithRelationInput | SubaccountSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubaccountSplits.
     */
    cursor?: SubaccountSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubaccountSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubaccountSplits.
     */
    skip?: number
    distinct?: SubaccountSplitScalarFieldEnum | SubaccountSplitScalarFieldEnum[]
  }

  /**
   * SubaccountSplit create
   */
  export type SubaccountSplitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * The data needed to create a SubaccountSplit.
     */
    data: XOR<SubaccountSplitCreateInput, SubaccountSplitUncheckedCreateInput>
  }

  /**
   * SubaccountSplit createMany
   */
  export type SubaccountSplitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubaccountSplits.
     */
    data: SubaccountSplitCreateManyInput | SubaccountSplitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubaccountSplit createManyAndReturn
   */
  export type SubaccountSplitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * The data used to create many SubaccountSplits.
     */
    data: SubaccountSplitCreateManyInput | SubaccountSplitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubaccountSplit update
   */
  export type SubaccountSplitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * The data needed to update a SubaccountSplit.
     */
    data: XOR<SubaccountSplitUpdateInput, SubaccountSplitUncheckedUpdateInput>
    /**
     * Choose, which SubaccountSplit to update.
     */
    where: SubaccountSplitWhereUniqueInput
  }

  /**
   * SubaccountSplit updateMany
   */
  export type SubaccountSplitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubaccountSplits.
     */
    data: XOR<SubaccountSplitUpdateManyMutationInput, SubaccountSplitUncheckedUpdateManyInput>
    /**
     * Filter which SubaccountSplits to update
     */
    where?: SubaccountSplitWhereInput
    /**
     * Limit how many SubaccountSplits to update.
     */
    limit?: number
  }

  /**
   * SubaccountSplit updateManyAndReturn
   */
  export type SubaccountSplitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * The data used to update SubaccountSplits.
     */
    data: XOR<SubaccountSplitUpdateManyMutationInput, SubaccountSplitUncheckedUpdateManyInput>
    /**
     * Filter which SubaccountSplits to update
     */
    where?: SubaccountSplitWhereInput
    /**
     * Limit how many SubaccountSplits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubaccountSplit upsert
   */
  export type SubaccountSplitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * The filter to search for the SubaccountSplit to update in case it exists.
     */
    where: SubaccountSplitWhereUniqueInput
    /**
     * In case the SubaccountSplit found by the `where` argument doesn't exist, create a new SubaccountSplit with this data.
     */
    create: XOR<SubaccountSplitCreateInput, SubaccountSplitUncheckedCreateInput>
    /**
     * In case the SubaccountSplit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubaccountSplitUpdateInput, SubaccountSplitUncheckedUpdateInput>
  }

  /**
   * SubaccountSplit delete
   */
  export type SubaccountSplitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    /**
     * Filter which SubaccountSplit to delete.
     */
    where: SubaccountSplitWhereUniqueInput
  }

  /**
   * SubaccountSplit deleteMany
   */
  export type SubaccountSplitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubaccountSplits to delete
     */
    where?: SubaccountSplitWhereInput
    /**
     * Limit how many SubaccountSplits to delete.
     */
    limit?: number
  }

  /**
   * SubaccountSplit without action
   */
  export type SubaccountSplitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
  }


  /**
   * Model SplitGroup
   */

  export type AggregateSplitGroup = {
    _count: SplitGroupCountAggregateOutputType | null
    _min: SplitGroupMinAggregateOutputType | null
    _max: SplitGroupMaxAggregateOutputType | null
  }

  export type SplitGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    currency: string | null
    splitCode: string | null
    bearerType: string | null
    bearerSubaccount: string | null
    createdAt: Date | null
  }

  export type SplitGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    currency: string | null
    splitCode: string | null
    bearerType: string | null
    bearerSubaccount: string | null
    createdAt: Date | null
  }

  export type SplitGroupCountAggregateOutputType = {
    id: number
    name: number
    type: number
    currency: number
    splitCode: number
    bearerType: number
    bearerSubaccount: number
    createdAt: number
    _all: number
  }


  export type SplitGroupMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    currency?: true
    splitCode?: true
    bearerType?: true
    bearerSubaccount?: true
    createdAt?: true
  }

  export type SplitGroupMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    currency?: true
    splitCode?: true
    bearerType?: true
    bearerSubaccount?: true
    createdAt?: true
  }

  export type SplitGroupCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    currency?: true
    splitCode?: true
    bearerType?: true
    bearerSubaccount?: true
    createdAt?: true
    _all?: true
  }

  export type SplitGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SplitGroup to aggregate.
     */
    where?: SplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitGroups to fetch.
     */
    orderBy?: SplitGroupOrderByWithRelationInput | SplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SplitGroups
    **/
    _count?: true | SplitGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SplitGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SplitGroupMaxAggregateInputType
  }

  export type GetSplitGroupAggregateType<T extends SplitGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateSplitGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSplitGroup[P]>
      : GetScalarType<T[P], AggregateSplitGroup[P]>
  }




  export type SplitGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SplitGroupWhereInput
    orderBy?: SplitGroupOrderByWithAggregationInput | SplitGroupOrderByWithAggregationInput[]
    by: SplitGroupScalarFieldEnum[] | SplitGroupScalarFieldEnum
    having?: SplitGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SplitGroupCountAggregateInputType | true
    _min?: SplitGroupMinAggregateInputType
    _max?: SplitGroupMaxAggregateInputType
  }

  export type SplitGroupGroupByOutputType = {
    id: string
    name: string
    type: string
    currency: string
    splitCode: string
    bearerType: string | null
    bearerSubaccount: string
    createdAt: Date
    _count: SplitGroupCountAggregateOutputType | null
    _min: SplitGroupMinAggregateOutputType | null
    _max: SplitGroupMaxAggregateOutputType | null
  }

  type GetSplitGroupGroupByPayload<T extends SplitGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SplitGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SplitGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SplitGroupGroupByOutputType[P]>
            : GetScalarType<T[P], SplitGroupGroupByOutputType[P]>
        }
      >
    >


  export type SplitGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    currency?: boolean
    splitCode?: boolean
    bearerType?: boolean
    bearerSubaccount?: boolean
    createdAt?: boolean
    subaccounts?: boolean | SplitGroup$subaccountsArgs<ExtArgs>
    _count?: boolean | SplitGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["splitGroup"]>

  export type SplitGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    currency?: boolean
    splitCode?: boolean
    bearerType?: boolean
    bearerSubaccount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["splitGroup"]>

  export type SplitGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    currency?: boolean
    splitCode?: boolean
    bearerType?: boolean
    bearerSubaccount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["splitGroup"]>

  export type SplitGroupSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    currency?: boolean
    splitCode?: boolean
    bearerType?: boolean
    bearerSubaccount?: boolean
    createdAt?: boolean
  }

  export type SplitGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "currency" | "splitCode" | "bearerType" | "bearerSubaccount" | "createdAt", ExtArgs["result"]["splitGroup"]>
  export type SplitGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subaccounts?: boolean | SplitGroup$subaccountsArgs<ExtArgs>
    _count?: boolean | SplitGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SplitGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SplitGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SplitGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SplitGroup"
    objects: {
      subaccounts: Prisma.$SubaccountSplitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      currency: string
      splitCode: string
      bearerType: string | null
      bearerSubaccount: string
      createdAt: Date
    }, ExtArgs["result"]["splitGroup"]>
    composites: {}
  }

  type SplitGroupGetPayload<S extends boolean | null | undefined | SplitGroupDefaultArgs> = $Result.GetResult<Prisma.$SplitGroupPayload, S>

  type SplitGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SplitGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SplitGroupCountAggregateInputType | true
    }

  export interface SplitGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SplitGroup'], meta: { name: 'SplitGroup' } }
    /**
     * Find zero or one SplitGroup that matches the filter.
     * @param {SplitGroupFindUniqueArgs} args - Arguments to find a SplitGroup
     * @example
     * // Get one SplitGroup
     * const splitGroup = await prisma.splitGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SplitGroupFindUniqueArgs>(args: SelectSubset<T, SplitGroupFindUniqueArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SplitGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SplitGroupFindUniqueOrThrowArgs} args - Arguments to find a SplitGroup
     * @example
     * // Get one SplitGroup
     * const splitGroup = await prisma.splitGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SplitGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, SplitGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SplitGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitGroupFindFirstArgs} args - Arguments to find a SplitGroup
     * @example
     * // Get one SplitGroup
     * const splitGroup = await prisma.splitGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SplitGroupFindFirstArgs>(args?: SelectSubset<T, SplitGroupFindFirstArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SplitGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitGroupFindFirstOrThrowArgs} args - Arguments to find a SplitGroup
     * @example
     * // Get one SplitGroup
     * const splitGroup = await prisma.splitGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SplitGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, SplitGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SplitGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SplitGroups
     * const splitGroups = await prisma.splitGroup.findMany()
     * 
     * // Get first 10 SplitGroups
     * const splitGroups = await prisma.splitGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const splitGroupWithIdOnly = await prisma.splitGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SplitGroupFindManyArgs>(args?: SelectSubset<T, SplitGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SplitGroup.
     * @param {SplitGroupCreateArgs} args - Arguments to create a SplitGroup.
     * @example
     * // Create one SplitGroup
     * const SplitGroup = await prisma.splitGroup.create({
     *   data: {
     *     // ... data to create a SplitGroup
     *   }
     * })
     * 
     */
    create<T extends SplitGroupCreateArgs>(args: SelectSubset<T, SplitGroupCreateArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SplitGroups.
     * @param {SplitGroupCreateManyArgs} args - Arguments to create many SplitGroups.
     * @example
     * // Create many SplitGroups
     * const splitGroup = await prisma.splitGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SplitGroupCreateManyArgs>(args?: SelectSubset<T, SplitGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SplitGroups and returns the data saved in the database.
     * @param {SplitGroupCreateManyAndReturnArgs} args - Arguments to create many SplitGroups.
     * @example
     * // Create many SplitGroups
     * const splitGroup = await prisma.splitGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SplitGroups and only return the `id`
     * const splitGroupWithIdOnly = await prisma.splitGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SplitGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, SplitGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SplitGroup.
     * @param {SplitGroupDeleteArgs} args - Arguments to delete one SplitGroup.
     * @example
     * // Delete one SplitGroup
     * const SplitGroup = await prisma.splitGroup.delete({
     *   where: {
     *     // ... filter to delete one SplitGroup
     *   }
     * })
     * 
     */
    delete<T extends SplitGroupDeleteArgs>(args: SelectSubset<T, SplitGroupDeleteArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SplitGroup.
     * @param {SplitGroupUpdateArgs} args - Arguments to update one SplitGroup.
     * @example
     * // Update one SplitGroup
     * const splitGroup = await prisma.splitGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SplitGroupUpdateArgs>(args: SelectSubset<T, SplitGroupUpdateArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SplitGroups.
     * @param {SplitGroupDeleteManyArgs} args - Arguments to filter SplitGroups to delete.
     * @example
     * // Delete a few SplitGroups
     * const { count } = await prisma.splitGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SplitGroupDeleteManyArgs>(args?: SelectSubset<T, SplitGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SplitGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SplitGroups
     * const splitGroup = await prisma.splitGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SplitGroupUpdateManyArgs>(args: SelectSubset<T, SplitGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SplitGroups and returns the data updated in the database.
     * @param {SplitGroupUpdateManyAndReturnArgs} args - Arguments to update many SplitGroups.
     * @example
     * // Update many SplitGroups
     * const splitGroup = await prisma.splitGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SplitGroups and only return the `id`
     * const splitGroupWithIdOnly = await prisma.splitGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SplitGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, SplitGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SplitGroup.
     * @param {SplitGroupUpsertArgs} args - Arguments to update or create a SplitGroup.
     * @example
     * // Update or create a SplitGroup
     * const splitGroup = await prisma.splitGroup.upsert({
     *   create: {
     *     // ... data to create a SplitGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SplitGroup we want to update
     *   }
     * })
     */
    upsert<T extends SplitGroupUpsertArgs>(args: SelectSubset<T, SplitGroupUpsertArgs<ExtArgs>>): Prisma__SplitGroupClient<$Result.GetResult<Prisma.$SplitGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SplitGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitGroupCountArgs} args - Arguments to filter SplitGroups to count.
     * @example
     * // Count the number of SplitGroups
     * const count = await prisma.splitGroup.count({
     *   where: {
     *     // ... the filter for the SplitGroups we want to count
     *   }
     * })
    **/
    count<T extends SplitGroupCountArgs>(
      args?: Subset<T, SplitGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SplitGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SplitGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SplitGroupAggregateArgs>(args: Subset<T, SplitGroupAggregateArgs>): Prisma.PrismaPromise<GetSplitGroupAggregateType<T>>

    /**
     * Group by SplitGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SplitGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SplitGroupGroupByArgs['orderBy'] }
        : { orderBy?: SplitGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SplitGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSplitGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SplitGroup model
   */
  readonly fields: SplitGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SplitGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SplitGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subaccounts<T extends SplitGroup$subaccountsArgs<ExtArgs> = {}>(args?: Subset<T, SplitGroup$subaccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubaccountSplitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SplitGroup model
   */
  interface SplitGroupFieldRefs {
    readonly id: FieldRef<"SplitGroup", 'String'>
    readonly name: FieldRef<"SplitGroup", 'String'>
    readonly type: FieldRef<"SplitGroup", 'String'>
    readonly currency: FieldRef<"SplitGroup", 'String'>
    readonly splitCode: FieldRef<"SplitGroup", 'String'>
    readonly bearerType: FieldRef<"SplitGroup", 'String'>
    readonly bearerSubaccount: FieldRef<"SplitGroup", 'String'>
    readonly createdAt: FieldRef<"SplitGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SplitGroup findUnique
   */
  export type SplitGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which SplitGroup to fetch.
     */
    where: SplitGroupWhereUniqueInput
  }

  /**
   * SplitGroup findUniqueOrThrow
   */
  export type SplitGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which SplitGroup to fetch.
     */
    where: SplitGroupWhereUniqueInput
  }

  /**
   * SplitGroup findFirst
   */
  export type SplitGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which SplitGroup to fetch.
     */
    where?: SplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitGroups to fetch.
     */
    orderBy?: SplitGroupOrderByWithRelationInput | SplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SplitGroups.
     */
    cursor?: SplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SplitGroups.
     */
    distinct?: SplitGroupScalarFieldEnum | SplitGroupScalarFieldEnum[]
  }

  /**
   * SplitGroup findFirstOrThrow
   */
  export type SplitGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which SplitGroup to fetch.
     */
    where?: SplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitGroups to fetch.
     */
    orderBy?: SplitGroupOrderByWithRelationInput | SplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SplitGroups.
     */
    cursor?: SplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SplitGroups.
     */
    distinct?: SplitGroupScalarFieldEnum | SplitGroupScalarFieldEnum[]
  }

  /**
   * SplitGroup findMany
   */
  export type SplitGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * Filter, which SplitGroups to fetch.
     */
    where?: SplitGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitGroups to fetch.
     */
    orderBy?: SplitGroupOrderByWithRelationInput | SplitGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SplitGroups.
     */
    cursor?: SplitGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitGroups.
     */
    skip?: number
    distinct?: SplitGroupScalarFieldEnum | SplitGroupScalarFieldEnum[]
  }

  /**
   * SplitGroup create
   */
  export type SplitGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a SplitGroup.
     */
    data: XOR<SplitGroupCreateInput, SplitGroupUncheckedCreateInput>
  }

  /**
   * SplitGroup createMany
   */
  export type SplitGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SplitGroups.
     */
    data: SplitGroupCreateManyInput | SplitGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SplitGroup createManyAndReturn
   */
  export type SplitGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * The data used to create many SplitGroups.
     */
    data: SplitGroupCreateManyInput | SplitGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SplitGroup update
   */
  export type SplitGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a SplitGroup.
     */
    data: XOR<SplitGroupUpdateInput, SplitGroupUncheckedUpdateInput>
    /**
     * Choose, which SplitGroup to update.
     */
    where: SplitGroupWhereUniqueInput
  }

  /**
   * SplitGroup updateMany
   */
  export type SplitGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SplitGroups.
     */
    data: XOR<SplitGroupUpdateManyMutationInput, SplitGroupUncheckedUpdateManyInput>
    /**
     * Filter which SplitGroups to update
     */
    where?: SplitGroupWhereInput
    /**
     * Limit how many SplitGroups to update.
     */
    limit?: number
  }

  /**
   * SplitGroup updateManyAndReturn
   */
  export type SplitGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * The data used to update SplitGroups.
     */
    data: XOR<SplitGroupUpdateManyMutationInput, SplitGroupUncheckedUpdateManyInput>
    /**
     * Filter which SplitGroups to update
     */
    where?: SplitGroupWhereInput
    /**
     * Limit how many SplitGroups to update.
     */
    limit?: number
  }

  /**
   * SplitGroup upsert
   */
  export type SplitGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the SplitGroup to update in case it exists.
     */
    where: SplitGroupWhereUniqueInput
    /**
     * In case the SplitGroup found by the `where` argument doesn't exist, create a new SplitGroup with this data.
     */
    create: XOR<SplitGroupCreateInput, SplitGroupUncheckedCreateInput>
    /**
     * In case the SplitGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SplitGroupUpdateInput, SplitGroupUncheckedUpdateInput>
  }

  /**
   * SplitGroup delete
   */
  export type SplitGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
    /**
     * Filter which SplitGroup to delete.
     */
    where: SplitGroupWhereUniqueInput
  }

  /**
   * SplitGroup deleteMany
   */
  export type SplitGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SplitGroups to delete
     */
    where?: SplitGroupWhereInput
    /**
     * Limit how many SplitGroups to delete.
     */
    limit?: number
  }

  /**
   * SplitGroup.subaccounts
   */
  export type SplitGroup$subaccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubaccountSplit
     */
    select?: SubaccountSplitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubaccountSplit
     */
    omit?: SubaccountSplitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubaccountSplitInclude<ExtArgs> | null
    where?: SubaccountSplitWhereInput
    orderBy?: SubaccountSplitOrderByWithRelationInput | SubaccountSplitOrderByWithRelationInput[]
    cursor?: SubaccountSplitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubaccountSplitScalarFieldEnum | SubaccountSplitScalarFieldEnum[]
  }

  /**
   * SplitGroup without action
   */
  export type SplitGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitGroup
     */
    select?: SplitGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitGroup
     */
    omit?: SplitGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SplitGroupInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransferSumAggregateOutputType = {
    amount: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    name: string | null
    accountNumber: string | null
    bankName: string | null
    bankCode: string | null
    recipientCode: string | null
    amount: number | null
    reason: string | null
    reference: string | null
    status: string | null
    batchId: string | null
    createdAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    name: string | null
    accountNumber: string | null
    bankName: string | null
    bankCode: string | null
    recipientCode: string | null
    amount: number | null
    reason: string | null
    reference: string | null
    status: string | null
    batchId: string | null
    createdAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    name: number
    accountNumber: number
    bankName: number
    bankCode: number
    recipientCode: number
    amount: number
    reason: number
    reference: number
    status: number
    batchId: number
    createdAt: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    amount?: true
  }

  export type TransferSumAggregateInputType = {
    amount?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankName?: true
    bankCode?: true
    recipientCode?: true
    amount?: true
    reason?: true
    reference?: true
    status?: true
    batchId?: true
    createdAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankName?: true
    bankCode?: true
    recipientCode?: true
    amount?: true
    reason?: true
    reference?: true
    status?: true
    batchId?: true
    createdAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankName?: true
    bankCode?: true
    recipientCode?: true
    amount?: true
    reason?: true
    reference?: true
    status?: true
    batchId?: true
    createdAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    name: string
    accountNumber: string
    bankName: string
    bankCode: string
    recipientCode: string
    amount: number
    reason: string
    reference: string | null
    status: string
    batchId: string | null
    createdAt: Date
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    amount?: boolean
    reason?: boolean
    reference?: boolean
    status?: boolean
    batchId?: boolean
    createdAt?: boolean
    batch?: boolean | Transfer$batchArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    amount?: boolean
    reason?: boolean
    reference?: boolean
    status?: boolean
    batchId?: boolean
    createdAt?: boolean
    batch?: boolean | Transfer$batchArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    amount?: boolean
    reason?: boolean
    reference?: boolean
    status?: boolean
    batchId?: boolean
    createdAt?: boolean
    batch?: boolean | Transfer$batchArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    amount?: boolean
    reason?: boolean
    reference?: boolean
    status?: boolean
    batchId?: boolean
    createdAt?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "accountNumber" | "bankName" | "bankCode" | "recipientCode" | "amount" | "reason" | "reference" | "status" | "batchId" | "createdAt", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | Transfer$batchArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | Transfer$batchArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | Transfer$batchArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      accountNumber: string
      bankName: string
      bankCode: string
      recipientCode: string
      amount: number
      reason: string
      reference: string | null
      status: string
      batchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends Transfer$batchArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly name: FieldRef<"Transfer", 'String'>
    readonly accountNumber: FieldRef<"Transfer", 'String'>
    readonly bankName: FieldRef<"Transfer", 'String'>
    readonly bankCode: FieldRef<"Transfer", 'String'>
    readonly recipientCode: FieldRef<"Transfer", 'String'>
    readonly amount: FieldRef<"Transfer", 'Float'>
    readonly reason: FieldRef<"Transfer", 'String'>
    readonly reference: FieldRef<"Transfer", 'String'>
    readonly status: FieldRef<"Transfer", 'String'>
    readonly batchId: FieldRef<"Transfer", 'String'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer.batch
   */
  export type Transfer$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    status: string | null
  }

  export type BatchMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    status: string | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    createdAt: number
    status: number
    _all: number
  }


  export type BatchMinAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: string
    createdAt: Date
    status: string
    _count: BatchCountAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
    transfers?: boolean | Batch$transfersArgs<ExtArgs>
    bulkTransfers?: boolean | Batch$bulkTransfersArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    createdAt?: boolean
    status?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "status", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfers?: boolean | Batch$transfersArgs<ExtArgs>
    bulkTransfers?: boolean | Batch$bulkTransfersArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      transfers: Prisma.$TransferPayload<ExtArgs>[]
      bulkTransfers: Prisma.$BulkTransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      status: string
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches and returns the data updated in the database.
     * @param {BatchUpdateManyAndReturnArgs} args - Arguments to update many Batches.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transfers<T extends Batch$transfersArgs<ExtArgs> = {}>(args?: Subset<T, Batch$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bulkTransfers<T extends Batch$bulkTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Batch$bulkTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'String'>
    readonly createdAt: FieldRef<"Batch", 'DateTime'>
    readonly status: FieldRef<"Batch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch updateManyAndReturn
   */
  export type BatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch.transfers
   */
  export type Batch$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Batch.bulkTransfers
   */
  export type Batch$bulkTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    where?: BulkTransferWhereInput
    orderBy?: BulkTransferOrderByWithRelationInput | BulkTransferOrderByWithRelationInput[]
    cursor?: BulkTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulkTransferScalarFieldEnum | BulkTransferScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model BulkTransfer
   */

  export type AggregateBulkTransfer = {
    _count: BulkTransferCountAggregateOutputType | null
    _avg: BulkTransferAvgAggregateOutputType | null
    _sum: BulkTransferSumAggregateOutputType | null
    _min: BulkTransferMinAggregateOutputType | null
    _max: BulkTransferMaxAggregateOutputType | null
  }

  export type BulkTransferAvgAggregateOutputType = {
    amount: number | null
  }

  export type BulkTransferSumAggregateOutputType = {
    amount: number | null
  }

  export type BulkTransferMinAggregateOutputType = {
    id: string | null
    amount: number | null
    status: string | null
    reference: string | null
    reason: string | null
    recipientCode: string | null
    transferCode: string | null
    createdAt: Date | null
    batchId: string | null
  }

  export type BulkTransferMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    status: string | null
    reference: string | null
    reason: string | null
    recipientCode: string | null
    transferCode: string | null
    createdAt: Date | null
    batchId: string | null
  }

  export type BulkTransferCountAggregateOutputType = {
    id: number
    amount: number
    status: number
    reference: number
    reason: number
    recipientCode: number
    transferCode: number
    createdAt: number
    batchId: number
    _all: number
  }


  export type BulkTransferAvgAggregateInputType = {
    amount?: true
  }

  export type BulkTransferSumAggregateInputType = {
    amount?: true
  }

  export type BulkTransferMinAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    reference?: true
    reason?: true
    recipientCode?: true
    transferCode?: true
    createdAt?: true
    batchId?: true
  }

  export type BulkTransferMaxAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    reference?: true
    reason?: true
    recipientCode?: true
    transferCode?: true
    createdAt?: true
    batchId?: true
  }

  export type BulkTransferCountAggregateInputType = {
    id?: true
    amount?: true
    status?: true
    reference?: true
    reason?: true
    recipientCode?: true
    transferCode?: true
    createdAt?: true
    batchId?: true
    _all?: true
  }

  export type BulkTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkTransfer to aggregate.
     */
    where?: BulkTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkTransfers to fetch.
     */
    orderBy?: BulkTransferOrderByWithRelationInput | BulkTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BulkTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BulkTransfers
    **/
    _count?: true | BulkTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BulkTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BulkTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BulkTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BulkTransferMaxAggregateInputType
  }

  export type GetBulkTransferAggregateType<T extends BulkTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateBulkTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBulkTransfer[P]>
      : GetScalarType<T[P], AggregateBulkTransfer[P]>
  }




  export type BulkTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkTransferWhereInput
    orderBy?: BulkTransferOrderByWithAggregationInput | BulkTransferOrderByWithAggregationInput[]
    by: BulkTransferScalarFieldEnum[] | BulkTransferScalarFieldEnum
    having?: BulkTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BulkTransferCountAggregateInputType | true
    _avg?: BulkTransferAvgAggregateInputType
    _sum?: BulkTransferSumAggregateInputType
    _min?: BulkTransferMinAggregateInputType
    _max?: BulkTransferMaxAggregateInputType
  }

  export type BulkTransferGroupByOutputType = {
    id: string
    amount: number
    status: string
    reference: string
    reason: string
    recipientCode: string
    transferCode: string
    createdAt: Date
    batchId: string
    _count: BulkTransferCountAggregateOutputType | null
    _avg: BulkTransferAvgAggregateOutputType | null
    _sum: BulkTransferSumAggregateOutputType | null
    _min: BulkTransferMinAggregateOutputType | null
    _max: BulkTransferMaxAggregateOutputType | null
  }

  type GetBulkTransferGroupByPayload<T extends BulkTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BulkTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BulkTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BulkTransferGroupByOutputType[P]>
            : GetScalarType<T[P], BulkTransferGroupByOutputType[P]>
        }
      >
    >


  export type BulkTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    reference?: boolean
    reason?: boolean
    recipientCode?: boolean
    transferCode?: boolean
    createdAt?: boolean
    batchId?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulkTransfer"]>

  export type BulkTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    reference?: boolean
    reason?: boolean
    recipientCode?: boolean
    transferCode?: boolean
    createdAt?: boolean
    batchId?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulkTransfer"]>

  export type BulkTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    status?: boolean
    reference?: boolean
    reason?: boolean
    recipientCode?: boolean
    transferCode?: boolean
    createdAt?: boolean
    batchId?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulkTransfer"]>

  export type BulkTransferSelectScalar = {
    id?: boolean
    amount?: boolean
    status?: boolean
    reference?: boolean
    reason?: boolean
    recipientCode?: boolean
    transferCode?: boolean
    createdAt?: boolean
    batchId?: boolean
  }

  export type BulkTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "status" | "reference" | "reason" | "recipientCode" | "transferCode" | "createdAt" | "batchId", ExtArgs["result"]["bulkTransfer"]>
  export type BulkTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }
  export type BulkTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }
  export type BulkTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }

  export type $BulkTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BulkTransfer"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      status: string
      reference: string
      reason: string
      recipientCode: string
      transferCode: string
      createdAt: Date
      batchId: string
    }, ExtArgs["result"]["bulkTransfer"]>
    composites: {}
  }

  type BulkTransferGetPayload<S extends boolean | null | undefined | BulkTransferDefaultArgs> = $Result.GetResult<Prisma.$BulkTransferPayload, S>

  type BulkTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BulkTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BulkTransferCountAggregateInputType | true
    }

  export interface BulkTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BulkTransfer'], meta: { name: 'BulkTransfer' } }
    /**
     * Find zero or one BulkTransfer that matches the filter.
     * @param {BulkTransferFindUniqueArgs} args - Arguments to find a BulkTransfer
     * @example
     * // Get one BulkTransfer
     * const bulkTransfer = await prisma.bulkTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BulkTransferFindUniqueArgs>(args: SelectSubset<T, BulkTransferFindUniqueArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BulkTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BulkTransferFindUniqueOrThrowArgs} args - Arguments to find a BulkTransfer
     * @example
     * // Get one BulkTransfer
     * const bulkTransfer = await prisma.bulkTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BulkTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, BulkTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkTransferFindFirstArgs} args - Arguments to find a BulkTransfer
     * @example
     * // Get one BulkTransfer
     * const bulkTransfer = await prisma.bulkTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BulkTransferFindFirstArgs>(args?: SelectSubset<T, BulkTransferFindFirstArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BulkTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkTransferFindFirstOrThrowArgs} args - Arguments to find a BulkTransfer
     * @example
     * // Get one BulkTransfer
     * const bulkTransfer = await prisma.bulkTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BulkTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, BulkTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BulkTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BulkTransfers
     * const bulkTransfers = await prisma.bulkTransfer.findMany()
     * 
     * // Get first 10 BulkTransfers
     * const bulkTransfers = await prisma.bulkTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bulkTransferWithIdOnly = await prisma.bulkTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BulkTransferFindManyArgs>(args?: SelectSubset<T, BulkTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BulkTransfer.
     * @param {BulkTransferCreateArgs} args - Arguments to create a BulkTransfer.
     * @example
     * // Create one BulkTransfer
     * const BulkTransfer = await prisma.bulkTransfer.create({
     *   data: {
     *     // ... data to create a BulkTransfer
     *   }
     * })
     * 
     */
    create<T extends BulkTransferCreateArgs>(args: SelectSubset<T, BulkTransferCreateArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BulkTransfers.
     * @param {BulkTransferCreateManyArgs} args - Arguments to create many BulkTransfers.
     * @example
     * // Create many BulkTransfers
     * const bulkTransfer = await prisma.bulkTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BulkTransferCreateManyArgs>(args?: SelectSubset<T, BulkTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BulkTransfers and returns the data saved in the database.
     * @param {BulkTransferCreateManyAndReturnArgs} args - Arguments to create many BulkTransfers.
     * @example
     * // Create many BulkTransfers
     * const bulkTransfer = await prisma.bulkTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BulkTransfers and only return the `id`
     * const bulkTransferWithIdOnly = await prisma.bulkTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BulkTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, BulkTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BulkTransfer.
     * @param {BulkTransferDeleteArgs} args - Arguments to delete one BulkTransfer.
     * @example
     * // Delete one BulkTransfer
     * const BulkTransfer = await prisma.bulkTransfer.delete({
     *   where: {
     *     // ... filter to delete one BulkTransfer
     *   }
     * })
     * 
     */
    delete<T extends BulkTransferDeleteArgs>(args: SelectSubset<T, BulkTransferDeleteArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BulkTransfer.
     * @param {BulkTransferUpdateArgs} args - Arguments to update one BulkTransfer.
     * @example
     * // Update one BulkTransfer
     * const bulkTransfer = await prisma.bulkTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BulkTransferUpdateArgs>(args: SelectSubset<T, BulkTransferUpdateArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BulkTransfers.
     * @param {BulkTransferDeleteManyArgs} args - Arguments to filter BulkTransfers to delete.
     * @example
     * // Delete a few BulkTransfers
     * const { count } = await prisma.bulkTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BulkTransferDeleteManyArgs>(args?: SelectSubset<T, BulkTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BulkTransfers
     * const bulkTransfer = await prisma.bulkTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BulkTransferUpdateManyArgs>(args: SelectSubset<T, BulkTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkTransfers and returns the data updated in the database.
     * @param {BulkTransferUpdateManyAndReturnArgs} args - Arguments to update many BulkTransfers.
     * @example
     * // Update many BulkTransfers
     * const bulkTransfer = await prisma.bulkTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BulkTransfers and only return the `id`
     * const bulkTransferWithIdOnly = await prisma.bulkTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BulkTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, BulkTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BulkTransfer.
     * @param {BulkTransferUpsertArgs} args - Arguments to update or create a BulkTransfer.
     * @example
     * // Update or create a BulkTransfer
     * const bulkTransfer = await prisma.bulkTransfer.upsert({
     *   create: {
     *     // ... data to create a BulkTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BulkTransfer we want to update
     *   }
     * })
     */
    upsert<T extends BulkTransferUpsertArgs>(args: SelectSubset<T, BulkTransferUpsertArgs<ExtArgs>>): Prisma__BulkTransferClient<$Result.GetResult<Prisma.$BulkTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BulkTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkTransferCountArgs} args - Arguments to filter BulkTransfers to count.
     * @example
     * // Count the number of BulkTransfers
     * const count = await prisma.bulkTransfer.count({
     *   where: {
     *     // ... the filter for the BulkTransfers we want to count
     *   }
     * })
    **/
    count<T extends BulkTransferCountArgs>(
      args?: Subset<T, BulkTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BulkTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BulkTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BulkTransferAggregateArgs>(args: Subset<T, BulkTransferAggregateArgs>): Prisma.PrismaPromise<GetBulkTransferAggregateType<T>>

    /**
     * Group by BulkTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BulkTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BulkTransferGroupByArgs['orderBy'] }
        : { orderBy?: BulkTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BulkTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBulkTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BulkTransfer model
   */
  readonly fields: BulkTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BulkTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BulkTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BulkTransfer model
   */
  interface BulkTransferFieldRefs {
    readonly id: FieldRef<"BulkTransfer", 'String'>
    readonly amount: FieldRef<"BulkTransfer", 'Int'>
    readonly status: FieldRef<"BulkTransfer", 'String'>
    readonly reference: FieldRef<"BulkTransfer", 'String'>
    readonly reason: FieldRef<"BulkTransfer", 'String'>
    readonly recipientCode: FieldRef<"BulkTransfer", 'String'>
    readonly transferCode: FieldRef<"BulkTransfer", 'String'>
    readonly createdAt: FieldRef<"BulkTransfer", 'DateTime'>
    readonly batchId: FieldRef<"BulkTransfer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BulkTransfer findUnique
   */
  export type BulkTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * Filter, which BulkTransfer to fetch.
     */
    where: BulkTransferWhereUniqueInput
  }

  /**
   * BulkTransfer findUniqueOrThrow
   */
  export type BulkTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * Filter, which BulkTransfer to fetch.
     */
    where: BulkTransferWhereUniqueInput
  }

  /**
   * BulkTransfer findFirst
   */
  export type BulkTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * Filter, which BulkTransfer to fetch.
     */
    where?: BulkTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkTransfers to fetch.
     */
    orderBy?: BulkTransferOrderByWithRelationInput | BulkTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkTransfers.
     */
    cursor?: BulkTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkTransfers.
     */
    distinct?: BulkTransferScalarFieldEnum | BulkTransferScalarFieldEnum[]
  }

  /**
   * BulkTransfer findFirstOrThrow
   */
  export type BulkTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * Filter, which BulkTransfer to fetch.
     */
    where?: BulkTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkTransfers to fetch.
     */
    orderBy?: BulkTransferOrderByWithRelationInput | BulkTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkTransfers.
     */
    cursor?: BulkTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkTransfers.
     */
    distinct?: BulkTransferScalarFieldEnum | BulkTransferScalarFieldEnum[]
  }

  /**
   * BulkTransfer findMany
   */
  export type BulkTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * Filter, which BulkTransfers to fetch.
     */
    where?: BulkTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkTransfers to fetch.
     */
    orderBy?: BulkTransferOrderByWithRelationInput | BulkTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BulkTransfers.
     */
    cursor?: BulkTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkTransfers.
     */
    skip?: number
    distinct?: BulkTransferScalarFieldEnum | BulkTransferScalarFieldEnum[]
  }

  /**
   * BulkTransfer create
   */
  export type BulkTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a BulkTransfer.
     */
    data: XOR<BulkTransferCreateInput, BulkTransferUncheckedCreateInput>
  }

  /**
   * BulkTransfer createMany
   */
  export type BulkTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BulkTransfers.
     */
    data: BulkTransferCreateManyInput | BulkTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BulkTransfer createManyAndReturn
   */
  export type BulkTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * The data used to create many BulkTransfers.
     */
    data: BulkTransferCreateManyInput | BulkTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulkTransfer update
   */
  export type BulkTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a BulkTransfer.
     */
    data: XOR<BulkTransferUpdateInput, BulkTransferUncheckedUpdateInput>
    /**
     * Choose, which BulkTransfer to update.
     */
    where: BulkTransferWhereUniqueInput
  }

  /**
   * BulkTransfer updateMany
   */
  export type BulkTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BulkTransfers.
     */
    data: XOR<BulkTransferUpdateManyMutationInput, BulkTransferUncheckedUpdateManyInput>
    /**
     * Filter which BulkTransfers to update
     */
    where?: BulkTransferWhereInput
    /**
     * Limit how many BulkTransfers to update.
     */
    limit?: number
  }

  /**
   * BulkTransfer updateManyAndReturn
   */
  export type BulkTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * The data used to update BulkTransfers.
     */
    data: XOR<BulkTransferUpdateManyMutationInput, BulkTransferUncheckedUpdateManyInput>
    /**
     * Filter which BulkTransfers to update
     */
    where?: BulkTransferWhereInput
    /**
     * Limit how many BulkTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulkTransfer upsert
   */
  export type BulkTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the BulkTransfer to update in case it exists.
     */
    where: BulkTransferWhereUniqueInput
    /**
     * In case the BulkTransfer found by the `where` argument doesn't exist, create a new BulkTransfer with this data.
     */
    create: XOR<BulkTransferCreateInput, BulkTransferUncheckedCreateInput>
    /**
     * In case the BulkTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BulkTransferUpdateInput, BulkTransferUncheckedUpdateInput>
  }

  /**
   * BulkTransfer delete
   */
  export type BulkTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
    /**
     * Filter which BulkTransfer to delete.
     */
    where: BulkTransferWhereUniqueInput
  }

  /**
   * BulkTransfer deleteMany
   */
  export type BulkTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkTransfers to delete
     */
    where?: BulkTransferWhereInput
    /**
     * Limit how many BulkTransfers to delete.
     */
    limit?: number
  }

  /**
   * BulkTransfer without action
   */
  export type BulkTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkTransfer
     */
    select?: BulkTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulkTransfer
     */
    omit?: BulkTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkTransferInclude<ExtArgs> | null
  }


  /**
   * Model Recipient
   */

  export type AggregateRecipient = {
    _count: RecipientCountAggregateOutputType | null
    _min: RecipientMinAggregateOutputType | null
    _max: RecipientMaxAggregateOutputType | null
  }

  export type RecipientMinAggregateOutputType = {
    id: string | null
    name: string | null
    accountNumber: string | null
    bankCode: string | null
    recipientCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    accountNumber: string | null
    bankCode: string | null
    recipientCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipientCountAggregateOutputType = {
    id: number
    name: number
    accountNumber: number
    bankCode: number
    recipientCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecipientMinAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankCode?: true
    recipientCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipientMaxAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankCode?: true
    recipientCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipientCountAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankCode?: true
    recipientCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipient to aggregate.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipients
    **/
    _count?: true | RecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipientMaxAggregateInputType
  }

  export type GetRecipientAggregateType<T extends RecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipient[P]>
      : GetScalarType<T[P], AggregateRecipient[P]>
  }




  export type RecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipientWhereInput
    orderBy?: RecipientOrderByWithAggregationInput | RecipientOrderByWithAggregationInput[]
    by: RecipientScalarFieldEnum[] | RecipientScalarFieldEnum
    having?: RecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipientCountAggregateInputType | true
    _min?: RecipientMinAggregateInputType
    _max?: RecipientMaxAggregateInputType
  }

  export type RecipientGroupByOutputType = {
    id: string
    name: string
    accountNumber: string
    bankCode: string
    recipientCode: string
    createdAt: Date
    updatedAt: Date
    _count: RecipientCountAggregateOutputType | null
    _min: RecipientMinAggregateOutputType | null
    _max: RecipientMaxAggregateOutputType | null
  }

  type GetRecipientGroupByPayload<T extends RecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipientGroupByOutputType[P]>
            : GetScalarType<T[P], RecipientGroupByOutputType[P]>
        }
      >
    >


  export type RecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recipient"]>

  export type RecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recipient"]>

  export type RecipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recipient"]>

  export type RecipientSelectScalar = {
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankCode?: boolean
    recipientCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "accountNumber" | "bankCode" | "recipientCode" | "createdAt" | "updatedAt", ExtArgs["result"]["recipient"]>

  export type $RecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipient"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      accountNumber: string
      bankCode: string
      recipientCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recipient"]>
    composites: {}
  }

  type RecipientGetPayload<S extends boolean | null | undefined | RecipientDefaultArgs> = $Result.GetResult<Prisma.$RecipientPayload, S>

  type RecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipientCountAggregateInputType | true
    }

  export interface RecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipient'], meta: { name: 'Recipient' } }
    /**
     * Find zero or one Recipient that matches the filter.
     * @param {RecipientFindUniqueArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipientFindUniqueArgs>(args: SelectSubset<T, RecipientFindUniqueArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipientFindUniqueOrThrowArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientFindFirstArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipientFindFirstArgs>(args?: SelectSubset<T, RecipientFindFirstArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientFindFirstOrThrowArgs} args - Arguments to find a Recipient
     * @example
     * // Get one Recipient
     * const recipient = await prisma.recipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipients
     * const recipients = await prisma.recipient.findMany()
     * 
     * // Get first 10 Recipients
     * const recipients = await prisma.recipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipientWithIdOnly = await prisma.recipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipientFindManyArgs>(args?: SelectSubset<T, RecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recipient.
     * @param {RecipientCreateArgs} args - Arguments to create a Recipient.
     * @example
     * // Create one Recipient
     * const Recipient = await prisma.recipient.create({
     *   data: {
     *     // ... data to create a Recipient
     *   }
     * })
     * 
     */
    create<T extends RecipientCreateArgs>(args: SelectSubset<T, RecipientCreateArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recipients.
     * @param {RecipientCreateManyArgs} args - Arguments to create many Recipients.
     * @example
     * // Create many Recipients
     * const recipient = await prisma.recipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipientCreateManyArgs>(args?: SelectSubset<T, RecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipients and returns the data saved in the database.
     * @param {RecipientCreateManyAndReturnArgs} args - Arguments to create many Recipients.
     * @example
     * // Create many Recipients
     * const recipient = await prisma.recipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipients and only return the `id`
     * const recipientWithIdOnly = await prisma.recipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recipient.
     * @param {RecipientDeleteArgs} args - Arguments to delete one Recipient.
     * @example
     * // Delete one Recipient
     * const Recipient = await prisma.recipient.delete({
     *   where: {
     *     // ... filter to delete one Recipient
     *   }
     * })
     * 
     */
    delete<T extends RecipientDeleteArgs>(args: SelectSubset<T, RecipientDeleteArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recipient.
     * @param {RecipientUpdateArgs} args - Arguments to update one Recipient.
     * @example
     * // Update one Recipient
     * const recipient = await prisma.recipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipientUpdateArgs>(args: SelectSubset<T, RecipientUpdateArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recipients.
     * @param {RecipientDeleteManyArgs} args - Arguments to filter Recipients to delete.
     * @example
     * // Delete a few Recipients
     * const { count } = await prisma.recipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipientDeleteManyArgs>(args?: SelectSubset<T, RecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipients
     * const recipient = await prisma.recipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipientUpdateManyArgs>(args: SelectSubset<T, RecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipients and returns the data updated in the database.
     * @param {RecipientUpdateManyAndReturnArgs} args - Arguments to update many Recipients.
     * @example
     * // Update many Recipients
     * const recipient = await prisma.recipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recipients and only return the `id`
     * const recipientWithIdOnly = await prisma.recipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipientUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recipient.
     * @param {RecipientUpsertArgs} args - Arguments to update or create a Recipient.
     * @example
     * // Update or create a Recipient
     * const recipient = await prisma.recipient.upsert({
     *   create: {
     *     // ... data to create a Recipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipient we want to update
     *   }
     * })
     */
    upsert<T extends RecipientUpsertArgs>(args: SelectSubset<T, RecipientUpsertArgs<ExtArgs>>): Prisma__RecipientClient<$Result.GetResult<Prisma.$RecipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientCountArgs} args - Arguments to filter Recipients to count.
     * @example
     * // Count the number of Recipients
     * const count = await prisma.recipient.count({
     *   where: {
     *     // ... the filter for the Recipients we want to count
     *   }
     * })
    **/
    count<T extends RecipientCountArgs>(
      args?: Subset<T, RecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipientAggregateArgs>(args: Subset<T, RecipientAggregateArgs>): Prisma.PrismaPromise<GetRecipientAggregateType<T>>

    /**
     * Group by Recipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipientGroupByArgs['orderBy'] }
        : { orderBy?: RecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipient model
   */
  readonly fields: RecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipient model
   */
  interface RecipientFieldRefs {
    readonly id: FieldRef<"Recipient", 'String'>
    readonly name: FieldRef<"Recipient", 'String'>
    readonly accountNumber: FieldRef<"Recipient", 'String'>
    readonly bankCode: FieldRef<"Recipient", 'String'>
    readonly recipientCode: FieldRef<"Recipient", 'String'>
    readonly createdAt: FieldRef<"Recipient", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recipient findUnique
   */
  export type RecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient findUniqueOrThrow
   */
  export type RecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient findFirst
   */
  export type RecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipients.
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipients.
     */
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * Recipient findFirstOrThrow
   */
  export type RecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * Filter, which Recipient to fetch.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipients.
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipients.
     */
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * Recipient findMany
   */
  export type RecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * Filter, which Recipients to fetch.
     */
    where?: RecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipients to fetch.
     */
    orderBy?: RecipientOrderByWithRelationInput | RecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipients.
     */
    cursor?: RecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipients.
     */
    skip?: number
    distinct?: RecipientScalarFieldEnum | RecipientScalarFieldEnum[]
  }

  /**
   * Recipient create
   */
  export type RecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * The data needed to create a Recipient.
     */
    data: XOR<RecipientCreateInput, RecipientUncheckedCreateInput>
  }

  /**
   * Recipient createMany
   */
  export type RecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipients.
     */
    data: RecipientCreateManyInput | RecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipient createManyAndReturn
   */
  export type RecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * The data used to create many Recipients.
     */
    data: RecipientCreateManyInput | RecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipient update
   */
  export type RecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * The data needed to update a Recipient.
     */
    data: XOR<RecipientUpdateInput, RecipientUncheckedUpdateInput>
    /**
     * Choose, which Recipient to update.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient updateMany
   */
  export type RecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipients.
     */
    data: XOR<RecipientUpdateManyMutationInput, RecipientUncheckedUpdateManyInput>
    /**
     * Filter which Recipients to update
     */
    where?: RecipientWhereInput
    /**
     * Limit how many Recipients to update.
     */
    limit?: number
  }

  /**
   * Recipient updateManyAndReturn
   */
  export type RecipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * The data used to update Recipients.
     */
    data: XOR<RecipientUpdateManyMutationInput, RecipientUncheckedUpdateManyInput>
    /**
     * Filter which Recipients to update
     */
    where?: RecipientWhereInput
    /**
     * Limit how many Recipients to update.
     */
    limit?: number
  }

  /**
   * Recipient upsert
   */
  export type RecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * The filter to search for the Recipient to update in case it exists.
     */
    where: RecipientWhereUniqueInput
    /**
     * In case the Recipient found by the `where` argument doesn't exist, create a new Recipient with this data.
     */
    create: XOR<RecipientCreateInput, RecipientUncheckedCreateInput>
    /**
     * In case the Recipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipientUpdateInput, RecipientUncheckedUpdateInput>
  }

  /**
   * Recipient delete
   */
  export type RecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
    /**
     * Filter which Recipient to delete.
     */
    where: RecipientWhereUniqueInput
  }

  /**
   * Recipient deleteMany
   */
  export type RecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipients to delete
     */
    where?: RecipientWhereInput
    /**
     * Limit how many Recipients to delete.
     */
    limit?: number
  }

  /**
   * Recipient without action
   */
  export type RecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipient
     */
    select?: RecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipient
     */
    omit?: RecipientOmit<ExtArgs> | null
  }


  /**
   * Model CryptoWallet
   */

  export type AggregateCryptoWallet = {
    _count: CryptoWalletCountAggregateOutputType | null
    _avg: CryptoWalletAvgAggregateOutputType | null
    _sum: CryptoWalletSumAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  export type CryptoWalletAvgAggregateOutputType = {
    u2kBalance: number | null
  }

  export type CryptoWalletSumAggregateOutputType = {
    u2kBalance: number | null
  }

  export type CryptoWalletMinAggregateOutputType = {
    id: string | null
    address: string | null
    userId: string | null
    u2kBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoWalletMaxAggregateOutputType = {
    id: string | null
    address: string | null
    userId: string | null
    u2kBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoWalletCountAggregateOutputType = {
    id: number
    address: number
    userId: number
    u2kBalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoWalletAvgAggregateInputType = {
    u2kBalance?: true
  }

  export type CryptoWalletSumAggregateInputType = {
    u2kBalance?: true
  }

  export type CryptoWalletMinAggregateInputType = {
    id?: true
    address?: true
    userId?: true
    u2kBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoWalletMaxAggregateInputType = {
    id?: true
    address?: true
    userId?: true
    u2kBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoWalletCountAggregateInputType = {
    id?: true
    address?: true
    userId?: true
    u2kBalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallet to aggregate.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoWallets
    **/
    _count?: true | CryptoWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type GetCryptoWalletAggregateType<T extends CryptoWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoWallet[P]>
      : GetScalarType<T[P], AggregateCryptoWallet[P]>
  }




  export type CryptoWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoWalletWhereInput
    orderBy?: CryptoWalletOrderByWithAggregationInput | CryptoWalletOrderByWithAggregationInput[]
    by: CryptoWalletScalarFieldEnum[] | CryptoWalletScalarFieldEnum
    having?: CryptoWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoWalletCountAggregateInputType | true
    _avg?: CryptoWalletAvgAggregateInputType
    _sum?: CryptoWalletSumAggregateInputType
    _min?: CryptoWalletMinAggregateInputType
    _max?: CryptoWalletMaxAggregateInputType
  }

  export type CryptoWalletGroupByOutputType = {
    id: string
    address: string
    userId: string
    u2kBalance: number
    createdAt: Date
    updatedAt: Date
    _count: CryptoWalletCountAggregateOutputType | null
    _avg: CryptoWalletAvgAggregateOutputType | null
    _sum: CryptoWalletSumAggregateOutputType | null
    _min: CryptoWalletMinAggregateOutputType | null
    _max: CryptoWalletMaxAggregateOutputType | null
  }

  type GetCryptoWalletGroupByPayload<T extends CryptoWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoWalletGroupByOutputType[P]>
        }
      >
    >


  export type CryptoWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    userId?: boolean
    u2kBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | CryptoWallet$transactionsArgs<ExtArgs>
    _count?: boolean | CryptoWalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    userId?: boolean
    u2kBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    userId?: boolean
    u2kBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoWallet"]>

  export type CryptoWalletSelectScalar = {
    id?: boolean
    address?: boolean
    userId?: boolean
    u2kBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "userId" | "u2kBalance" | "createdAt" | "updatedAt", ExtArgs["result"]["cryptoWallet"]>
  export type CryptoWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | CryptoWallet$transactionsArgs<ExtArgs>
    _count?: boolean | CryptoWalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CryptoWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CryptoWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CryptoWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoWallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$BlockchainTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      userId: string
      u2kBalance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoWallet"]>
    composites: {}
  }

  type CryptoWalletGetPayload<S extends boolean | null | undefined | CryptoWalletDefaultArgs> = $Result.GetResult<Prisma.$CryptoWalletPayload, S>

  type CryptoWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CryptoWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CryptoWalletCountAggregateInputType | true
    }

  export interface CryptoWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoWallet'], meta: { name: 'CryptoWallet' } }
    /**
     * Find zero or one CryptoWallet that matches the filter.
     * @param {CryptoWalletFindUniqueArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoWalletFindUniqueArgs>(args: SelectSubset<T, CryptoWalletFindUniqueArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CryptoWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CryptoWalletFindUniqueOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoWalletFindFirstArgs>(args?: SelectSubset<T, CryptoWalletFindFirstArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindFirstOrThrowArgs} args - Arguments to find a CryptoWallet
     * @example
     * // Get one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CryptoWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany()
     * 
     * // Get first 10 CryptoWallets
     * const cryptoWallets = await prisma.cryptoWallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoWalletFindManyArgs>(args?: SelectSubset<T, CryptoWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CryptoWallet.
     * @param {CryptoWalletCreateArgs} args - Arguments to create a CryptoWallet.
     * @example
     * // Create one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.create({
     *   data: {
     *     // ... data to create a CryptoWallet
     *   }
     * })
     * 
     */
    create<T extends CryptoWalletCreateArgs>(args: SelectSubset<T, CryptoWalletCreateArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CryptoWallets.
     * @param {CryptoWalletCreateManyArgs} args - Arguments to create many CryptoWallets.
     * @example
     * // Create many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoWalletCreateManyArgs>(args?: SelectSubset<T, CryptoWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoWallets and returns the data saved in the database.
     * @param {CryptoWalletCreateManyAndReturnArgs} args - Arguments to create many CryptoWallets.
     * @example
     * // Create many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoWallets and only return the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CryptoWallet.
     * @param {CryptoWalletDeleteArgs} args - Arguments to delete one CryptoWallet.
     * @example
     * // Delete one CryptoWallet
     * const CryptoWallet = await prisma.cryptoWallet.delete({
     *   where: {
     *     // ... filter to delete one CryptoWallet
     *   }
     * })
     * 
     */
    delete<T extends CryptoWalletDeleteArgs>(args: SelectSubset<T, CryptoWalletDeleteArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CryptoWallet.
     * @param {CryptoWalletUpdateArgs} args - Arguments to update one CryptoWallet.
     * @example
     * // Update one CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoWalletUpdateArgs>(args: SelectSubset<T, CryptoWalletUpdateArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CryptoWallets.
     * @param {CryptoWalletDeleteManyArgs} args - Arguments to filter CryptoWallets to delete.
     * @example
     * // Delete a few CryptoWallets
     * const { count } = await prisma.cryptoWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoWalletDeleteManyArgs>(args?: SelectSubset<T, CryptoWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoWalletUpdateManyArgs>(args: SelectSubset<T, CryptoWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoWallets and returns the data updated in the database.
     * @param {CryptoWalletUpdateManyAndReturnArgs} args - Arguments to update many CryptoWallets.
     * @example
     * // Update many CryptoWallets
     * const cryptoWallet = await prisma.cryptoWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CryptoWallets and only return the `id`
     * const cryptoWalletWithIdOnly = await prisma.cryptoWallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CryptoWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, CryptoWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CryptoWallet.
     * @param {CryptoWalletUpsertArgs} args - Arguments to update or create a CryptoWallet.
     * @example
     * // Update or create a CryptoWallet
     * const cryptoWallet = await prisma.cryptoWallet.upsert({
     *   create: {
     *     // ... data to create a CryptoWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoWallet we want to update
     *   }
     * })
     */
    upsert<T extends CryptoWalletUpsertArgs>(args: SelectSubset<T, CryptoWalletUpsertArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CryptoWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletCountArgs} args - Arguments to filter CryptoWallets to count.
     * @example
     * // Count the number of CryptoWallets
     * const count = await prisma.cryptoWallet.count({
     *   where: {
     *     // ... the filter for the CryptoWallets we want to count
     *   }
     * })
    **/
    count<T extends CryptoWalletCountArgs>(
      args?: Subset<T, CryptoWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoWalletAggregateArgs>(args: Subset<T, CryptoWalletAggregateArgs>): Prisma.PrismaPromise<GetCryptoWalletAggregateType<T>>

    /**
     * Group by CryptoWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoWalletGroupByArgs['orderBy'] }
        : { orderBy?: CryptoWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoWallet model
   */
  readonly fields: CryptoWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends CryptoWallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoWallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoWallet model
   */
  interface CryptoWalletFieldRefs {
    readonly id: FieldRef<"CryptoWallet", 'String'>
    readonly address: FieldRef<"CryptoWallet", 'String'>
    readonly userId: FieldRef<"CryptoWallet", 'String'>
    readonly u2kBalance: FieldRef<"CryptoWallet", 'Float'>
    readonly createdAt: FieldRef<"CryptoWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoWallet findUnique
   */
  export type CryptoWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet findUniqueOrThrow
   */
  export type CryptoWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet findFirst
   */
  export type CryptoWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet findFirstOrThrow
   */
  export type CryptoWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallet to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoWallets.
     */
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet findMany
   */
  export type CryptoWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter, which CryptoWallets to fetch.
     */
    where?: CryptoWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoWallets to fetch.
     */
    orderBy?: CryptoWalletOrderByWithRelationInput | CryptoWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoWallets.
     */
    cursor?: CryptoWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoWallets.
     */
    skip?: number
    distinct?: CryptoWalletScalarFieldEnum | CryptoWalletScalarFieldEnum[]
  }

  /**
   * CryptoWallet create
   */
  export type CryptoWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoWallet.
     */
    data: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
  }

  /**
   * CryptoWallet createMany
   */
  export type CryptoWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoWallets.
     */
    data: CryptoWalletCreateManyInput | CryptoWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoWallet createManyAndReturn
   */
  export type CryptoWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * The data used to create many CryptoWallets.
     */
    data: CryptoWalletCreateManyInput | CryptoWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoWallet update
   */
  export type CryptoWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoWallet.
     */
    data: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
    /**
     * Choose, which CryptoWallet to update.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet updateMany
   */
  export type CryptoWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoWallets.
     */
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyInput>
    /**
     * Filter which CryptoWallets to update
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to update.
     */
    limit?: number
  }

  /**
   * CryptoWallet updateManyAndReturn
   */
  export type CryptoWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * The data used to update CryptoWallets.
     */
    data: XOR<CryptoWalletUpdateManyMutationInput, CryptoWalletUncheckedUpdateManyInput>
    /**
     * Filter which CryptoWallets to update
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoWallet upsert
   */
  export type CryptoWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoWallet to update in case it exists.
     */
    where: CryptoWalletWhereUniqueInput
    /**
     * In case the CryptoWallet found by the `where` argument doesn't exist, create a new CryptoWallet with this data.
     */
    create: XOR<CryptoWalletCreateInput, CryptoWalletUncheckedCreateInput>
    /**
     * In case the CryptoWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoWalletUpdateInput, CryptoWalletUncheckedUpdateInput>
  }

  /**
   * CryptoWallet delete
   */
  export type CryptoWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
    /**
     * Filter which CryptoWallet to delete.
     */
    where: CryptoWalletWhereUniqueInput
  }

  /**
   * CryptoWallet deleteMany
   */
  export type CryptoWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoWallets to delete
     */
    where?: CryptoWalletWhereInput
    /**
     * Limit how many CryptoWallets to delete.
     */
    limit?: number
  }

  /**
   * CryptoWallet.transactions
   */
  export type CryptoWallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    where?: BlockchainTransactionWhereInput
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    cursor?: BlockchainTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * CryptoWallet without action
   */
  export type CryptoWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoWallet
     */
    select?: CryptoWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoWallet
     */
    omit?: CryptoWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoWalletInclude<ExtArgs> | null
  }


  /**
   * Model BlockchainRequest
   */

  export type AggregateBlockchainRequest = {
    _count: BlockchainRequestCountAggregateOutputType | null
    _avg: BlockchainRequestAvgAggregateOutputType | null
    _sum: BlockchainRequestSumAggregateOutputType | null
    _min: BlockchainRequestMinAggregateOutputType | null
    _max: BlockchainRequestMaxAggregateOutputType | null
  }

  export type BlockchainRequestAvgAggregateOutputType = {
    amount: number | null
    cryptoAmount: number | null
  }

  export type BlockchainRequestSumAggregateOutputType = {
    amount: number | null
    cryptoAmount: number | null
  }

  export type BlockchainRequestMinAggregateOutputType = {
    id: string | null
    billId: string | null
    blockchainBillId: string | null
    transactionHash: string | null
    status: $Enums.BlockchainTxStatus | null
    amount: number | null
    cryptoAmount: number | null
    paymentType: $Enums.PaymentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockchainRequestMaxAggregateOutputType = {
    id: string | null
    billId: string | null
    blockchainBillId: string | null
    transactionHash: string | null
    status: $Enums.BlockchainTxStatus | null
    amount: number | null
    cryptoAmount: number | null
    paymentType: $Enums.PaymentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockchainRequestCountAggregateOutputType = {
    id: number
    billId: number
    blockchainBillId: number
    transactionHash: number
    status: number
    amount: number
    cryptoAmount: number
    paymentType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockchainRequestAvgAggregateInputType = {
    amount?: true
    cryptoAmount?: true
  }

  export type BlockchainRequestSumAggregateInputType = {
    amount?: true
    cryptoAmount?: true
  }

  export type BlockchainRequestMinAggregateInputType = {
    id?: true
    billId?: true
    blockchainBillId?: true
    transactionHash?: true
    status?: true
    amount?: true
    cryptoAmount?: true
    paymentType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockchainRequestMaxAggregateInputType = {
    id?: true
    billId?: true
    blockchainBillId?: true
    transactionHash?: true
    status?: true
    amount?: true
    cryptoAmount?: true
    paymentType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockchainRequestCountAggregateInputType = {
    id?: true
    billId?: true
    blockchainBillId?: true
    transactionHash?: true
    status?: true
    amount?: true
    cryptoAmount?: true
    paymentType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockchainRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainRequest to aggregate.
     */
    where?: BlockchainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainRequests to fetch.
     */
    orderBy?: BlockchainRequestOrderByWithRelationInput | BlockchainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockchainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockchainRequests
    **/
    _count?: true | BlockchainRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockchainRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockchainRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockchainRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockchainRequestMaxAggregateInputType
  }

  export type GetBlockchainRequestAggregateType<T extends BlockchainRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockchainRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockchainRequest[P]>
      : GetScalarType<T[P], AggregateBlockchainRequest[P]>
  }




  export type BlockchainRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockchainRequestWhereInput
    orderBy?: BlockchainRequestOrderByWithAggregationInput | BlockchainRequestOrderByWithAggregationInput[]
    by: BlockchainRequestScalarFieldEnum[] | BlockchainRequestScalarFieldEnum
    having?: BlockchainRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockchainRequestCountAggregateInputType | true
    _avg?: BlockchainRequestAvgAggregateInputType
    _sum?: BlockchainRequestSumAggregateInputType
    _min?: BlockchainRequestMinAggregateInputType
    _max?: BlockchainRequestMaxAggregateInputType
  }

  export type BlockchainRequestGroupByOutputType = {
    id: string
    billId: string
    blockchainBillId: string | null
    transactionHash: string | null
    status: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType: $Enums.PaymentType
    createdAt: Date
    updatedAt: Date
    _count: BlockchainRequestCountAggregateOutputType | null
    _avg: BlockchainRequestAvgAggregateOutputType | null
    _sum: BlockchainRequestSumAggregateOutputType | null
    _min: BlockchainRequestMinAggregateOutputType | null
    _max: BlockchainRequestMaxAggregateOutputType | null
  }

  type GetBlockchainRequestGroupByPayload<T extends BlockchainRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockchainRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockchainRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockchainRequestGroupByOutputType[P]>
            : GetScalarType<T[P], BlockchainRequestGroupByOutputType[P]>
        }
      >
    >


  export type BlockchainRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    blockchainBillId?: boolean
    transactionHash?: boolean
    status?: boolean
    amount?: boolean
    cryptoAmount?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
    transactions?: boolean | BlockchainRequest$transactionsArgs<ExtArgs>
    _count?: boolean | BlockchainRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainRequest"]>

  export type BlockchainRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    blockchainBillId?: boolean
    transactionHash?: boolean
    status?: boolean
    amount?: boolean
    cryptoAmount?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainRequest"]>

  export type BlockchainRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billId?: boolean
    blockchainBillId?: boolean
    transactionHash?: boolean
    status?: boolean
    amount?: boolean
    cryptoAmount?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainRequest"]>

  export type BlockchainRequestSelectScalar = {
    id?: boolean
    billId?: boolean
    blockchainBillId?: boolean
    transactionHash?: boolean
    status?: boolean
    amount?: boolean
    cryptoAmount?: boolean
    paymentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlockchainRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billId" | "blockchainBillId" | "transactionHash" | "status" | "amount" | "cryptoAmount" | "paymentType" | "createdAt" | "updatedAt", ExtArgs["result"]["blockchainRequest"]>
  export type BlockchainRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
    transactions?: boolean | BlockchainRequest$transactionsArgs<ExtArgs>
    _count?: boolean | BlockchainRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlockchainRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }
  export type BlockchainRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | BillDefaultArgs<ExtArgs>
  }

  export type $BlockchainRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockchainRequest"
    objects: {
      bill: Prisma.$BillPayload<ExtArgs>
      transactions: Prisma.$BlockchainTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billId: string
      blockchainBillId: string | null
      transactionHash: string | null
      status: $Enums.BlockchainTxStatus
      amount: number
      cryptoAmount: number
      paymentType: $Enums.PaymentType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blockchainRequest"]>
    composites: {}
  }

  type BlockchainRequestGetPayload<S extends boolean | null | undefined | BlockchainRequestDefaultArgs> = $Result.GetResult<Prisma.$BlockchainRequestPayload, S>

  type BlockchainRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockchainRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockchainRequestCountAggregateInputType | true
    }

  export interface BlockchainRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockchainRequest'], meta: { name: 'BlockchainRequest' } }
    /**
     * Find zero or one BlockchainRequest that matches the filter.
     * @param {BlockchainRequestFindUniqueArgs} args - Arguments to find a BlockchainRequest
     * @example
     * // Get one BlockchainRequest
     * const blockchainRequest = await prisma.blockchainRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockchainRequestFindUniqueArgs>(args: SelectSubset<T, BlockchainRequestFindUniqueArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockchainRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockchainRequestFindUniqueOrThrowArgs} args - Arguments to find a BlockchainRequest
     * @example
     * // Get one BlockchainRequest
     * const blockchainRequest = await prisma.blockchainRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockchainRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockchainRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockchainRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainRequestFindFirstArgs} args - Arguments to find a BlockchainRequest
     * @example
     * // Get one BlockchainRequest
     * const blockchainRequest = await prisma.blockchainRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockchainRequestFindFirstArgs>(args?: SelectSubset<T, BlockchainRequestFindFirstArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockchainRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainRequestFindFirstOrThrowArgs} args - Arguments to find a BlockchainRequest
     * @example
     * // Get one BlockchainRequest
     * const blockchainRequest = await prisma.blockchainRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockchainRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockchainRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockchainRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockchainRequests
     * const blockchainRequests = await prisma.blockchainRequest.findMany()
     * 
     * // Get first 10 BlockchainRequests
     * const blockchainRequests = await prisma.blockchainRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockchainRequestWithIdOnly = await prisma.blockchainRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockchainRequestFindManyArgs>(args?: SelectSubset<T, BlockchainRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockchainRequest.
     * @param {BlockchainRequestCreateArgs} args - Arguments to create a BlockchainRequest.
     * @example
     * // Create one BlockchainRequest
     * const BlockchainRequest = await prisma.blockchainRequest.create({
     *   data: {
     *     // ... data to create a BlockchainRequest
     *   }
     * })
     * 
     */
    create<T extends BlockchainRequestCreateArgs>(args: SelectSubset<T, BlockchainRequestCreateArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockchainRequests.
     * @param {BlockchainRequestCreateManyArgs} args - Arguments to create many BlockchainRequests.
     * @example
     * // Create many BlockchainRequests
     * const blockchainRequest = await prisma.blockchainRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockchainRequestCreateManyArgs>(args?: SelectSubset<T, BlockchainRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockchainRequests and returns the data saved in the database.
     * @param {BlockchainRequestCreateManyAndReturnArgs} args - Arguments to create many BlockchainRequests.
     * @example
     * // Create many BlockchainRequests
     * const blockchainRequest = await prisma.blockchainRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockchainRequests and only return the `id`
     * const blockchainRequestWithIdOnly = await prisma.blockchainRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockchainRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockchainRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockchainRequest.
     * @param {BlockchainRequestDeleteArgs} args - Arguments to delete one BlockchainRequest.
     * @example
     * // Delete one BlockchainRequest
     * const BlockchainRequest = await prisma.blockchainRequest.delete({
     *   where: {
     *     // ... filter to delete one BlockchainRequest
     *   }
     * })
     * 
     */
    delete<T extends BlockchainRequestDeleteArgs>(args: SelectSubset<T, BlockchainRequestDeleteArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockchainRequest.
     * @param {BlockchainRequestUpdateArgs} args - Arguments to update one BlockchainRequest.
     * @example
     * // Update one BlockchainRequest
     * const blockchainRequest = await prisma.blockchainRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockchainRequestUpdateArgs>(args: SelectSubset<T, BlockchainRequestUpdateArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockchainRequests.
     * @param {BlockchainRequestDeleteManyArgs} args - Arguments to filter BlockchainRequests to delete.
     * @example
     * // Delete a few BlockchainRequests
     * const { count } = await prisma.blockchainRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockchainRequestDeleteManyArgs>(args?: SelectSubset<T, BlockchainRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockchainRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockchainRequests
     * const blockchainRequest = await prisma.blockchainRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockchainRequestUpdateManyArgs>(args: SelectSubset<T, BlockchainRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockchainRequests and returns the data updated in the database.
     * @param {BlockchainRequestUpdateManyAndReturnArgs} args - Arguments to update many BlockchainRequests.
     * @example
     * // Update many BlockchainRequests
     * const blockchainRequest = await prisma.blockchainRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockchainRequests and only return the `id`
     * const blockchainRequestWithIdOnly = await prisma.blockchainRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockchainRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockchainRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockchainRequest.
     * @param {BlockchainRequestUpsertArgs} args - Arguments to update or create a BlockchainRequest.
     * @example
     * // Update or create a BlockchainRequest
     * const blockchainRequest = await prisma.blockchainRequest.upsert({
     *   create: {
     *     // ... data to create a BlockchainRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockchainRequest we want to update
     *   }
     * })
     */
    upsert<T extends BlockchainRequestUpsertArgs>(args: SelectSubset<T, BlockchainRequestUpsertArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockchainRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainRequestCountArgs} args - Arguments to filter BlockchainRequests to count.
     * @example
     * // Count the number of BlockchainRequests
     * const count = await prisma.blockchainRequest.count({
     *   where: {
     *     // ... the filter for the BlockchainRequests we want to count
     *   }
     * })
    **/
    count<T extends BlockchainRequestCountArgs>(
      args?: Subset<T, BlockchainRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockchainRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockchainRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockchainRequestAggregateArgs>(args: Subset<T, BlockchainRequestAggregateArgs>): Prisma.PrismaPromise<GetBlockchainRequestAggregateType<T>>

    /**
     * Group by BlockchainRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockchainRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockchainRequestGroupByArgs['orderBy'] }
        : { orderBy?: BlockchainRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockchainRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockchainRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockchainRequest model
   */
  readonly fields: BlockchainRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockchainRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockchainRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends BillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillDefaultArgs<ExtArgs>>): Prisma__BillClient<$Result.GetResult<Prisma.$BillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends BlockchainRequest$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, BlockchainRequest$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockchainRequest model
   */
  interface BlockchainRequestFieldRefs {
    readonly id: FieldRef<"BlockchainRequest", 'String'>
    readonly billId: FieldRef<"BlockchainRequest", 'String'>
    readonly blockchainBillId: FieldRef<"BlockchainRequest", 'String'>
    readonly transactionHash: FieldRef<"BlockchainRequest", 'String'>
    readonly status: FieldRef<"BlockchainRequest", 'BlockchainTxStatus'>
    readonly amount: FieldRef<"BlockchainRequest", 'Float'>
    readonly cryptoAmount: FieldRef<"BlockchainRequest", 'Float'>
    readonly paymentType: FieldRef<"BlockchainRequest", 'PaymentType'>
    readonly createdAt: FieldRef<"BlockchainRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockchainRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockchainRequest findUnique
   */
  export type BlockchainRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainRequest to fetch.
     */
    where: BlockchainRequestWhereUniqueInput
  }

  /**
   * BlockchainRequest findUniqueOrThrow
   */
  export type BlockchainRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainRequest to fetch.
     */
    where: BlockchainRequestWhereUniqueInput
  }

  /**
   * BlockchainRequest findFirst
   */
  export type BlockchainRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainRequest to fetch.
     */
    where?: BlockchainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainRequests to fetch.
     */
    orderBy?: BlockchainRequestOrderByWithRelationInput | BlockchainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainRequests.
     */
    cursor?: BlockchainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainRequests.
     */
    distinct?: BlockchainRequestScalarFieldEnum | BlockchainRequestScalarFieldEnum[]
  }

  /**
   * BlockchainRequest findFirstOrThrow
   */
  export type BlockchainRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainRequest to fetch.
     */
    where?: BlockchainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainRequests to fetch.
     */
    orderBy?: BlockchainRequestOrderByWithRelationInput | BlockchainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainRequests.
     */
    cursor?: BlockchainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainRequests.
     */
    distinct?: BlockchainRequestScalarFieldEnum | BlockchainRequestScalarFieldEnum[]
  }

  /**
   * BlockchainRequest findMany
   */
  export type BlockchainRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainRequests to fetch.
     */
    where?: BlockchainRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainRequests to fetch.
     */
    orderBy?: BlockchainRequestOrderByWithRelationInput | BlockchainRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockchainRequests.
     */
    cursor?: BlockchainRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainRequests.
     */
    skip?: number
    distinct?: BlockchainRequestScalarFieldEnum | BlockchainRequestScalarFieldEnum[]
  }

  /**
   * BlockchainRequest create
   */
  export type BlockchainRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockchainRequest.
     */
    data: XOR<BlockchainRequestCreateInput, BlockchainRequestUncheckedCreateInput>
  }

  /**
   * BlockchainRequest createMany
   */
  export type BlockchainRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockchainRequests.
     */
    data: BlockchainRequestCreateManyInput | BlockchainRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockchainRequest createManyAndReturn
   */
  export type BlockchainRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * The data used to create many BlockchainRequests.
     */
    data: BlockchainRequestCreateManyInput | BlockchainRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockchainRequest update
   */
  export type BlockchainRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockchainRequest.
     */
    data: XOR<BlockchainRequestUpdateInput, BlockchainRequestUncheckedUpdateInput>
    /**
     * Choose, which BlockchainRequest to update.
     */
    where: BlockchainRequestWhereUniqueInput
  }

  /**
   * BlockchainRequest updateMany
   */
  export type BlockchainRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockchainRequests.
     */
    data: XOR<BlockchainRequestUpdateManyMutationInput, BlockchainRequestUncheckedUpdateManyInput>
    /**
     * Filter which BlockchainRequests to update
     */
    where?: BlockchainRequestWhereInput
    /**
     * Limit how many BlockchainRequests to update.
     */
    limit?: number
  }

  /**
   * BlockchainRequest updateManyAndReturn
   */
  export type BlockchainRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * The data used to update BlockchainRequests.
     */
    data: XOR<BlockchainRequestUpdateManyMutationInput, BlockchainRequestUncheckedUpdateManyInput>
    /**
     * Filter which BlockchainRequests to update
     */
    where?: BlockchainRequestWhereInput
    /**
     * Limit how many BlockchainRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockchainRequest upsert
   */
  export type BlockchainRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockchainRequest to update in case it exists.
     */
    where: BlockchainRequestWhereUniqueInput
    /**
     * In case the BlockchainRequest found by the `where` argument doesn't exist, create a new BlockchainRequest with this data.
     */
    create: XOR<BlockchainRequestCreateInput, BlockchainRequestUncheckedCreateInput>
    /**
     * In case the BlockchainRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockchainRequestUpdateInput, BlockchainRequestUncheckedUpdateInput>
  }

  /**
   * BlockchainRequest delete
   */
  export type BlockchainRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    /**
     * Filter which BlockchainRequest to delete.
     */
    where: BlockchainRequestWhereUniqueInput
  }

  /**
   * BlockchainRequest deleteMany
   */
  export type BlockchainRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainRequests to delete
     */
    where?: BlockchainRequestWhereInput
    /**
     * Limit how many BlockchainRequests to delete.
     */
    limit?: number
  }

  /**
   * BlockchainRequest.transactions
   */
  export type BlockchainRequest$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    where?: BlockchainTransactionWhereInput
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    cursor?: BlockchainTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * BlockchainRequest without action
   */
  export type BlockchainRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
  }


  /**
   * Model BlockchainTransaction
   */

  export type AggregateBlockchainTransaction = {
    _count: BlockchainTransactionCountAggregateOutputType | null
    _avg: BlockchainTransactionAvgAggregateOutputType | null
    _sum: BlockchainTransactionSumAggregateOutputType | null
    _min: BlockchainTransactionMinAggregateOutputType | null
    _max: BlockchainTransactionMaxAggregateOutputType | null
  }

  export type BlockchainTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type BlockchainTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type BlockchainTransactionMinAggregateOutputType = {
    id: string | null
    transactionHash: string | null
    from: string | null
    to: string | null
    amount: number | null
    status: $Enums.BlockchainTxStatus | null
    cryptoWalletId: string | null
    blockchainRequestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockchainTransactionMaxAggregateOutputType = {
    id: string | null
    transactionHash: string | null
    from: string | null
    to: string | null
    amount: number | null
    status: $Enums.BlockchainTxStatus | null
    cryptoWalletId: string | null
    blockchainRequestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockchainTransactionCountAggregateOutputType = {
    id: number
    transactionHash: number
    from: number
    to: number
    amount: number
    status: number
    cryptoWalletId: number
    blockchainRequestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockchainTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type BlockchainTransactionSumAggregateInputType = {
    amount?: true
  }

  export type BlockchainTransactionMinAggregateInputType = {
    id?: true
    transactionHash?: true
    from?: true
    to?: true
    amount?: true
    status?: true
    cryptoWalletId?: true
    blockchainRequestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockchainTransactionMaxAggregateInputType = {
    id?: true
    transactionHash?: true
    from?: true
    to?: true
    amount?: true
    status?: true
    cryptoWalletId?: true
    blockchainRequestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockchainTransactionCountAggregateInputType = {
    id?: true
    transactionHash?: true
    from?: true
    to?: true
    amount?: true
    status?: true
    cryptoWalletId?: true
    blockchainRequestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockchainTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainTransaction to aggregate.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockchainTransactions
    **/
    _count?: true | BlockchainTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockchainTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockchainTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockchainTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockchainTransactionMaxAggregateInputType
  }

  export type GetBlockchainTransactionAggregateType<T extends BlockchainTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockchainTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockchainTransaction[P]>
      : GetScalarType<T[P], AggregateBlockchainTransaction[P]>
  }




  export type BlockchainTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockchainTransactionWhereInput
    orderBy?: BlockchainTransactionOrderByWithAggregationInput | BlockchainTransactionOrderByWithAggregationInput[]
    by: BlockchainTransactionScalarFieldEnum[] | BlockchainTransactionScalarFieldEnum
    having?: BlockchainTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockchainTransactionCountAggregateInputType | true
    _avg?: BlockchainTransactionAvgAggregateInputType
    _sum?: BlockchainTransactionSumAggregateInputType
    _min?: BlockchainTransactionMinAggregateInputType
    _max?: BlockchainTransactionMaxAggregateInputType
  }

  export type BlockchainTransactionGroupByOutputType = {
    id: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    cryptoWalletId: string
    blockchainRequestId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlockchainTransactionCountAggregateOutputType | null
    _avg: BlockchainTransactionAvgAggregateOutputType | null
    _sum: BlockchainTransactionSumAggregateOutputType | null
    _min: BlockchainTransactionMinAggregateOutputType | null
    _max: BlockchainTransactionMaxAggregateOutputType | null
  }

  type GetBlockchainTransactionGroupByPayload<T extends BlockchainTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockchainTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockchainTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockchainTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BlockchainTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BlockchainTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionHash?: boolean
    from?: boolean
    to?: boolean
    amount?: boolean
    status?: boolean
    cryptoWalletId?: boolean
    blockchainRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cryptoWallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    blockchainRequest?: boolean | BlockchainTransaction$blockchainRequestArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainTransaction"]>

  export type BlockchainTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionHash?: boolean
    from?: boolean
    to?: boolean
    amount?: boolean
    status?: boolean
    cryptoWalletId?: boolean
    blockchainRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cryptoWallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    blockchainRequest?: boolean | BlockchainTransaction$blockchainRequestArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainTransaction"]>

  export type BlockchainTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionHash?: boolean
    from?: boolean
    to?: boolean
    amount?: boolean
    status?: boolean
    cryptoWalletId?: boolean
    blockchainRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cryptoWallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    blockchainRequest?: boolean | BlockchainTransaction$blockchainRequestArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainTransaction"]>

  export type BlockchainTransactionSelectScalar = {
    id?: boolean
    transactionHash?: boolean
    from?: boolean
    to?: boolean
    amount?: boolean
    status?: boolean
    cryptoWalletId?: boolean
    blockchainRequestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlockchainTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionHash" | "from" | "to" | "amount" | "status" | "cryptoWalletId" | "blockchainRequestId" | "createdAt" | "updatedAt", ExtArgs["result"]["blockchainTransaction"]>
  export type BlockchainTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cryptoWallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    blockchainRequest?: boolean | BlockchainTransaction$blockchainRequestArgs<ExtArgs>
  }
  export type BlockchainTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cryptoWallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    blockchainRequest?: boolean | BlockchainTransaction$blockchainRequestArgs<ExtArgs>
  }
  export type BlockchainTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cryptoWallet?: boolean | CryptoWalletDefaultArgs<ExtArgs>
    blockchainRequest?: boolean | BlockchainTransaction$blockchainRequestArgs<ExtArgs>
  }

  export type $BlockchainTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockchainTransaction"
    objects: {
      cryptoWallet: Prisma.$CryptoWalletPayload<ExtArgs>
      blockchainRequest: Prisma.$BlockchainRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionHash: string
      from: string
      to: string
      amount: number
      status: $Enums.BlockchainTxStatus
      cryptoWalletId: string
      blockchainRequestId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blockchainTransaction"]>
    composites: {}
  }

  type BlockchainTransactionGetPayload<S extends boolean | null | undefined | BlockchainTransactionDefaultArgs> = $Result.GetResult<Prisma.$BlockchainTransactionPayload, S>

  type BlockchainTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockchainTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockchainTransactionCountAggregateInputType | true
    }

  export interface BlockchainTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockchainTransaction'], meta: { name: 'BlockchainTransaction' } }
    /**
     * Find zero or one BlockchainTransaction that matches the filter.
     * @param {BlockchainTransactionFindUniqueArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockchainTransactionFindUniqueArgs>(args: SelectSubset<T, BlockchainTransactionFindUniqueArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockchainTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockchainTransactionFindUniqueOrThrowArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockchainTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockchainTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindFirstArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockchainTransactionFindFirstArgs>(args?: SelectSubset<T, BlockchainTransactionFindFirstArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockchainTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindFirstOrThrowArgs} args - Arguments to find a BlockchainTransaction
     * @example
     * // Get one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockchainTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockchainTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockchainTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockchainTransactions
     * const blockchainTransactions = await prisma.blockchainTransaction.findMany()
     * 
     * // Get first 10 BlockchainTransactions
     * const blockchainTransactions = await prisma.blockchainTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockchainTransactionWithIdOnly = await prisma.blockchainTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockchainTransactionFindManyArgs>(args?: SelectSubset<T, BlockchainTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockchainTransaction.
     * @param {BlockchainTransactionCreateArgs} args - Arguments to create a BlockchainTransaction.
     * @example
     * // Create one BlockchainTransaction
     * const BlockchainTransaction = await prisma.blockchainTransaction.create({
     *   data: {
     *     // ... data to create a BlockchainTransaction
     *   }
     * })
     * 
     */
    create<T extends BlockchainTransactionCreateArgs>(args: SelectSubset<T, BlockchainTransactionCreateArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockchainTransactions.
     * @param {BlockchainTransactionCreateManyArgs} args - Arguments to create many BlockchainTransactions.
     * @example
     * // Create many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockchainTransactionCreateManyArgs>(args?: SelectSubset<T, BlockchainTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockchainTransactions and returns the data saved in the database.
     * @param {BlockchainTransactionCreateManyAndReturnArgs} args - Arguments to create many BlockchainTransactions.
     * @example
     * // Create many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockchainTransactions and only return the `id`
     * const blockchainTransactionWithIdOnly = await prisma.blockchainTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockchainTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockchainTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockchainTransaction.
     * @param {BlockchainTransactionDeleteArgs} args - Arguments to delete one BlockchainTransaction.
     * @example
     * // Delete one BlockchainTransaction
     * const BlockchainTransaction = await prisma.blockchainTransaction.delete({
     *   where: {
     *     // ... filter to delete one BlockchainTransaction
     *   }
     * })
     * 
     */
    delete<T extends BlockchainTransactionDeleteArgs>(args: SelectSubset<T, BlockchainTransactionDeleteArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockchainTransaction.
     * @param {BlockchainTransactionUpdateArgs} args - Arguments to update one BlockchainTransaction.
     * @example
     * // Update one BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockchainTransactionUpdateArgs>(args: SelectSubset<T, BlockchainTransactionUpdateArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockchainTransactions.
     * @param {BlockchainTransactionDeleteManyArgs} args - Arguments to filter BlockchainTransactions to delete.
     * @example
     * // Delete a few BlockchainTransactions
     * const { count } = await prisma.blockchainTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockchainTransactionDeleteManyArgs>(args?: SelectSubset<T, BlockchainTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockchainTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockchainTransactionUpdateManyArgs>(args: SelectSubset<T, BlockchainTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockchainTransactions and returns the data updated in the database.
     * @param {BlockchainTransactionUpdateManyAndReturnArgs} args - Arguments to update many BlockchainTransactions.
     * @example
     * // Update many BlockchainTransactions
     * const blockchainTransaction = await prisma.blockchainTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockchainTransactions and only return the `id`
     * const blockchainTransactionWithIdOnly = await prisma.blockchainTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockchainTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockchainTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockchainTransaction.
     * @param {BlockchainTransactionUpsertArgs} args - Arguments to update or create a BlockchainTransaction.
     * @example
     * // Update or create a BlockchainTransaction
     * const blockchainTransaction = await prisma.blockchainTransaction.upsert({
     *   create: {
     *     // ... data to create a BlockchainTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockchainTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BlockchainTransactionUpsertArgs>(args: SelectSubset<T, BlockchainTransactionUpsertArgs<ExtArgs>>): Prisma__BlockchainTransactionClient<$Result.GetResult<Prisma.$BlockchainTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockchainTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionCountArgs} args - Arguments to filter BlockchainTransactions to count.
     * @example
     * // Count the number of BlockchainTransactions
     * const count = await prisma.blockchainTransaction.count({
     *   where: {
     *     // ... the filter for the BlockchainTransactions we want to count
     *   }
     * })
    **/
    count<T extends BlockchainTransactionCountArgs>(
      args?: Subset<T, BlockchainTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockchainTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockchainTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockchainTransactionAggregateArgs>(args: Subset<T, BlockchainTransactionAggregateArgs>): Prisma.PrismaPromise<GetBlockchainTransactionAggregateType<T>>

    /**
     * Group by BlockchainTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockchainTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockchainTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BlockchainTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockchainTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockchainTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockchainTransaction model
   */
  readonly fields: BlockchainTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockchainTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockchainTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cryptoWallet<T extends CryptoWalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoWalletDefaultArgs<ExtArgs>>): Prisma__CryptoWalletClient<$Result.GetResult<Prisma.$CryptoWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blockchainRequest<T extends BlockchainTransaction$blockchainRequestArgs<ExtArgs> = {}>(args?: Subset<T, BlockchainTransaction$blockchainRequestArgs<ExtArgs>>): Prisma__BlockchainRequestClient<$Result.GetResult<Prisma.$BlockchainRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockchainTransaction model
   */
  interface BlockchainTransactionFieldRefs {
    readonly id: FieldRef<"BlockchainTransaction", 'String'>
    readonly transactionHash: FieldRef<"BlockchainTransaction", 'String'>
    readonly from: FieldRef<"BlockchainTransaction", 'String'>
    readonly to: FieldRef<"BlockchainTransaction", 'String'>
    readonly amount: FieldRef<"BlockchainTransaction", 'Float'>
    readonly status: FieldRef<"BlockchainTransaction", 'BlockchainTxStatus'>
    readonly cryptoWalletId: FieldRef<"BlockchainTransaction", 'String'>
    readonly blockchainRequestId: FieldRef<"BlockchainTransaction", 'String'>
    readonly createdAt: FieldRef<"BlockchainTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockchainTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockchainTransaction findUnique
   */
  export type BlockchainTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction findUniqueOrThrow
   */
  export type BlockchainTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction findFirst
   */
  export type BlockchainTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainTransactions.
     */
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * BlockchainTransaction findFirstOrThrow
   */
  export type BlockchainTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransaction to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainTransactions.
     */
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * BlockchainTransaction findMany
   */
  export type BlockchainTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainTransactions to fetch.
     */
    where?: BlockchainTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainTransactions to fetch.
     */
    orderBy?: BlockchainTransactionOrderByWithRelationInput | BlockchainTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockchainTransactions.
     */
    cursor?: BlockchainTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainTransactions.
     */
    skip?: number
    distinct?: BlockchainTransactionScalarFieldEnum | BlockchainTransactionScalarFieldEnum[]
  }

  /**
   * BlockchainTransaction create
   */
  export type BlockchainTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockchainTransaction.
     */
    data: XOR<BlockchainTransactionCreateInput, BlockchainTransactionUncheckedCreateInput>
  }

  /**
   * BlockchainTransaction createMany
   */
  export type BlockchainTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockchainTransactions.
     */
    data: BlockchainTransactionCreateManyInput | BlockchainTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockchainTransaction createManyAndReturn
   */
  export type BlockchainTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many BlockchainTransactions.
     */
    data: BlockchainTransactionCreateManyInput | BlockchainTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockchainTransaction update
   */
  export type BlockchainTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockchainTransaction.
     */
    data: XOR<BlockchainTransactionUpdateInput, BlockchainTransactionUncheckedUpdateInput>
    /**
     * Choose, which BlockchainTransaction to update.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction updateMany
   */
  export type BlockchainTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockchainTransactions.
     */
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BlockchainTransactions to update
     */
    where?: BlockchainTransactionWhereInput
    /**
     * Limit how many BlockchainTransactions to update.
     */
    limit?: number
  }

  /**
   * BlockchainTransaction updateManyAndReturn
   */
  export type BlockchainTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * The data used to update BlockchainTransactions.
     */
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BlockchainTransactions to update
     */
    where?: BlockchainTransactionWhereInput
    /**
     * Limit how many BlockchainTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockchainTransaction upsert
   */
  export type BlockchainTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockchainTransaction to update in case it exists.
     */
    where: BlockchainTransactionWhereUniqueInput
    /**
     * In case the BlockchainTransaction found by the `where` argument doesn't exist, create a new BlockchainTransaction with this data.
     */
    create: XOR<BlockchainTransactionCreateInput, BlockchainTransactionUncheckedCreateInput>
    /**
     * In case the BlockchainTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockchainTransactionUpdateInput, BlockchainTransactionUncheckedUpdateInput>
  }

  /**
   * BlockchainTransaction delete
   */
  export type BlockchainTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
    /**
     * Filter which BlockchainTransaction to delete.
     */
    where: BlockchainTransactionWhereUniqueInput
  }

  /**
   * BlockchainTransaction deleteMany
   */
  export type BlockchainTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainTransactions to delete
     */
    where?: BlockchainTransactionWhereInput
    /**
     * Limit how many BlockchainTransactions to delete.
     */
    limit?: number
  }

  /**
   * BlockchainTransaction.blockchainRequest
   */
  export type BlockchainTransaction$blockchainRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainRequest
     */
    select?: BlockchainRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainRequest
     */
    omit?: BlockchainRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainRequestInclude<ExtArgs> | null
    where?: BlockchainRequestWhereInput
  }

  /**
   * BlockchainTransaction without action
   */
  export type BlockchainTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainTransaction
     */
    select?: BlockchainTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockchainTransaction
     */
    omit?: BlockchainTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockchainTransactionInclude<ExtArgs> | null
  }


  /**
   * Model SplitPayment
   */

  export type AggregateSplitPayment = {
    _count: SplitPaymentCountAggregateOutputType | null
    _avg: SplitPaymentAvgAggregateOutputType | null
    _sum: SplitPaymentSumAggregateOutputType | null
    _min: SplitPaymentMinAggregateOutputType | null
    _max: SplitPaymentMaxAggregateOutputType | null
  }

  export type SplitPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type SplitPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type SplitPaymentMinAggregateOutputType = {
    id: string | null
    email: string | null
    amount: number | null
    splitCode: string | null
    reference: string | null
    status: string | null
    createdAt: Date | null
  }

  export type SplitPaymentMaxAggregateOutputType = {
    id: string | null
    email: string | null
    amount: number | null
    splitCode: string | null
    reference: string | null
    status: string | null
    createdAt: Date | null
  }

  export type SplitPaymentCountAggregateOutputType = {
    id: number
    email: number
    amount: number
    splitCode: number
    reference: number
    status: number
    createdAt: number
    _all: number
  }


  export type SplitPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type SplitPaymentSumAggregateInputType = {
    amount?: true
  }

  export type SplitPaymentMinAggregateInputType = {
    id?: true
    email?: true
    amount?: true
    splitCode?: true
    reference?: true
    status?: true
    createdAt?: true
  }

  export type SplitPaymentMaxAggregateInputType = {
    id?: true
    email?: true
    amount?: true
    splitCode?: true
    reference?: true
    status?: true
    createdAt?: true
  }

  export type SplitPaymentCountAggregateInputType = {
    id?: true
    email?: true
    amount?: true
    splitCode?: true
    reference?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type SplitPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SplitPayment to aggregate.
     */
    where?: SplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitPayments to fetch.
     */
    orderBy?: SplitPaymentOrderByWithRelationInput | SplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SplitPayments
    **/
    _count?: true | SplitPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SplitPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SplitPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SplitPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SplitPaymentMaxAggregateInputType
  }

  export type GetSplitPaymentAggregateType<T extends SplitPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSplitPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSplitPayment[P]>
      : GetScalarType<T[P], AggregateSplitPayment[P]>
  }




  export type SplitPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SplitPaymentWhereInput
    orderBy?: SplitPaymentOrderByWithAggregationInput | SplitPaymentOrderByWithAggregationInput[]
    by: SplitPaymentScalarFieldEnum[] | SplitPaymentScalarFieldEnum
    having?: SplitPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SplitPaymentCountAggregateInputType | true
    _avg?: SplitPaymentAvgAggregateInputType
    _sum?: SplitPaymentSumAggregateInputType
    _min?: SplitPaymentMinAggregateInputType
    _max?: SplitPaymentMaxAggregateInputType
  }

  export type SplitPaymentGroupByOutputType = {
    id: string
    email: string
    amount: number
    splitCode: string
    reference: string
    status: string
    createdAt: Date
    _count: SplitPaymentCountAggregateOutputType | null
    _avg: SplitPaymentAvgAggregateOutputType | null
    _sum: SplitPaymentSumAggregateOutputType | null
    _min: SplitPaymentMinAggregateOutputType | null
    _max: SplitPaymentMaxAggregateOutputType | null
  }

  type GetSplitPaymentGroupByPayload<T extends SplitPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SplitPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SplitPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SplitPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SplitPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SplitPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    amount?: boolean
    splitCode?: boolean
    reference?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["splitPayment"]>

  export type SplitPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    amount?: boolean
    splitCode?: boolean
    reference?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["splitPayment"]>

  export type SplitPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    amount?: boolean
    splitCode?: boolean
    reference?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["splitPayment"]>

  export type SplitPaymentSelectScalar = {
    id?: boolean
    email?: boolean
    amount?: boolean
    splitCode?: boolean
    reference?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type SplitPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "amount" | "splitCode" | "reference" | "status" | "createdAt", ExtArgs["result"]["splitPayment"]>

  export type $SplitPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SplitPayment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      amount: number
      splitCode: string
      reference: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["splitPayment"]>
    composites: {}
  }

  type SplitPaymentGetPayload<S extends boolean | null | undefined | SplitPaymentDefaultArgs> = $Result.GetResult<Prisma.$SplitPaymentPayload, S>

  type SplitPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SplitPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SplitPaymentCountAggregateInputType | true
    }

  export interface SplitPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SplitPayment'], meta: { name: 'SplitPayment' } }
    /**
     * Find zero or one SplitPayment that matches the filter.
     * @param {SplitPaymentFindUniqueArgs} args - Arguments to find a SplitPayment
     * @example
     * // Get one SplitPayment
     * const splitPayment = await prisma.splitPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SplitPaymentFindUniqueArgs>(args: SelectSubset<T, SplitPaymentFindUniqueArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SplitPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SplitPaymentFindUniqueOrThrowArgs} args - Arguments to find a SplitPayment
     * @example
     * // Get one SplitPayment
     * const splitPayment = await prisma.splitPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SplitPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SplitPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SplitPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitPaymentFindFirstArgs} args - Arguments to find a SplitPayment
     * @example
     * // Get one SplitPayment
     * const splitPayment = await prisma.splitPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SplitPaymentFindFirstArgs>(args?: SelectSubset<T, SplitPaymentFindFirstArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SplitPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitPaymentFindFirstOrThrowArgs} args - Arguments to find a SplitPayment
     * @example
     * // Get one SplitPayment
     * const splitPayment = await prisma.splitPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SplitPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SplitPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SplitPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SplitPayments
     * const splitPayments = await prisma.splitPayment.findMany()
     * 
     * // Get first 10 SplitPayments
     * const splitPayments = await prisma.splitPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const splitPaymentWithIdOnly = await prisma.splitPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SplitPaymentFindManyArgs>(args?: SelectSubset<T, SplitPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SplitPayment.
     * @param {SplitPaymentCreateArgs} args - Arguments to create a SplitPayment.
     * @example
     * // Create one SplitPayment
     * const SplitPayment = await prisma.splitPayment.create({
     *   data: {
     *     // ... data to create a SplitPayment
     *   }
     * })
     * 
     */
    create<T extends SplitPaymentCreateArgs>(args: SelectSubset<T, SplitPaymentCreateArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SplitPayments.
     * @param {SplitPaymentCreateManyArgs} args - Arguments to create many SplitPayments.
     * @example
     * // Create many SplitPayments
     * const splitPayment = await prisma.splitPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SplitPaymentCreateManyArgs>(args?: SelectSubset<T, SplitPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SplitPayments and returns the data saved in the database.
     * @param {SplitPaymentCreateManyAndReturnArgs} args - Arguments to create many SplitPayments.
     * @example
     * // Create many SplitPayments
     * const splitPayment = await prisma.splitPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SplitPayments and only return the `id`
     * const splitPaymentWithIdOnly = await prisma.splitPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SplitPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SplitPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SplitPayment.
     * @param {SplitPaymentDeleteArgs} args - Arguments to delete one SplitPayment.
     * @example
     * // Delete one SplitPayment
     * const SplitPayment = await prisma.splitPayment.delete({
     *   where: {
     *     // ... filter to delete one SplitPayment
     *   }
     * })
     * 
     */
    delete<T extends SplitPaymentDeleteArgs>(args: SelectSubset<T, SplitPaymentDeleteArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SplitPayment.
     * @param {SplitPaymentUpdateArgs} args - Arguments to update one SplitPayment.
     * @example
     * // Update one SplitPayment
     * const splitPayment = await prisma.splitPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SplitPaymentUpdateArgs>(args: SelectSubset<T, SplitPaymentUpdateArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SplitPayments.
     * @param {SplitPaymentDeleteManyArgs} args - Arguments to filter SplitPayments to delete.
     * @example
     * // Delete a few SplitPayments
     * const { count } = await prisma.splitPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SplitPaymentDeleteManyArgs>(args?: SelectSubset<T, SplitPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SplitPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SplitPayments
     * const splitPayment = await prisma.splitPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SplitPaymentUpdateManyArgs>(args: SelectSubset<T, SplitPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SplitPayments and returns the data updated in the database.
     * @param {SplitPaymentUpdateManyAndReturnArgs} args - Arguments to update many SplitPayments.
     * @example
     * // Update many SplitPayments
     * const splitPayment = await prisma.splitPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SplitPayments and only return the `id`
     * const splitPaymentWithIdOnly = await prisma.splitPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SplitPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, SplitPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SplitPayment.
     * @param {SplitPaymentUpsertArgs} args - Arguments to update or create a SplitPayment.
     * @example
     * // Update or create a SplitPayment
     * const splitPayment = await prisma.splitPayment.upsert({
     *   create: {
     *     // ... data to create a SplitPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SplitPayment we want to update
     *   }
     * })
     */
    upsert<T extends SplitPaymentUpsertArgs>(args: SelectSubset<T, SplitPaymentUpsertArgs<ExtArgs>>): Prisma__SplitPaymentClient<$Result.GetResult<Prisma.$SplitPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SplitPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitPaymentCountArgs} args - Arguments to filter SplitPayments to count.
     * @example
     * // Count the number of SplitPayments
     * const count = await prisma.splitPayment.count({
     *   where: {
     *     // ... the filter for the SplitPayments we want to count
     *   }
     * })
    **/
    count<T extends SplitPaymentCountArgs>(
      args?: Subset<T, SplitPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SplitPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SplitPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SplitPaymentAggregateArgs>(args: Subset<T, SplitPaymentAggregateArgs>): Prisma.PrismaPromise<GetSplitPaymentAggregateType<T>>

    /**
     * Group by SplitPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SplitPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SplitPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SplitPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SplitPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SplitPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSplitPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SplitPayment model
   */
  readonly fields: SplitPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SplitPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SplitPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SplitPayment model
   */
  interface SplitPaymentFieldRefs {
    readonly id: FieldRef<"SplitPayment", 'String'>
    readonly email: FieldRef<"SplitPayment", 'String'>
    readonly amount: FieldRef<"SplitPayment", 'Float'>
    readonly splitCode: FieldRef<"SplitPayment", 'String'>
    readonly reference: FieldRef<"SplitPayment", 'String'>
    readonly status: FieldRef<"SplitPayment", 'String'>
    readonly createdAt: FieldRef<"SplitPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SplitPayment findUnique
   */
  export type SplitPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SplitPayment to fetch.
     */
    where: SplitPaymentWhereUniqueInput
  }

  /**
   * SplitPayment findUniqueOrThrow
   */
  export type SplitPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SplitPayment to fetch.
     */
    where: SplitPaymentWhereUniqueInput
  }

  /**
   * SplitPayment findFirst
   */
  export type SplitPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SplitPayment to fetch.
     */
    where?: SplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitPayments to fetch.
     */
    orderBy?: SplitPaymentOrderByWithRelationInput | SplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SplitPayments.
     */
    cursor?: SplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SplitPayments.
     */
    distinct?: SplitPaymentScalarFieldEnum | SplitPaymentScalarFieldEnum[]
  }

  /**
   * SplitPayment findFirstOrThrow
   */
  export type SplitPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SplitPayment to fetch.
     */
    where?: SplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitPayments to fetch.
     */
    orderBy?: SplitPaymentOrderByWithRelationInput | SplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SplitPayments.
     */
    cursor?: SplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SplitPayments.
     */
    distinct?: SplitPaymentScalarFieldEnum | SplitPaymentScalarFieldEnum[]
  }

  /**
   * SplitPayment findMany
   */
  export type SplitPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * Filter, which SplitPayments to fetch.
     */
    where?: SplitPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SplitPayments to fetch.
     */
    orderBy?: SplitPaymentOrderByWithRelationInput | SplitPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SplitPayments.
     */
    cursor?: SplitPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SplitPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SplitPayments.
     */
    skip?: number
    distinct?: SplitPaymentScalarFieldEnum | SplitPaymentScalarFieldEnum[]
  }

  /**
   * SplitPayment create
   */
  export type SplitPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * The data needed to create a SplitPayment.
     */
    data: XOR<SplitPaymentCreateInput, SplitPaymentUncheckedCreateInput>
  }

  /**
   * SplitPayment createMany
   */
  export type SplitPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SplitPayments.
     */
    data: SplitPaymentCreateManyInput | SplitPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SplitPayment createManyAndReturn
   */
  export type SplitPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many SplitPayments.
     */
    data: SplitPaymentCreateManyInput | SplitPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SplitPayment update
   */
  export type SplitPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * The data needed to update a SplitPayment.
     */
    data: XOR<SplitPaymentUpdateInput, SplitPaymentUncheckedUpdateInput>
    /**
     * Choose, which SplitPayment to update.
     */
    where: SplitPaymentWhereUniqueInput
  }

  /**
   * SplitPayment updateMany
   */
  export type SplitPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SplitPayments.
     */
    data: XOR<SplitPaymentUpdateManyMutationInput, SplitPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SplitPayments to update
     */
    where?: SplitPaymentWhereInput
    /**
     * Limit how many SplitPayments to update.
     */
    limit?: number
  }

  /**
   * SplitPayment updateManyAndReturn
   */
  export type SplitPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * The data used to update SplitPayments.
     */
    data: XOR<SplitPaymentUpdateManyMutationInput, SplitPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SplitPayments to update
     */
    where?: SplitPaymentWhereInput
    /**
     * Limit how many SplitPayments to update.
     */
    limit?: number
  }

  /**
   * SplitPayment upsert
   */
  export type SplitPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * The filter to search for the SplitPayment to update in case it exists.
     */
    where: SplitPaymentWhereUniqueInput
    /**
     * In case the SplitPayment found by the `where` argument doesn't exist, create a new SplitPayment with this data.
     */
    create: XOR<SplitPaymentCreateInput, SplitPaymentUncheckedCreateInput>
    /**
     * In case the SplitPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SplitPaymentUpdateInput, SplitPaymentUncheckedUpdateInput>
  }

  /**
   * SplitPayment delete
   */
  export type SplitPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
    /**
     * Filter which SplitPayment to delete.
     */
    where: SplitPaymentWhereUniqueInput
  }

  /**
   * SplitPayment deleteMany
   */
  export type SplitPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SplitPayments to delete
     */
    where?: SplitPaymentWhereInput
    /**
     * Limit how many SplitPayments to delete.
     */
    limit?: number
  }

  /**
   * SplitPayment without action
   */
  export type SplitPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SplitPayment
     */
    select?: SplitPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SplitPayment
     */
    omit?: SplitPaymentOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    phone: 'phone',
    password: 'password',
    googleId: 'googleId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    accountNumber: 'accountNumber',
    verified: 'verified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const BillScalarFieldEnum: {
    id: 'id',
    billName: 'billName',
    description: 'description',
    type: 'type',
    note: 'note',
    amount: 'amount',
    priority: 'priority',
    status: 'status',
    category: 'category',
    dueDate: 'dueDate',
    paymentMethod: 'paymentMethod',
    userId: 'userId',
    providerId: 'providerId',
    requestId: 'requestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    status: 'status',
    billId: 'billId',
    reference: 'reference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    userId: 'userId',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const RequestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    notes: 'notes',
    status: 'status',
    feedback: 'feedback',
    publicLinkId: 'publicLinkId',
    requesterId: 'requesterId',
    supporterId: 'supporterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    email: 'email',
    amount: 'amount',
    reference: 'reference',
    status: 'status',
    splitCode: 'splitCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AirtimeTransactionScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    amount: 'amount',
    network: 'network',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type AirtimeTransactionScalarFieldEnum = (typeof AirtimeTransactionScalarFieldEnum)[keyof typeof AirtimeTransactionScalarFieldEnum]


  export const SubaccountScalarFieldEnum: {
    id: 'id',
    businessName: 'businessName',
    bankCode: 'bankCode',
    accountNumber: 'accountNumber',
    percentageCharge: 'percentageCharge',
    subaccountCode: 'subaccountCode',
    createdAt: 'createdAt',
    lastPaidAt: 'lastPaidAt'
  };

  export type SubaccountScalarFieldEnum = (typeof SubaccountScalarFieldEnum)[keyof typeof SubaccountScalarFieldEnum]


  export const SubaccountSplitScalarFieldEnum: {
    id: 'id',
    subaccountId: 'subaccountId',
    splitGroupId: 'splitGroupId',
    share: 'share'
  };

  export type SubaccountSplitScalarFieldEnum = (typeof SubaccountSplitScalarFieldEnum)[keyof typeof SubaccountSplitScalarFieldEnum]


  export const SplitGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    currency: 'currency',
    splitCode: 'splitCode',
    bearerType: 'bearerType',
    bearerSubaccount: 'bearerSubaccount',
    createdAt: 'createdAt'
  };

  export type SplitGroupScalarFieldEnum = (typeof SplitGroupScalarFieldEnum)[keyof typeof SplitGroupScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    name: 'name',
    accountNumber: 'accountNumber',
    bankName: 'bankName',
    bankCode: 'bankCode',
    recipientCode: 'recipientCode',
    amount: 'amount',
    reason: 'reason',
    reference: 'reference',
    status: 'status',
    batchId: 'batchId',
    createdAt: 'createdAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    status: 'status'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const BulkTransferScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    status: 'status',
    reference: 'reference',
    reason: 'reason',
    recipientCode: 'recipientCode',
    transferCode: 'transferCode',
    createdAt: 'createdAt',
    batchId: 'batchId'
  };

  export type BulkTransferScalarFieldEnum = (typeof BulkTransferScalarFieldEnum)[keyof typeof BulkTransferScalarFieldEnum]


  export const RecipientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    accountNumber: 'accountNumber',
    bankCode: 'bankCode',
    recipientCode: 'recipientCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecipientScalarFieldEnum = (typeof RecipientScalarFieldEnum)[keyof typeof RecipientScalarFieldEnum]


  export const CryptoWalletScalarFieldEnum: {
    id: 'id',
    address: 'address',
    userId: 'userId',
    u2kBalance: 'u2kBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoWalletScalarFieldEnum = (typeof CryptoWalletScalarFieldEnum)[keyof typeof CryptoWalletScalarFieldEnum]


  export const BlockchainRequestScalarFieldEnum: {
    id: 'id',
    billId: 'billId',
    blockchainBillId: 'blockchainBillId',
    transactionHash: 'transactionHash',
    status: 'status',
    amount: 'amount',
    cryptoAmount: 'cryptoAmount',
    paymentType: 'paymentType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockchainRequestScalarFieldEnum = (typeof BlockchainRequestScalarFieldEnum)[keyof typeof BlockchainRequestScalarFieldEnum]


  export const BlockchainTransactionScalarFieldEnum: {
    id: 'id',
    transactionHash: 'transactionHash',
    from: 'from',
    to: 'to',
    amount: 'amount',
    status: 'status',
    cryptoWalletId: 'cryptoWalletId',
    blockchainRequestId: 'blockchainRequestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockchainTransactionScalarFieldEnum = (typeof BlockchainTransactionScalarFieldEnum)[keyof typeof BlockchainTransactionScalarFieldEnum]


  export const SplitPaymentScalarFieldEnum: {
    id: 'id',
    email: 'email',
    amount: 'amount',
    splitCode: 'splitCode',
    reference: 'reference',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type SplitPaymentScalarFieldEnum = (typeof SplitPaymentScalarFieldEnum)[keyof typeof SplitPaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'BillStatus'
   */
  export type EnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus'>
    


  /**
   * Reference to a field of type 'BillStatus[]'
   */
  export type ListEnumBillStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillStatus[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BlockchainTxStatus'
   */
  export type EnumBlockchainTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlockchainTxStatus'>
    


  /**
   * Reference to a field of type 'BlockchainTxStatus[]'
   */
  export type ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlockchainTxStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bills?: BillListRelationFilter
    requests?: RequestListRelationFilter
    supports?: RequestListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    cryptoWallet?: XOR<CryptoWalletNullableScalarRelationFilter, CryptoWalletWhereInput> | null
    sponsoredBills?: BillListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bills?: BillOrderByRelationAggregateInput
    requests?: RequestOrderByRelationAggregateInput
    supports?: RequestOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
    cryptoWallet?: CryptoWalletOrderByWithRelationInput
    sponsoredBills?: BillOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bills?: BillListRelationFilter
    requests?: RequestListRelationFilter
    supports?: RequestListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    cryptoWallet?: XOR<CryptoWalletNullableScalarRelationFilter, CryptoWalletWhereInput> | null
    sponsoredBills?: BillListRelationFilter
  }, "id" | "email" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: StringFilter<"Provider"> | string
    name?: StringFilter<"Provider"> | string
    email?: StringNullableFilter<"Provider"> | string | null
    accountNumber?: StringNullableFilter<"Provider"> | string | null
    verified?: BoolFilter<"Provider"> | boolean
    createdAt?: DateTimeFilter<"Provider"> | Date | string
    updatedAt?: DateTimeFilter<"Provider"> | Date | string
    bills?: BillListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bills?: BillOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    email?: string
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    accountNumber?: StringNullableFilter<"Provider"> | string | null
    verified?: BoolFilter<"Provider"> | boolean
    createdAt?: DateTimeFilter<"Provider"> | Date | string
    updatedAt?: DateTimeFilter<"Provider"> | Date | string
    bills?: BillListRelationFilter
  }, "id" | "name" | "email">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Provider"> | string
    name?: StringWithAggregatesFilter<"Provider"> | string
    email?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    verified?: BoolWithAggregatesFilter<"Provider"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
  }

  export type BillWhereInput = {
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    id?: StringFilter<"Bill"> | string
    billName?: StringFilter<"Bill"> | string
    description?: StringFilter<"Bill"> | string
    type?: StringFilter<"Bill"> | string
    note?: StringNullableFilter<"Bill"> | string | null
    amount?: FloatFilter<"Bill"> | number
    priority?: EnumPriorityFilter<"Bill"> | $Enums.Priority
    status?: EnumBillStatusFilter<"Bill"> | $Enums.BillStatus
    category?: StringNullableFilter<"Bill"> | string | null
    dueDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Bill"> | string | null
    userId?: StringFilter<"Bill"> | string
    providerId?: StringNullableFilter<"Bill"> | string | null
    requestId?: StringNullableFilter<"Bill"> | string | null
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
    request?: XOR<RequestNullableScalarRelationFilter, RequestWhereInput> | null
    sponsors?: UserListRelationFilter
    transactions?: TransactionListRelationFilter
    blockchainRequest?: XOR<BlockchainRequestNullableScalarRelationFilter, BlockchainRequestWhereInput> | null
  }

  export type BillOrderByWithRelationInput = {
    id?: SortOrder
    billName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    amount?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    userId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
    request?: RequestOrderByWithRelationInput
    sponsors?: UserOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    blockchainRequest?: BlockchainRequestOrderByWithRelationInput
  }

  export type BillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillWhereInput | BillWhereInput[]
    OR?: BillWhereInput[]
    NOT?: BillWhereInput | BillWhereInput[]
    billName?: StringFilter<"Bill"> | string
    description?: StringFilter<"Bill"> | string
    type?: StringFilter<"Bill"> | string
    note?: StringNullableFilter<"Bill"> | string | null
    amount?: FloatFilter<"Bill"> | number
    priority?: EnumPriorityFilter<"Bill"> | $Enums.Priority
    status?: EnumBillStatusFilter<"Bill"> | $Enums.BillStatus
    category?: StringNullableFilter<"Bill"> | string | null
    dueDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Bill"> | string | null
    userId?: StringFilter<"Bill"> | string
    providerId?: StringNullableFilter<"Bill"> | string | null
    requestId?: StringNullableFilter<"Bill"> | string | null
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
    request?: XOR<RequestNullableScalarRelationFilter, RequestWhereInput> | null
    sponsors?: UserListRelationFilter
    transactions?: TransactionListRelationFilter
    blockchainRequest?: XOR<BlockchainRequestNullableScalarRelationFilter, BlockchainRequestWhereInput> | null
  }, "id">

  export type BillOrderByWithAggregationInput = {
    id?: SortOrder
    billName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    amount?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    userId?: SortOrder
    providerId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillCountOrderByAggregateInput
    _avg?: BillAvgOrderByAggregateInput
    _max?: BillMaxOrderByAggregateInput
    _min?: BillMinOrderByAggregateInput
    _sum?: BillSumOrderByAggregateInput
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    OR?: BillScalarWhereWithAggregatesInput[]
    NOT?: BillScalarWhereWithAggregatesInput | BillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bill"> | string
    billName?: StringWithAggregatesFilter<"Bill"> | string
    description?: StringWithAggregatesFilter<"Bill"> | string
    type?: StringWithAggregatesFilter<"Bill"> | string
    note?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    amount?: FloatWithAggregatesFilter<"Bill"> | number
    priority?: EnumPriorityWithAggregatesFilter<"Bill"> | $Enums.Priority
    status?: EnumBillStatusWithAggregatesFilter<"Bill"> | $Enums.BillStatus
    category?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Bill"> | Date | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    userId?: StringWithAggregatesFilter<"Bill"> | string
    providerId?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"Bill"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bill"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    billId?: StringFilter<"Transaction"> | string
    reference?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    billId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bill?: BillOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    billId?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
  }, "id" | "reference">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    billId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    status?: StringWithAggregatesFilter<"Transaction"> | string
    billId?: StringWithAggregatesFilter<"Transaction"> | string
    reference?: StringWithAggregatesFilter<"Transaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    balance?: FloatFilter<"Wallet"> | number
    userId?: StringFilter<"Wallet"> | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balance?: FloatFilter<"Wallet"> | number
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: FloatWithAggregatesFilter<"Wallet"> | number
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type RequestWhereInput = {
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    id?: StringFilter<"Request"> | string
    name?: StringFilter<"Request"> | string
    notes?: StringNullableFilter<"Request"> | string | null
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    feedback?: StringNullableFilter<"Request"> | string | null
    publicLinkId?: StringFilter<"Request"> | string
    requesterId?: StringFilter<"Request"> | string
    supporterId?: StringNullableFilter<"Request"> | string | null
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    supporter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bills?: BillListRelationFilter
  }

  export type RequestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    publicLinkId?: SortOrder
    requesterId?: SortOrder
    supporterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requester?: UserOrderByWithRelationInput
    supporter?: UserOrderByWithRelationInput
    bills?: BillOrderByRelationAggregateInput
  }

  export type RequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publicLinkId?: string
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    name?: StringFilter<"Request"> | string
    notes?: StringNullableFilter<"Request"> | string | null
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    feedback?: StringNullableFilter<"Request"> | string | null
    requesterId?: StringFilter<"Request"> | string
    supporterId?: StringNullableFilter<"Request"> | string | null
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    supporter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bills?: BillListRelationFilter
  }, "id" | "publicLinkId">

  export type RequestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    publicLinkId?: SortOrder
    requesterId?: SortOrder
    supporterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestCountOrderByAggregateInput
    _max?: RequestMaxOrderByAggregateInput
    _min?: RequestMinOrderByAggregateInput
  }

  export type RequestScalarWhereWithAggregatesInput = {
    AND?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    OR?: RequestScalarWhereWithAggregatesInput[]
    NOT?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Request"> | string
    name?: StringWithAggregatesFilter<"Request"> | string
    notes?: StringNullableWithAggregatesFilter<"Request"> | string | null
    status?: EnumRequestStatusWithAggregatesFilter<"Request"> | $Enums.RequestStatus
    feedback?: StringNullableWithAggregatesFilter<"Request"> | string | null
    publicLinkId?: StringWithAggregatesFilter<"Request"> | string
    requesterId?: StringWithAggregatesFilter<"Request"> | string
    supporterId?: StringNullableWithAggregatesFilter<"Request"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    email?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    reference?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    splitCode?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    splitCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    email?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    splitCode?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }, "id" | "reference">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    splitCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    email?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    reference?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    splitCode?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type AirtimeTransactionWhereInput = {
    AND?: AirtimeTransactionWhereInput | AirtimeTransactionWhereInput[]
    OR?: AirtimeTransactionWhereInput[]
    NOT?: AirtimeTransactionWhereInput | AirtimeTransactionWhereInput[]
    id?: StringFilter<"AirtimeTransaction"> | string
    phone?: StringFilter<"AirtimeTransaction"> | string
    amount?: FloatFilter<"AirtimeTransaction"> | number
    network?: StringFilter<"AirtimeTransaction"> | string
    reference?: StringFilter<"AirtimeTransaction"> | string
    createdAt?: DateTimeFilter<"AirtimeTransaction"> | Date | string
  }

  export type AirtimeTransactionOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    amount?: SortOrder
    network?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type AirtimeTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: AirtimeTransactionWhereInput | AirtimeTransactionWhereInput[]
    OR?: AirtimeTransactionWhereInput[]
    NOT?: AirtimeTransactionWhereInput | AirtimeTransactionWhereInput[]
    phone?: StringFilter<"AirtimeTransaction"> | string
    amount?: FloatFilter<"AirtimeTransaction"> | number
    network?: StringFilter<"AirtimeTransaction"> | string
    createdAt?: DateTimeFilter<"AirtimeTransaction"> | Date | string
  }, "id" | "reference">

  export type AirtimeTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    amount?: SortOrder
    network?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    _count?: AirtimeTransactionCountOrderByAggregateInput
    _avg?: AirtimeTransactionAvgOrderByAggregateInput
    _max?: AirtimeTransactionMaxOrderByAggregateInput
    _min?: AirtimeTransactionMinOrderByAggregateInput
    _sum?: AirtimeTransactionSumOrderByAggregateInput
  }

  export type AirtimeTransactionScalarWhereWithAggregatesInput = {
    AND?: AirtimeTransactionScalarWhereWithAggregatesInput | AirtimeTransactionScalarWhereWithAggregatesInput[]
    OR?: AirtimeTransactionScalarWhereWithAggregatesInput[]
    NOT?: AirtimeTransactionScalarWhereWithAggregatesInput | AirtimeTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AirtimeTransaction"> | string
    phone?: StringWithAggregatesFilter<"AirtimeTransaction"> | string
    amount?: FloatWithAggregatesFilter<"AirtimeTransaction"> | number
    network?: StringWithAggregatesFilter<"AirtimeTransaction"> | string
    reference?: StringWithAggregatesFilter<"AirtimeTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AirtimeTransaction"> | Date | string
  }

  export type SubaccountWhereInput = {
    AND?: SubaccountWhereInput | SubaccountWhereInput[]
    OR?: SubaccountWhereInput[]
    NOT?: SubaccountWhereInput | SubaccountWhereInput[]
    id?: StringFilter<"Subaccount"> | string
    businessName?: StringFilter<"Subaccount"> | string
    bankCode?: StringFilter<"Subaccount"> | string
    accountNumber?: StringFilter<"Subaccount"> | string
    percentageCharge?: FloatFilter<"Subaccount"> | number
    subaccountCode?: StringFilter<"Subaccount"> | string
    createdAt?: DateTimeFilter<"Subaccount"> | Date | string
    lastPaidAt?: DateTimeNullableFilter<"Subaccount"> | Date | string | null
    subaccountSplits?: SubaccountSplitListRelationFilter
  }

  export type SubaccountOrderByWithRelationInput = {
    id?: SortOrder
    businessName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    percentageCharge?: SortOrder
    subaccountCode?: SortOrder
    createdAt?: SortOrder
    lastPaidAt?: SortOrderInput | SortOrder
    subaccountSplits?: SubaccountSplitOrderByRelationAggregateInput
  }

  export type SubaccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subaccountCode?: string
    AND?: SubaccountWhereInput | SubaccountWhereInput[]
    OR?: SubaccountWhereInput[]
    NOT?: SubaccountWhereInput | SubaccountWhereInput[]
    businessName?: StringFilter<"Subaccount"> | string
    bankCode?: StringFilter<"Subaccount"> | string
    accountNumber?: StringFilter<"Subaccount"> | string
    percentageCharge?: FloatFilter<"Subaccount"> | number
    createdAt?: DateTimeFilter<"Subaccount"> | Date | string
    lastPaidAt?: DateTimeNullableFilter<"Subaccount"> | Date | string | null
    subaccountSplits?: SubaccountSplitListRelationFilter
  }, "id" | "subaccountCode">

  export type SubaccountOrderByWithAggregationInput = {
    id?: SortOrder
    businessName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    percentageCharge?: SortOrder
    subaccountCode?: SortOrder
    createdAt?: SortOrder
    lastPaidAt?: SortOrderInput | SortOrder
    _count?: SubaccountCountOrderByAggregateInput
    _avg?: SubaccountAvgOrderByAggregateInput
    _max?: SubaccountMaxOrderByAggregateInput
    _min?: SubaccountMinOrderByAggregateInput
    _sum?: SubaccountSumOrderByAggregateInput
  }

  export type SubaccountScalarWhereWithAggregatesInput = {
    AND?: SubaccountScalarWhereWithAggregatesInput | SubaccountScalarWhereWithAggregatesInput[]
    OR?: SubaccountScalarWhereWithAggregatesInput[]
    NOT?: SubaccountScalarWhereWithAggregatesInput | SubaccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subaccount"> | string
    businessName?: StringWithAggregatesFilter<"Subaccount"> | string
    bankCode?: StringWithAggregatesFilter<"Subaccount"> | string
    accountNumber?: StringWithAggregatesFilter<"Subaccount"> | string
    percentageCharge?: FloatWithAggregatesFilter<"Subaccount"> | number
    subaccountCode?: StringWithAggregatesFilter<"Subaccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subaccount"> | Date | string
    lastPaidAt?: DateTimeNullableWithAggregatesFilter<"Subaccount"> | Date | string | null
  }

  export type SubaccountSplitWhereInput = {
    AND?: SubaccountSplitWhereInput | SubaccountSplitWhereInput[]
    OR?: SubaccountSplitWhereInput[]
    NOT?: SubaccountSplitWhereInput | SubaccountSplitWhereInput[]
    id?: StringFilter<"SubaccountSplit"> | string
    subaccountId?: StringFilter<"SubaccountSplit"> | string
    splitGroupId?: StringFilter<"SubaccountSplit"> | string
    share?: FloatFilter<"SubaccountSplit"> | number
    subaccount?: XOR<SubaccountScalarRelationFilter, SubaccountWhereInput>
    splitGroup?: XOR<SplitGroupScalarRelationFilter, SplitGroupWhereInput>
  }

  export type SubaccountSplitOrderByWithRelationInput = {
    id?: SortOrder
    subaccountId?: SortOrder
    splitGroupId?: SortOrder
    share?: SortOrder
    subaccount?: SubaccountOrderByWithRelationInput
    splitGroup?: SplitGroupOrderByWithRelationInput
  }

  export type SubaccountSplitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubaccountSplitWhereInput | SubaccountSplitWhereInput[]
    OR?: SubaccountSplitWhereInput[]
    NOT?: SubaccountSplitWhereInput | SubaccountSplitWhereInput[]
    subaccountId?: StringFilter<"SubaccountSplit"> | string
    splitGroupId?: StringFilter<"SubaccountSplit"> | string
    share?: FloatFilter<"SubaccountSplit"> | number
    subaccount?: XOR<SubaccountScalarRelationFilter, SubaccountWhereInput>
    splitGroup?: XOR<SplitGroupScalarRelationFilter, SplitGroupWhereInput>
  }, "id">

  export type SubaccountSplitOrderByWithAggregationInput = {
    id?: SortOrder
    subaccountId?: SortOrder
    splitGroupId?: SortOrder
    share?: SortOrder
    _count?: SubaccountSplitCountOrderByAggregateInput
    _avg?: SubaccountSplitAvgOrderByAggregateInput
    _max?: SubaccountSplitMaxOrderByAggregateInput
    _min?: SubaccountSplitMinOrderByAggregateInput
    _sum?: SubaccountSplitSumOrderByAggregateInput
  }

  export type SubaccountSplitScalarWhereWithAggregatesInput = {
    AND?: SubaccountSplitScalarWhereWithAggregatesInput | SubaccountSplitScalarWhereWithAggregatesInput[]
    OR?: SubaccountSplitScalarWhereWithAggregatesInput[]
    NOT?: SubaccountSplitScalarWhereWithAggregatesInput | SubaccountSplitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubaccountSplit"> | string
    subaccountId?: StringWithAggregatesFilter<"SubaccountSplit"> | string
    splitGroupId?: StringWithAggregatesFilter<"SubaccountSplit"> | string
    share?: FloatWithAggregatesFilter<"SubaccountSplit"> | number
  }

  export type SplitGroupWhereInput = {
    AND?: SplitGroupWhereInput | SplitGroupWhereInput[]
    OR?: SplitGroupWhereInput[]
    NOT?: SplitGroupWhereInput | SplitGroupWhereInput[]
    id?: StringFilter<"SplitGroup"> | string
    name?: StringFilter<"SplitGroup"> | string
    type?: StringFilter<"SplitGroup"> | string
    currency?: StringFilter<"SplitGroup"> | string
    splitCode?: StringFilter<"SplitGroup"> | string
    bearerType?: StringNullableFilter<"SplitGroup"> | string | null
    bearerSubaccount?: StringFilter<"SplitGroup"> | string
    createdAt?: DateTimeFilter<"SplitGroup"> | Date | string
    subaccounts?: SubaccountSplitListRelationFilter
  }

  export type SplitGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    splitCode?: SortOrder
    bearerType?: SortOrderInput | SortOrder
    bearerSubaccount?: SortOrder
    createdAt?: SortOrder
    subaccounts?: SubaccountSplitOrderByRelationAggregateInput
  }

  export type SplitGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    splitCode?: string
    AND?: SplitGroupWhereInput | SplitGroupWhereInput[]
    OR?: SplitGroupWhereInput[]
    NOT?: SplitGroupWhereInput | SplitGroupWhereInput[]
    name?: StringFilter<"SplitGroup"> | string
    type?: StringFilter<"SplitGroup"> | string
    currency?: StringFilter<"SplitGroup"> | string
    bearerType?: StringNullableFilter<"SplitGroup"> | string | null
    bearerSubaccount?: StringFilter<"SplitGroup"> | string
    createdAt?: DateTimeFilter<"SplitGroup"> | Date | string
    subaccounts?: SubaccountSplitListRelationFilter
  }, "id" | "splitCode">

  export type SplitGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    splitCode?: SortOrder
    bearerType?: SortOrderInput | SortOrder
    bearerSubaccount?: SortOrder
    createdAt?: SortOrder
    _count?: SplitGroupCountOrderByAggregateInput
    _max?: SplitGroupMaxOrderByAggregateInput
    _min?: SplitGroupMinOrderByAggregateInput
  }

  export type SplitGroupScalarWhereWithAggregatesInput = {
    AND?: SplitGroupScalarWhereWithAggregatesInput | SplitGroupScalarWhereWithAggregatesInput[]
    OR?: SplitGroupScalarWhereWithAggregatesInput[]
    NOT?: SplitGroupScalarWhereWithAggregatesInput | SplitGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SplitGroup"> | string
    name?: StringWithAggregatesFilter<"SplitGroup"> | string
    type?: StringWithAggregatesFilter<"SplitGroup"> | string
    currency?: StringWithAggregatesFilter<"SplitGroup"> | string
    splitCode?: StringWithAggregatesFilter<"SplitGroup"> | string
    bearerType?: StringNullableWithAggregatesFilter<"SplitGroup"> | string | null
    bearerSubaccount?: StringWithAggregatesFilter<"SplitGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SplitGroup"> | Date | string
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    name?: StringFilter<"Transfer"> | string
    accountNumber?: StringFilter<"Transfer"> | string
    bankName?: StringFilter<"Transfer"> | string
    bankCode?: StringFilter<"Transfer"> | string
    recipientCode?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    reason?: StringFilter<"Transfer"> | string
    reference?: StringNullableFilter<"Transfer"> | string | null
    status?: StringFilter<"Transfer"> | string
    batchId?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    batchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    batch?: BatchOrderByWithRelationInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    name?: StringFilter<"Transfer"> | string
    accountNumber?: StringFilter<"Transfer"> | string
    bankName?: StringFilter<"Transfer"> | string
    bankCode?: StringFilter<"Transfer"> | string
    recipientCode?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    reason?: StringFilter<"Transfer"> | string
    reference?: StringNullableFilter<"Transfer"> | string | null
    status?: StringFilter<"Transfer"> | string
    batchId?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
  }, "id">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    batchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    name?: StringWithAggregatesFilter<"Transfer"> | string
    accountNumber?: StringWithAggregatesFilter<"Transfer"> | string
    bankName?: StringWithAggregatesFilter<"Transfer"> | string
    bankCode?: StringWithAggregatesFilter<"Transfer"> | string
    recipientCode?: StringWithAggregatesFilter<"Transfer"> | string
    amount?: FloatWithAggregatesFilter<"Transfer"> | number
    reason?: StringWithAggregatesFilter<"Transfer"> | string
    reference?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    status?: StringWithAggregatesFilter<"Transfer"> | string
    batchId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: StringFilter<"Batch"> | string
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    status?: StringFilter<"Batch"> | string
    transfers?: TransferListRelationFilter
    bulkTransfers?: BulkTransferListRelationFilter
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    transfers?: TransferOrderByRelationAggregateInput
    bulkTransfers?: BulkTransferOrderByRelationAggregateInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    status?: StringFilter<"Batch"> | string
    transfers?: TransferListRelationFilter
    bulkTransfers?: BulkTransferListRelationFilter
  }, "id">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Batch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    status?: StringWithAggregatesFilter<"Batch"> | string
  }

  export type BulkTransferWhereInput = {
    AND?: BulkTransferWhereInput | BulkTransferWhereInput[]
    OR?: BulkTransferWhereInput[]
    NOT?: BulkTransferWhereInput | BulkTransferWhereInput[]
    id?: StringFilter<"BulkTransfer"> | string
    amount?: IntFilter<"BulkTransfer"> | number
    status?: StringFilter<"BulkTransfer"> | string
    reference?: StringFilter<"BulkTransfer"> | string
    reason?: StringFilter<"BulkTransfer"> | string
    recipientCode?: StringFilter<"BulkTransfer"> | string
    transferCode?: StringFilter<"BulkTransfer"> | string
    createdAt?: DateTimeFilter<"BulkTransfer"> | Date | string
    batchId?: StringFilter<"BulkTransfer"> | string
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
  }

  export type BulkTransferOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    recipientCode?: SortOrder
    transferCode?: SortOrder
    createdAt?: SortOrder
    batchId?: SortOrder
    batch?: BatchOrderByWithRelationInput
  }

  export type BulkTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BulkTransferWhereInput | BulkTransferWhereInput[]
    OR?: BulkTransferWhereInput[]
    NOT?: BulkTransferWhereInput | BulkTransferWhereInput[]
    amount?: IntFilter<"BulkTransfer"> | number
    status?: StringFilter<"BulkTransfer"> | string
    reference?: StringFilter<"BulkTransfer"> | string
    reason?: StringFilter<"BulkTransfer"> | string
    recipientCode?: StringFilter<"BulkTransfer"> | string
    transferCode?: StringFilter<"BulkTransfer"> | string
    createdAt?: DateTimeFilter<"BulkTransfer"> | Date | string
    batchId?: StringFilter<"BulkTransfer"> | string
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
  }, "id">

  export type BulkTransferOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    recipientCode?: SortOrder
    transferCode?: SortOrder
    createdAt?: SortOrder
    batchId?: SortOrder
    _count?: BulkTransferCountOrderByAggregateInput
    _avg?: BulkTransferAvgOrderByAggregateInput
    _max?: BulkTransferMaxOrderByAggregateInput
    _min?: BulkTransferMinOrderByAggregateInput
    _sum?: BulkTransferSumOrderByAggregateInput
  }

  export type BulkTransferScalarWhereWithAggregatesInput = {
    AND?: BulkTransferScalarWhereWithAggregatesInput | BulkTransferScalarWhereWithAggregatesInput[]
    OR?: BulkTransferScalarWhereWithAggregatesInput[]
    NOT?: BulkTransferScalarWhereWithAggregatesInput | BulkTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BulkTransfer"> | string
    amount?: IntWithAggregatesFilter<"BulkTransfer"> | number
    status?: StringWithAggregatesFilter<"BulkTransfer"> | string
    reference?: StringWithAggregatesFilter<"BulkTransfer"> | string
    reason?: StringWithAggregatesFilter<"BulkTransfer"> | string
    recipientCode?: StringWithAggregatesFilter<"BulkTransfer"> | string
    transferCode?: StringWithAggregatesFilter<"BulkTransfer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BulkTransfer"> | Date | string
    batchId?: StringWithAggregatesFilter<"BulkTransfer"> | string
  }

  export type RecipientWhereInput = {
    AND?: RecipientWhereInput | RecipientWhereInput[]
    OR?: RecipientWhereInput[]
    NOT?: RecipientWhereInput | RecipientWhereInput[]
    id?: StringFilter<"Recipient"> | string
    name?: StringFilter<"Recipient"> | string
    accountNumber?: StringFilter<"Recipient"> | string
    bankCode?: StringFilter<"Recipient"> | string
    recipientCode?: StringFilter<"Recipient"> | string
    createdAt?: DateTimeFilter<"Recipient"> | Date | string
    updatedAt?: DateTimeFilter<"Recipient"> | Date | string
  }

  export type RecipientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipientCode?: string
    AND?: RecipientWhereInput | RecipientWhereInput[]
    OR?: RecipientWhereInput[]
    NOT?: RecipientWhereInput | RecipientWhereInput[]
    name?: StringFilter<"Recipient"> | string
    accountNumber?: StringFilter<"Recipient"> | string
    bankCode?: StringFilter<"Recipient"> | string
    createdAt?: DateTimeFilter<"Recipient"> | Date | string
    updatedAt?: DateTimeFilter<"Recipient"> | Date | string
  }, "id" | "recipientCode">

  export type RecipientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecipientCountOrderByAggregateInput
    _max?: RecipientMaxOrderByAggregateInput
    _min?: RecipientMinOrderByAggregateInput
  }

  export type RecipientScalarWhereWithAggregatesInput = {
    AND?: RecipientScalarWhereWithAggregatesInput | RecipientScalarWhereWithAggregatesInput[]
    OR?: RecipientScalarWhereWithAggregatesInput[]
    NOT?: RecipientScalarWhereWithAggregatesInput | RecipientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipient"> | string
    name?: StringWithAggregatesFilter<"Recipient"> | string
    accountNumber?: StringWithAggregatesFilter<"Recipient"> | string
    bankCode?: StringWithAggregatesFilter<"Recipient"> | string
    recipientCode?: StringWithAggregatesFilter<"Recipient"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Recipient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipient"> | Date | string
  }

  export type CryptoWalletWhereInput = {
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    id?: StringFilter<"CryptoWallet"> | string
    address?: StringFilter<"CryptoWallet"> | string
    userId?: StringFilter<"CryptoWallet"> | string
    u2kBalance?: FloatFilter<"CryptoWallet"> | number
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: BlockchainTransactionListRelationFilter
  }

  export type CryptoWalletOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    userId?: SortOrder
    u2kBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: BlockchainTransactionOrderByRelationAggregateInput
  }

  export type CryptoWalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    address?: string
    userId?: string
    AND?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    OR?: CryptoWalletWhereInput[]
    NOT?: CryptoWalletWhereInput | CryptoWalletWhereInput[]
    u2kBalance?: FloatFilter<"CryptoWallet"> | number
    createdAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoWallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    transactions?: BlockchainTransactionListRelationFilter
  }, "id" | "address" | "userId">

  export type CryptoWalletOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    userId?: SortOrder
    u2kBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoWalletCountOrderByAggregateInput
    _avg?: CryptoWalletAvgOrderByAggregateInput
    _max?: CryptoWalletMaxOrderByAggregateInput
    _min?: CryptoWalletMinOrderByAggregateInput
    _sum?: CryptoWalletSumOrderByAggregateInput
  }

  export type CryptoWalletScalarWhereWithAggregatesInput = {
    AND?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    OR?: CryptoWalletScalarWhereWithAggregatesInput[]
    NOT?: CryptoWalletScalarWhereWithAggregatesInput | CryptoWalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CryptoWallet"> | string
    address?: StringWithAggregatesFilter<"CryptoWallet"> | string
    userId?: StringWithAggregatesFilter<"CryptoWallet"> | string
    u2kBalance?: FloatWithAggregatesFilter<"CryptoWallet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoWallet"> | Date | string
  }

  export type BlockchainRequestWhereInput = {
    AND?: BlockchainRequestWhereInput | BlockchainRequestWhereInput[]
    OR?: BlockchainRequestWhereInput[]
    NOT?: BlockchainRequestWhereInput | BlockchainRequestWhereInput[]
    id?: StringFilter<"BlockchainRequest"> | string
    billId?: StringFilter<"BlockchainRequest"> | string
    blockchainBillId?: StringNullableFilter<"BlockchainRequest"> | string | null
    transactionHash?: StringNullableFilter<"BlockchainRequest"> | string | null
    status?: EnumBlockchainTxStatusFilter<"BlockchainRequest"> | $Enums.BlockchainTxStatus
    amount?: FloatFilter<"BlockchainRequest"> | number
    cryptoAmount?: FloatFilter<"BlockchainRequest"> | number
    paymentType?: EnumPaymentTypeFilter<"BlockchainRequest"> | $Enums.PaymentType
    createdAt?: DateTimeFilter<"BlockchainRequest"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainRequest"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    transactions?: BlockchainTransactionListRelationFilter
  }

  export type BlockchainRequestOrderByWithRelationInput = {
    id?: SortOrder
    billId?: SortOrder
    blockchainBillId?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    status?: SortOrder
    amount?: SortOrder
    cryptoAmount?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bill?: BillOrderByWithRelationInput
    transactions?: BlockchainTransactionOrderByRelationAggregateInput
  }

  export type BlockchainRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    billId?: string
    transactionHash?: string
    AND?: BlockchainRequestWhereInput | BlockchainRequestWhereInput[]
    OR?: BlockchainRequestWhereInput[]
    NOT?: BlockchainRequestWhereInput | BlockchainRequestWhereInput[]
    blockchainBillId?: StringNullableFilter<"BlockchainRequest"> | string | null
    status?: EnumBlockchainTxStatusFilter<"BlockchainRequest"> | $Enums.BlockchainTxStatus
    amount?: FloatFilter<"BlockchainRequest"> | number
    cryptoAmount?: FloatFilter<"BlockchainRequest"> | number
    paymentType?: EnumPaymentTypeFilter<"BlockchainRequest"> | $Enums.PaymentType
    createdAt?: DateTimeFilter<"BlockchainRequest"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainRequest"> | Date | string
    bill?: XOR<BillScalarRelationFilter, BillWhereInput>
    transactions?: BlockchainTransactionListRelationFilter
  }, "id" | "billId" | "transactionHash">

  export type BlockchainRequestOrderByWithAggregationInput = {
    id?: SortOrder
    billId?: SortOrder
    blockchainBillId?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    status?: SortOrder
    amount?: SortOrder
    cryptoAmount?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlockchainRequestCountOrderByAggregateInput
    _avg?: BlockchainRequestAvgOrderByAggregateInput
    _max?: BlockchainRequestMaxOrderByAggregateInput
    _min?: BlockchainRequestMinOrderByAggregateInput
    _sum?: BlockchainRequestSumOrderByAggregateInput
  }

  export type BlockchainRequestScalarWhereWithAggregatesInput = {
    AND?: BlockchainRequestScalarWhereWithAggregatesInput | BlockchainRequestScalarWhereWithAggregatesInput[]
    OR?: BlockchainRequestScalarWhereWithAggregatesInput[]
    NOT?: BlockchainRequestScalarWhereWithAggregatesInput | BlockchainRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockchainRequest"> | string
    billId?: StringWithAggregatesFilter<"BlockchainRequest"> | string
    blockchainBillId?: StringNullableWithAggregatesFilter<"BlockchainRequest"> | string | null
    transactionHash?: StringNullableWithAggregatesFilter<"BlockchainRequest"> | string | null
    status?: EnumBlockchainTxStatusWithAggregatesFilter<"BlockchainRequest"> | $Enums.BlockchainTxStatus
    amount?: FloatWithAggregatesFilter<"BlockchainRequest"> | number
    cryptoAmount?: FloatWithAggregatesFilter<"BlockchainRequest"> | number
    paymentType?: EnumPaymentTypeWithAggregatesFilter<"BlockchainRequest"> | $Enums.PaymentType
    createdAt?: DateTimeWithAggregatesFilter<"BlockchainRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockchainRequest"> | Date | string
  }

  export type BlockchainTransactionWhereInput = {
    AND?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    OR?: BlockchainTransactionWhereInput[]
    NOT?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    id?: StringFilter<"BlockchainTransaction"> | string
    transactionHash?: StringFilter<"BlockchainTransaction"> | string
    from?: StringFilter<"BlockchainTransaction"> | string
    to?: StringFilter<"BlockchainTransaction"> | string
    amount?: FloatFilter<"BlockchainTransaction"> | number
    status?: EnumBlockchainTxStatusFilter<"BlockchainTransaction"> | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringFilter<"BlockchainTransaction"> | string
    blockchainRequestId?: StringNullableFilter<"BlockchainTransaction"> | string | null
    createdAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    cryptoWallet?: XOR<CryptoWalletScalarRelationFilter, CryptoWalletWhereInput>
    blockchainRequest?: XOR<BlockchainRequestNullableScalarRelationFilter, BlockchainRequestWhereInput> | null
  }

  export type BlockchainTransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionHash?: SortOrder
    from?: SortOrder
    to?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    cryptoWalletId?: SortOrder
    blockchainRequestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cryptoWallet?: CryptoWalletOrderByWithRelationInput
    blockchainRequest?: BlockchainRequestOrderByWithRelationInput
  }

  export type BlockchainTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionHash?: string
    AND?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    OR?: BlockchainTransactionWhereInput[]
    NOT?: BlockchainTransactionWhereInput | BlockchainTransactionWhereInput[]
    from?: StringFilter<"BlockchainTransaction"> | string
    to?: StringFilter<"BlockchainTransaction"> | string
    amount?: FloatFilter<"BlockchainTransaction"> | number
    status?: EnumBlockchainTxStatusFilter<"BlockchainTransaction"> | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringFilter<"BlockchainTransaction"> | string
    blockchainRequestId?: StringNullableFilter<"BlockchainTransaction"> | string | null
    createdAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    cryptoWallet?: XOR<CryptoWalletScalarRelationFilter, CryptoWalletWhereInput>
    blockchainRequest?: XOR<BlockchainRequestNullableScalarRelationFilter, BlockchainRequestWhereInput> | null
  }, "id" | "transactionHash">

  export type BlockchainTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionHash?: SortOrder
    from?: SortOrder
    to?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    cryptoWalletId?: SortOrder
    blockchainRequestId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlockchainTransactionCountOrderByAggregateInput
    _avg?: BlockchainTransactionAvgOrderByAggregateInput
    _max?: BlockchainTransactionMaxOrderByAggregateInput
    _min?: BlockchainTransactionMinOrderByAggregateInput
    _sum?: BlockchainTransactionSumOrderByAggregateInput
  }

  export type BlockchainTransactionScalarWhereWithAggregatesInput = {
    AND?: BlockchainTransactionScalarWhereWithAggregatesInput | BlockchainTransactionScalarWhereWithAggregatesInput[]
    OR?: BlockchainTransactionScalarWhereWithAggregatesInput[]
    NOT?: BlockchainTransactionScalarWhereWithAggregatesInput | BlockchainTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    transactionHash?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    from?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    to?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    amount?: FloatWithAggregatesFilter<"BlockchainTransaction"> | number
    status?: EnumBlockchainTxStatusWithAggregatesFilter<"BlockchainTransaction"> | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringWithAggregatesFilter<"BlockchainTransaction"> | string
    blockchainRequestId?: StringNullableWithAggregatesFilter<"BlockchainTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockchainTransaction"> | Date | string
  }

  export type SplitPaymentWhereInput = {
    AND?: SplitPaymentWhereInput | SplitPaymentWhereInput[]
    OR?: SplitPaymentWhereInput[]
    NOT?: SplitPaymentWhereInput | SplitPaymentWhereInput[]
    id?: StringFilter<"SplitPayment"> | string
    email?: StringFilter<"SplitPayment"> | string
    amount?: FloatFilter<"SplitPayment"> | number
    splitCode?: StringFilter<"SplitPayment"> | string
    reference?: StringFilter<"SplitPayment"> | string
    status?: StringFilter<"SplitPayment"> | string
    createdAt?: DateTimeFilter<"SplitPayment"> | Date | string
  }

  export type SplitPaymentOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    splitCode?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SplitPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: SplitPaymentWhereInput | SplitPaymentWhereInput[]
    OR?: SplitPaymentWhereInput[]
    NOT?: SplitPaymentWhereInput | SplitPaymentWhereInput[]
    email?: StringFilter<"SplitPayment"> | string
    amount?: FloatFilter<"SplitPayment"> | number
    splitCode?: StringFilter<"SplitPayment"> | string
    status?: StringFilter<"SplitPayment"> | string
    createdAt?: DateTimeFilter<"SplitPayment"> | Date | string
  }, "id" | "reference">

  export type SplitPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    splitCode?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: SplitPaymentCountOrderByAggregateInput
    _avg?: SplitPaymentAvgOrderByAggregateInput
    _max?: SplitPaymentMaxOrderByAggregateInput
    _min?: SplitPaymentMinOrderByAggregateInput
    _sum?: SplitPaymentSumOrderByAggregateInput
  }

  export type SplitPaymentScalarWhereWithAggregatesInput = {
    AND?: SplitPaymentScalarWhereWithAggregatesInput | SplitPaymentScalarWhereWithAggregatesInput[]
    OR?: SplitPaymentScalarWhereWithAggregatesInput[]
    NOT?: SplitPaymentScalarWhereWithAggregatesInput | SplitPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SplitPayment"> | string
    email?: StringWithAggregatesFilter<"SplitPayment"> | string
    amount?: FloatWithAggregatesFilter<"SplitPayment"> | number
    splitCode?: StringWithAggregatesFilter<"SplitPayment"> | string
    reference?: StringWithAggregatesFilter<"SplitPayment"> | string
    status?: StringWithAggregatesFilter<"SplitPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SplitPayment"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutUserInput
    requests?: RequestCreateNestedManyWithoutRequesterInput
    supports?: RequestCreateNestedManyWithoutSupporterInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutUserInput
    sponsoredBills?: BillCreateNestedManyWithoutSponsorsInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    requests?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    supports?: RequestUncheckedCreateNestedManyWithoutSupporterInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletUncheckedCreateNestedOneWithoutUserInput
    sponsoredBills?: BillUncheckedCreateNestedManyWithoutSponsorsInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutUserNestedInput
    requests?: RequestUpdateManyWithoutRequesterNestedInput
    supports?: RequestUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUpdateManyWithoutSponsorsNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    supports?: RequestUncheckedUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUncheckedUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUncheckedUpdateManyWithoutSponsorsNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderCreateInput = {
    id?: string
    name: string
    email?: string | null
    accountNumber?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    accountNumber?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    accountNumber?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillsInput
    provider?: ProviderCreateNestedOneWithoutBillsInput
    request?: RequestCreateNestedOneWithoutBillsInput
    sponsors?: UserCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    providerId?: string | null
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sponsors?: UserUncheckedCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestUncheckedCreateNestedOneWithoutBillInput
  }

  export type BillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillsNestedInput
    provider?: ProviderUpdateOneWithoutBillsNestedInput
    request?: RequestUpdateOneWithoutBillsNestedInput
    sponsors?: UserUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsors?: UserUncheckedUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUncheckedUpdateOneWithoutBillNestedInput
  }

  export type BillCreateManyInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    providerId?: string | null
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    status?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    amount: number
    status?: string
    billId: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    amount: number
    status?: string
    billId: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    balance?: number
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    balance?: number
    userId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateManyInput = {
    id?: string
    balance?: number
    userId: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutRequestsInput
    supporter?: UserCreateNestedOneWithoutSupportsInput
    bills?: BillCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    requesterId: string
    supporterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutRequestsNestedInput
    supporter?: UserUpdateOneWithoutSupportsNestedInput
    bills?: BillUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    supporterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestCreateManyInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    requesterId: string
    supporterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    supporterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    email: string
    amount: number
    reference: string
    status?: string
    splitCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    email: string
    amount: number
    reference: string
    status?: string
    splitCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    splitCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    splitCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    email: string
    amount: number
    reference: string
    status?: string
    splitCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    splitCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    splitCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirtimeTransactionCreateInput = {
    id?: string
    phone: string
    amount: number
    network: string
    reference: string
    createdAt?: Date | string
  }

  export type AirtimeTransactionUncheckedCreateInput = {
    id?: string
    phone: string
    amount: number
    network: string
    reference: string
    createdAt?: Date | string
  }

  export type AirtimeTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirtimeTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirtimeTransactionCreateManyInput = {
    id?: string
    phone: string
    amount: number
    network: string
    reference: string
    createdAt?: Date | string
  }

  export type AirtimeTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirtimeTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    network?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubaccountCreateInput = {
    id?: string
    businessName: string
    bankCode: string
    accountNumber: string
    percentageCharge: number
    subaccountCode: string
    createdAt?: Date | string
    lastPaidAt?: Date | string | null
    subaccountSplits?: SubaccountSplitCreateNestedManyWithoutSubaccountInput
  }

  export type SubaccountUncheckedCreateInput = {
    id?: string
    businessName: string
    bankCode: string
    accountNumber: string
    percentageCharge: number
    subaccountCode: string
    createdAt?: Date | string
    lastPaidAt?: Date | string | null
    subaccountSplits?: SubaccountSplitUncheckedCreateNestedManyWithoutSubaccountInput
  }

  export type SubaccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    percentageCharge?: FloatFieldUpdateOperationsInput | number
    subaccountCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subaccountSplits?: SubaccountSplitUpdateManyWithoutSubaccountNestedInput
  }

  export type SubaccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    percentageCharge?: FloatFieldUpdateOperationsInput | number
    subaccountCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subaccountSplits?: SubaccountSplitUncheckedUpdateManyWithoutSubaccountNestedInput
  }

  export type SubaccountCreateManyInput = {
    id?: string
    businessName: string
    bankCode: string
    accountNumber: string
    percentageCharge: number
    subaccountCode: string
    createdAt?: Date | string
    lastPaidAt?: Date | string | null
  }

  export type SubaccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    percentageCharge?: FloatFieldUpdateOperationsInput | number
    subaccountCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubaccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    percentageCharge?: FloatFieldUpdateOperationsInput | number
    subaccountCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubaccountSplitCreateInput = {
    id?: string
    share: number
    subaccount: SubaccountCreateNestedOneWithoutSubaccountSplitsInput
    splitGroup: SplitGroupCreateNestedOneWithoutSubaccountsInput
  }

  export type SubaccountSplitUncheckedCreateInput = {
    id?: string
    subaccountId: string
    splitGroupId: string
    share: number
  }

  export type SubaccountSplitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
    subaccount?: SubaccountUpdateOneRequiredWithoutSubaccountSplitsNestedInput
    splitGroup?: SplitGroupUpdateOneRequiredWithoutSubaccountsNestedInput
  }

  export type SubaccountSplitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subaccountId?: StringFieldUpdateOperationsInput | string
    splitGroupId?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
  }

  export type SubaccountSplitCreateManyInput = {
    id?: string
    subaccountId: string
    splitGroupId: string
    share: number
  }

  export type SubaccountSplitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
  }

  export type SubaccountSplitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subaccountId?: StringFieldUpdateOperationsInput | string
    splitGroupId?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
  }

  export type SplitGroupCreateInput = {
    id?: string
    name: string
    type: string
    currency: string
    splitCode: string
    bearerType?: string | null
    bearerSubaccount: string
    createdAt?: Date | string
    subaccounts?: SubaccountSplitCreateNestedManyWithoutSplitGroupInput
  }

  export type SplitGroupUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    currency: string
    splitCode: string
    bearerType?: string | null
    bearerSubaccount: string
    createdAt?: Date | string
    subaccounts?: SubaccountSplitUncheckedCreateNestedManyWithoutSplitGroupInput
  }

  export type SplitGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    splitCode?: StringFieldUpdateOperationsInput | string
    bearerType?: NullableStringFieldUpdateOperationsInput | string | null
    bearerSubaccount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subaccounts?: SubaccountSplitUpdateManyWithoutSplitGroupNestedInput
  }

  export type SplitGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    splitCode?: StringFieldUpdateOperationsInput | string
    bearerType?: NullableStringFieldUpdateOperationsInput | string | null
    bearerSubaccount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subaccounts?: SubaccountSplitUncheckedUpdateManyWithoutSplitGroupNestedInput
  }

  export type SplitGroupCreateManyInput = {
    id?: string
    name: string
    type: string
    currency: string
    splitCode: string
    bearerType?: string | null
    bearerSubaccount: string
    createdAt?: Date | string
  }

  export type SplitGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    splitCode?: StringFieldUpdateOperationsInput | string
    bearerType?: NullableStringFieldUpdateOperationsInput | string | null
    bearerSubaccount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SplitGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    splitCode?: StringFieldUpdateOperationsInput | string
    bearerType?: NullableStringFieldUpdateOperationsInput | string | null
    bearerSubaccount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateInput = {
    id?: string
    name: string
    accountNumber: string
    bankName: string
    bankCode: string
    recipientCode: string
    amount: number
    reason: string
    reference?: string | null
    status: string
    createdAt?: Date | string
    batch?: BatchCreateNestedOneWithoutTransfersInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    name: string
    accountNumber: string
    bankName: string
    bankCode: string
    recipientCode: string
    amount: number
    reason: string
    reference?: string | null
    status: string
    batchId?: string | null
    createdAt?: Date | string
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneWithoutTransfersNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateManyInput = {
    id?: string
    name: string
    accountNumber: string
    bankName: string
    bankCode: string
    recipientCode: string
    amount: number
    reason: string
    reference?: string | null
    status: string
    batchId?: string | null
    createdAt?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateInput = {
    id?: string
    createdAt?: Date | string
    status: string
    transfers?: TransferCreateNestedManyWithoutBatchInput
    bulkTransfers?: BulkTransferCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    status: string
    transfers?: TransferUncheckedCreateNestedManyWithoutBatchInput
    bulkTransfers?: BulkTransferUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    transfers?: TransferUpdateManyWithoutBatchNestedInput
    bulkTransfers?: BulkTransferUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    transfers?: TransferUncheckedUpdateManyWithoutBatchNestedInput
    bulkTransfers?: BulkTransferUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id?: string
    createdAt?: Date | string
    status: string
  }

  export type BatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type BulkTransferCreateInput = {
    id?: string
    amount: number
    status: string
    reference: string
    reason: string
    recipientCode: string
    transferCode: string
    createdAt?: Date | string
    batch: BatchCreateNestedOneWithoutBulkTransfersInput
  }

  export type BulkTransferUncheckedCreateInput = {
    id?: string
    amount: number
    status: string
    reference: string
    reason: string
    recipientCode: string
    transferCode: string
    createdAt?: Date | string
    batchId: string
  }

  export type BulkTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutBulkTransfersNestedInput
  }

  export type BulkTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
  }

  export type BulkTransferCreateManyInput = {
    id?: string
    amount: number
    status: string
    reference: string
    reason: string
    recipientCode: string
    transferCode: string
    createdAt?: Date | string
    batchId: string
  }

  export type BulkTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipientCreateInput = {
    id?: string
    name: string
    accountNumber: string
    bankCode: string
    recipientCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientUncheckedCreateInput = {
    id?: string
    name: string
    accountNumber: string
    bankCode: string
    recipientCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientCreateManyInput = {
    id?: string
    name: string
    accountNumber: string
    bankCode: string
    recipientCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletCreateInput = {
    id?: string
    address: string
    u2kBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoWalletInput
    transactions?: BlockchainTransactionCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletUncheckedCreateInput = {
    id?: string
    address: string
    userId: string
    u2kBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoWalletNestedInput
    transactions?: BlockchainTransactionUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BlockchainTransactionUncheckedUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletCreateManyInput = {
    id?: string
    address: string
    userId: string
    u2kBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainRequestCreateInput = {
    id?: string
    blockchainBillId?: string | null
    transactionHash?: string | null
    status?: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType?: $Enums.PaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutBlockchainRequestInput
    transactions?: BlockchainTransactionCreateNestedManyWithoutBlockchainRequestInput
  }

  export type BlockchainRequestUncheckedCreateInput = {
    id?: string
    billId: string
    blockchainBillId?: string | null
    transactionHash?: string | null
    status?: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType?: $Enums.PaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutBlockchainRequestInput
  }

  export type BlockchainRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutBlockchainRequestNestedInput
    transactions?: BlockchainTransactionUpdateManyWithoutBlockchainRequestNestedInput
  }

  export type BlockchainRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BlockchainTransactionUncheckedUpdateManyWithoutBlockchainRequestNestedInput
  }

  export type BlockchainRequestCreateManyInput = {
    id?: string
    billId: string
    blockchainBillId?: string | null
    transactionHash?: string | null
    status?: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType?: $Enums.PaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionCreateInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoWallet: CryptoWalletCreateNestedOneWithoutTransactionsInput
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutTransactionsInput
  }

  export type BlockchainTransactionUncheckedCreateInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    cryptoWalletId: string
    blockchainRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoWallet?: CryptoWalletUpdateOneRequiredWithoutTransactionsNestedInput
    blockchainRequest?: BlockchainRequestUpdateOneWithoutTransactionsNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringFieldUpdateOperationsInput | string
    blockchainRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionCreateManyInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    cryptoWalletId: string
    blockchainRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringFieldUpdateOperationsInput | string
    blockchainRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SplitPaymentCreateInput = {
    id?: string
    email: string
    amount: number
    splitCode: string
    reference: string
    status?: string
    createdAt?: Date | string
  }

  export type SplitPaymentUncheckedCreateInput = {
    id?: string
    email: string
    amount: number
    splitCode: string
    reference: string
    status?: string
    createdAt?: Date | string
  }

  export type SplitPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    splitCode?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SplitPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    splitCode?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SplitPaymentCreateManyInput = {
    id?: string
    email: string
    amount: number
    splitCode: string
    reference: string
    status?: string
    createdAt?: Date | string
  }

  export type SplitPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    splitCode?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SplitPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    splitCode?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type RequestListRelationFilter = {
    every?: RequestWhereInput
    some?: RequestWhereInput
    none?: RequestWhereInput
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type CryptoWalletNullableScalarRelationFilter = {
    is?: CryptoWalletWhereInput | null
    isNot?: CryptoWalletWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    googleId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    accountNumber?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    accountNumber?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    accountNumber?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProviderNullableScalarRelationFilter = {
    is?: ProviderWhereInput | null
    isNot?: ProviderWhereInput | null
  }

  export type RequestNullableScalarRelationFilter = {
    is?: RequestWhereInput | null
    isNot?: RequestWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type BlockchainRequestNullableScalarRelationFilter = {
    is?: BlockchainRequestWhereInput | null
    isNot?: BlockchainRequestWhereInput | null
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillCountOrderByAggregateInput = {
    id?: SortOrder
    billName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    note?: SortOrder
    amount?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrder
    dueDate?: SortOrder
    paymentMethod?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillMaxOrderByAggregateInput = {
    id?: SortOrder
    billName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    note?: SortOrder
    amount?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrder
    dueDate?: SortOrder
    paymentMethod?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillMinOrderByAggregateInput = {
    id?: SortOrder
    billName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    note?: SortOrder
    amount?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrder
    dueDate?: SortOrder
    paymentMethod?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    requestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BillScalarRelationFilter = {
    is?: BillWhereInput
    isNot?: BillWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    billId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    billId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    billId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RequestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    publicLinkId?: SortOrder
    requesterId?: SortOrder
    supporterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    publicLinkId?: SortOrder
    requesterId?: SortOrder
    supporterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    publicLinkId?: SortOrder
    requesterId?: SortOrder
    supporterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    splitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    splitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    splitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AirtimeTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    amount?: SortOrder
    network?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type AirtimeTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AirtimeTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    amount?: SortOrder
    network?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type AirtimeTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    amount?: SortOrder
    network?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type AirtimeTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubaccountSplitListRelationFilter = {
    every?: SubaccountSplitWhereInput
    some?: SubaccountSplitWhereInput
    none?: SubaccountSplitWhereInput
  }

  export type SubaccountSplitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubaccountCountOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    percentageCharge?: SortOrder
    subaccountCode?: SortOrder
    createdAt?: SortOrder
    lastPaidAt?: SortOrder
  }

  export type SubaccountAvgOrderByAggregateInput = {
    percentageCharge?: SortOrder
  }

  export type SubaccountMaxOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    percentageCharge?: SortOrder
    subaccountCode?: SortOrder
    createdAt?: SortOrder
    lastPaidAt?: SortOrder
  }

  export type SubaccountMinOrderByAggregateInput = {
    id?: SortOrder
    businessName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    percentageCharge?: SortOrder
    subaccountCode?: SortOrder
    createdAt?: SortOrder
    lastPaidAt?: SortOrder
  }

  export type SubaccountSumOrderByAggregateInput = {
    percentageCharge?: SortOrder
  }

  export type SubaccountScalarRelationFilter = {
    is?: SubaccountWhereInput
    isNot?: SubaccountWhereInput
  }

  export type SplitGroupScalarRelationFilter = {
    is?: SplitGroupWhereInput
    isNot?: SplitGroupWhereInput
  }

  export type SubaccountSplitCountOrderByAggregateInput = {
    id?: SortOrder
    subaccountId?: SortOrder
    splitGroupId?: SortOrder
    share?: SortOrder
  }

  export type SubaccountSplitAvgOrderByAggregateInput = {
    share?: SortOrder
  }

  export type SubaccountSplitMaxOrderByAggregateInput = {
    id?: SortOrder
    subaccountId?: SortOrder
    splitGroupId?: SortOrder
    share?: SortOrder
  }

  export type SubaccountSplitMinOrderByAggregateInput = {
    id?: SortOrder
    subaccountId?: SortOrder
    splitGroupId?: SortOrder
    share?: SortOrder
  }

  export type SubaccountSplitSumOrderByAggregateInput = {
    share?: SortOrder
  }

  export type SplitGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    splitCode?: SortOrder
    bearerType?: SortOrder
    bearerSubaccount?: SortOrder
    createdAt?: SortOrder
  }

  export type SplitGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    splitCode?: SortOrder
    bearerType?: SortOrder
    bearerSubaccount?: SortOrder
    createdAt?: SortOrder
  }

  export type SplitGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    splitCode?: SortOrder
    bearerType?: SortOrder
    bearerSubaccount?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchNullableScalarRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type BulkTransferListRelationFilter = {
    every?: BulkTransferWhereInput
    some?: BulkTransferWhereInput
    none?: BulkTransferWhereInput
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BulkTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BatchScalarRelationFilter = {
    is?: BatchWhereInput
    isNot?: BatchWhereInput
  }

  export type BulkTransferCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    recipientCode?: SortOrder
    transferCode?: SortOrder
    createdAt?: SortOrder
    batchId?: SortOrder
  }

  export type BulkTransferAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BulkTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    recipientCode?: SortOrder
    transferCode?: SortOrder
    createdAt?: SortOrder
    batchId?: SortOrder
  }

  export type BulkTransferMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    recipientCode?: SortOrder
    transferCode?: SortOrder
    createdAt?: SortOrder
    batchId?: SortOrder
  }

  export type BulkTransferSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RecipientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankCode?: SortOrder
    recipientCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainTransactionListRelationFilter = {
    every?: BlockchainTransactionWhereInput
    some?: BlockchainTransactionWhereInput
    none?: BlockchainTransactionWhereInput
  }

  export type BlockchainTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoWalletCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    userId?: SortOrder
    u2kBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletAvgOrderByAggregateInput = {
    u2kBalance?: SortOrder
  }

  export type CryptoWalletMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    userId?: SortOrder
    u2kBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    userId?: SortOrder
    u2kBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoWalletSumOrderByAggregateInput = {
    u2kBalance?: SortOrder
  }

  export type EnumBlockchainTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockchainTxStatus | EnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockchainTxStatusFilter<$PrismaModel> | $Enums.BlockchainTxStatus
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type BlockchainRequestCountOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    blockchainBillId?: SortOrder
    transactionHash?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    cryptoAmount?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainRequestAvgOrderByAggregateInput = {
    amount?: SortOrder
    cryptoAmount?: SortOrder
  }

  export type BlockchainRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    blockchainBillId?: SortOrder
    transactionHash?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    cryptoAmount?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainRequestMinOrderByAggregateInput = {
    id?: SortOrder
    billId?: SortOrder
    blockchainBillId?: SortOrder
    transactionHash?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    cryptoAmount?: SortOrder
    paymentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainRequestSumOrderByAggregateInput = {
    amount?: SortOrder
    cryptoAmount?: SortOrder
  }

  export type EnumBlockchainTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockchainTxStatus | EnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockchainTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlockchainTxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlockchainTxStatusFilter<$PrismaModel>
    _max?: NestedEnumBlockchainTxStatusFilter<$PrismaModel>
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type CryptoWalletScalarRelationFilter = {
    is?: CryptoWalletWhereInput
    isNot?: CryptoWalletWhereInput
  }

  export type BlockchainTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionHash?: SortOrder
    from?: SortOrder
    to?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    cryptoWalletId?: SortOrder
    blockchainRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BlockchainTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionHash?: SortOrder
    from?: SortOrder
    to?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    cryptoWalletId?: SortOrder
    blockchainRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionHash?: SortOrder
    from?: SortOrder
    to?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    cryptoWalletId?: SortOrder
    blockchainRequestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockchainTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SplitPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    splitCode?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SplitPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SplitPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    splitCode?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SplitPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    amount?: SortOrder
    splitCode?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SplitPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillCreateNestedManyWithoutUserInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type RequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type RequestCreateNestedManyWithoutSupporterInput = {
    create?: XOR<RequestCreateWithoutSupporterInput, RequestUncheckedCreateWithoutSupporterInput> | RequestCreateWithoutSupporterInput[] | RequestUncheckedCreateWithoutSupporterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutSupporterInput | RequestCreateOrConnectWithoutSupporterInput[]
    createMany?: RequestCreateManySupporterInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type CryptoWalletCreateNestedOneWithoutUserInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput
    connect?: CryptoWalletWhereUniqueInput
  }

  export type BillCreateNestedManyWithoutSponsorsInput = {
    create?: XOR<BillCreateWithoutSponsorsInput, BillUncheckedCreateWithoutSponsorsInput> | BillCreateWithoutSponsorsInput[] | BillUncheckedCreateWithoutSponsorsInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSponsorsInput | BillCreateOrConnectWithoutSponsorsInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type RequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type RequestUncheckedCreateNestedManyWithoutSupporterInput = {
    create?: XOR<RequestCreateWithoutSupporterInput, RequestUncheckedCreateWithoutSupporterInput> | RequestCreateWithoutSupporterInput[] | RequestUncheckedCreateWithoutSupporterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutSupporterInput | RequestCreateOrConnectWithoutSupporterInput[]
    createMany?: RequestCreateManySupporterInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type CryptoWalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput
    connect?: CryptoWalletWhereUniqueInput
  }

  export type BillUncheckedCreateNestedManyWithoutSponsorsInput = {
    create?: XOR<BillCreateWithoutSponsorsInput, BillUncheckedCreateWithoutSponsorsInput> | BillCreateWithoutSponsorsInput[] | BillUncheckedCreateWithoutSponsorsInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSponsorsInput | BillCreateOrConnectWithoutSponsorsInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BillUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutUserInput | BillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutUserInput | BillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillUpdateManyWithWhereWithoutUserInput | BillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type RequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutRequesterInput | RequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutRequesterInput | RequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutRequesterInput | RequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type RequestUpdateManyWithoutSupporterNestedInput = {
    create?: XOR<RequestCreateWithoutSupporterInput, RequestUncheckedCreateWithoutSupporterInput> | RequestCreateWithoutSupporterInput[] | RequestUncheckedCreateWithoutSupporterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutSupporterInput | RequestCreateOrConnectWithoutSupporterInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutSupporterInput | RequestUpsertWithWhereUniqueWithoutSupporterInput[]
    createMany?: RequestCreateManySupporterInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutSupporterInput | RequestUpdateWithWhereUniqueWithoutSupporterInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutSupporterInput | RequestUpdateManyWithWhereWithoutSupporterInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type CryptoWalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput
    upsert?: CryptoWalletUpsertWithoutUserInput
    disconnect?: CryptoWalletWhereInput | boolean
    delete?: CryptoWalletWhereInput | boolean
    connect?: CryptoWalletWhereUniqueInput
    update?: XOR<XOR<CryptoWalletUpdateToOneWithWhereWithoutUserInput, CryptoWalletUpdateWithoutUserInput>, CryptoWalletUncheckedUpdateWithoutUserInput>
  }

  export type BillUpdateManyWithoutSponsorsNestedInput = {
    create?: XOR<BillCreateWithoutSponsorsInput, BillUncheckedCreateWithoutSponsorsInput> | BillCreateWithoutSponsorsInput[] | BillUncheckedCreateWithoutSponsorsInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSponsorsInput | BillCreateOrConnectWithoutSponsorsInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutSponsorsInput | BillUpsertWithWhereUniqueWithoutSponsorsInput[]
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutSponsorsInput | BillUpdateWithWhereUniqueWithoutSponsorsInput[]
    updateMany?: BillUpdateManyWithWhereWithoutSponsorsInput | BillUpdateManyWithWhereWithoutSponsorsInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput> | BillCreateWithoutUserInput[] | BillUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BillCreateOrConnectWithoutUserInput | BillCreateOrConnectWithoutUserInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutUserInput | BillUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BillCreateManyUserInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutUserInput | BillUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BillUpdateManyWithWhereWithoutUserInput | BillUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type RequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput> | RequestCreateWithoutRequesterInput[] | RequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutRequesterInput | RequestCreateOrConnectWithoutRequesterInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutRequesterInput | RequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: RequestCreateManyRequesterInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutRequesterInput | RequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutRequesterInput | RequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type RequestUncheckedUpdateManyWithoutSupporterNestedInput = {
    create?: XOR<RequestCreateWithoutSupporterInput, RequestUncheckedCreateWithoutSupporterInput> | RequestCreateWithoutSupporterInput[] | RequestUncheckedCreateWithoutSupporterInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutSupporterInput | RequestCreateOrConnectWithoutSupporterInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutSupporterInput | RequestUpsertWithWhereUniqueWithoutSupporterInput[]
    createMany?: RequestCreateManySupporterInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutSupporterInput | RequestUpdateWithWhereUniqueWithoutSupporterInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutSupporterInput | RequestUpdateManyWithWhereWithoutSupporterInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type CryptoWalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutUserInput
    upsert?: CryptoWalletUpsertWithoutUserInput
    disconnect?: CryptoWalletWhereInput | boolean
    delete?: CryptoWalletWhereInput | boolean
    connect?: CryptoWalletWhereUniqueInput
    update?: XOR<XOR<CryptoWalletUpdateToOneWithWhereWithoutUserInput, CryptoWalletUpdateWithoutUserInput>, CryptoWalletUncheckedUpdateWithoutUserInput>
  }

  export type BillUncheckedUpdateManyWithoutSponsorsNestedInput = {
    create?: XOR<BillCreateWithoutSponsorsInput, BillUncheckedCreateWithoutSponsorsInput> | BillCreateWithoutSponsorsInput[] | BillUncheckedCreateWithoutSponsorsInput[]
    connectOrCreate?: BillCreateOrConnectWithoutSponsorsInput | BillCreateOrConnectWithoutSponsorsInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutSponsorsInput | BillUpsertWithWhereUniqueWithoutSponsorsInput[]
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutSponsorsInput | BillUpdateWithWhereUniqueWithoutSponsorsInput[]
    updateMany?: BillUpdateManyWithWhereWithoutSponsorsInput | BillUpdateManyWithWhereWithoutSponsorsInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BillCreateNestedManyWithoutProviderInput = {
    create?: XOR<BillCreateWithoutProviderInput, BillUncheckedCreateWithoutProviderInput> | BillCreateWithoutProviderInput[] | BillUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProviderInput | BillCreateOrConnectWithoutProviderInput[]
    createMany?: BillCreateManyProviderInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<BillCreateWithoutProviderInput, BillUncheckedCreateWithoutProviderInput> | BillCreateWithoutProviderInput[] | BillUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProviderInput | BillCreateOrConnectWithoutProviderInput[]
    createMany?: BillCreateManyProviderInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BillUpdateManyWithoutProviderNestedInput = {
    create?: XOR<BillCreateWithoutProviderInput, BillUncheckedCreateWithoutProviderInput> | BillCreateWithoutProviderInput[] | BillUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProviderInput | BillCreateOrConnectWithoutProviderInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutProviderInput | BillUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: BillCreateManyProviderInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutProviderInput | BillUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: BillUpdateManyWithWhereWithoutProviderInput | BillUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<BillCreateWithoutProviderInput, BillUncheckedCreateWithoutProviderInput> | BillCreateWithoutProviderInput[] | BillUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BillCreateOrConnectWithoutProviderInput | BillCreateOrConnectWithoutProviderInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutProviderInput | BillUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: BillCreateManyProviderInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutProviderInput | BillUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: BillUpdateManyWithWhereWithoutProviderInput | BillUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBillsInput = {
    create?: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillsInput
    connect?: UserWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutBillsInput = {
    create?: XOR<ProviderCreateWithoutBillsInput, ProviderUncheckedCreateWithoutBillsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutBillsInput
    connect?: ProviderWhereUniqueInput
  }

  export type RequestCreateNestedOneWithoutBillsInput = {
    create?: XOR<RequestCreateWithoutBillsInput, RequestUncheckedCreateWithoutBillsInput>
    connectOrCreate?: RequestCreateOrConnectWithoutBillsInput
    connect?: RequestWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSponsoredBillsInput = {
    create?: XOR<UserCreateWithoutSponsoredBillsInput, UserUncheckedCreateWithoutSponsoredBillsInput> | UserCreateWithoutSponsoredBillsInput[] | UserUncheckedCreateWithoutSponsoredBillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSponsoredBillsInput | UserCreateOrConnectWithoutSponsoredBillsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutBillInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BlockchainRequestCreateNestedOneWithoutBillInput = {
    create?: XOR<BlockchainRequestCreateWithoutBillInput, BlockchainRequestUncheckedCreateWithoutBillInput>
    connectOrCreate?: BlockchainRequestCreateOrConnectWithoutBillInput
    connect?: BlockchainRequestWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutSponsoredBillsInput = {
    create?: XOR<UserCreateWithoutSponsoredBillsInput, UserUncheckedCreateWithoutSponsoredBillsInput> | UserCreateWithoutSponsoredBillsInput[] | UserUncheckedCreateWithoutSponsoredBillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSponsoredBillsInput | UserCreateOrConnectWithoutSponsoredBillsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BlockchainRequestUncheckedCreateNestedOneWithoutBillInput = {
    create?: XOR<BlockchainRequestCreateWithoutBillInput, BlockchainRequestUncheckedCreateWithoutBillInput>
    connectOrCreate?: BlockchainRequestCreateOrConnectWithoutBillInput
    connect?: BlockchainRequestWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumBillStatusFieldUpdateOperationsInput = {
    set?: $Enums.BillStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillsInput
    upsert?: UserUpsertWithoutBillsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBillsInput, UserUpdateWithoutBillsInput>, UserUncheckedUpdateWithoutBillsInput>
  }

  export type ProviderUpdateOneWithoutBillsNestedInput = {
    create?: XOR<ProviderCreateWithoutBillsInput, ProviderUncheckedCreateWithoutBillsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutBillsInput
    upsert?: ProviderUpsertWithoutBillsInput
    disconnect?: ProviderWhereInput | boolean
    delete?: ProviderWhereInput | boolean
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutBillsInput, ProviderUpdateWithoutBillsInput>, ProviderUncheckedUpdateWithoutBillsInput>
  }

  export type RequestUpdateOneWithoutBillsNestedInput = {
    create?: XOR<RequestCreateWithoutBillsInput, RequestUncheckedCreateWithoutBillsInput>
    connectOrCreate?: RequestCreateOrConnectWithoutBillsInput
    upsert?: RequestUpsertWithoutBillsInput
    disconnect?: RequestWhereInput | boolean
    delete?: RequestWhereInput | boolean
    connect?: RequestWhereUniqueInput
    update?: XOR<XOR<RequestUpdateToOneWithWhereWithoutBillsInput, RequestUpdateWithoutBillsInput>, RequestUncheckedUpdateWithoutBillsInput>
  }

  export type UserUpdateManyWithoutSponsoredBillsNestedInput = {
    create?: XOR<UserCreateWithoutSponsoredBillsInput, UserUncheckedCreateWithoutSponsoredBillsInput> | UserCreateWithoutSponsoredBillsInput[] | UserUncheckedCreateWithoutSponsoredBillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSponsoredBillsInput | UserCreateOrConnectWithoutSponsoredBillsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSponsoredBillsInput | UserUpsertWithWhereUniqueWithoutSponsoredBillsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSponsoredBillsInput | UserUpdateWithWhereUniqueWithoutSponsoredBillsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSponsoredBillsInput | UserUpdateManyWithWhereWithoutSponsoredBillsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutBillNestedInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBillInput | TransactionUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBillInput | TransactionUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBillInput | TransactionUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BlockchainRequestUpdateOneWithoutBillNestedInput = {
    create?: XOR<BlockchainRequestCreateWithoutBillInput, BlockchainRequestUncheckedCreateWithoutBillInput>
    connectOrCreate?: BlockchainRequestCreateOrConnectWithoutBillInput
    upsert?: BlockchainRequestUpsertWithoutBillInput
    disconnect?: BlockchainRequestWhereInput | boolean
    delete?: BlockchainRequestWhereInput | boolean
    connect?: BlockchainRequestWhereUniqueInput
    update?: XOR<XOR<BlockchainRequestUpdateToOneWithWhereWithoutBillInput, BlockchainRequestUpdateWithoutBillInput>, BlockchainRequestUncheckedUpdateWithoutBillInput>
  }

  export type UserUncheckedUpdateManyWithoutSponsoredBillsNestedInput = {
    create?: XOR<UserCreateWithoutSponsoredBillsInput, UserUncheckedCreateWithoutSponsoredBillsInput> | UserCreateWithoutSponsoredBillsInput[] | UserUncheckedCreateWithoutSponsoredBillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSponsoredBillsInput | UserCreateOrConnectWithoutSponsoredBillsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSponsoredBillsInput | UserUpsertWithWhereUniqueWithoutSponsoredBillsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSponsoredBillsInput | UserUpdateWithWhereUniqueWithoutSponsoredBillsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSponsoredBillsInput | UserUpdateManyWithWhereWithoutSponsoredBillsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput> | TransactionCreateWithoutBillInput[] | TransactionUncheckedCreateWithoutBillInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBillInput | TransactionCreateOrConnectWithoutBillInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBillInput | TransactionUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: TransactionCreateManyBillInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBillInput | TransactionUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBillInput | TransactionUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BlockchainRequestUncheckedUpdateOneWithoutBillNestedInput = {
    create?: XOR<BlockchainRequestCreateWithoutBillInput, BlockchainRequestUncheckedCreateWithoutBillInput>
    connectOrCreate?: BlockchainRequestCreateOrConnectWithoutBillInput
    upsert?: BlockchainRequestUpsertWithoutBillInput
    disconnect?: BlockchainRequestWhereInput | boolean
    delete?: BlockchainRequestWhereInput | boolean
    connect?: BlockchainRequestWhereUniqueInput
    update?: XOR<XOR<BlockchainRequestUpdateToOneWithWhereWithoutBillInput, BlockchainRequestUpdateWithoutBillInput>, BlockchainRequestUncheckedUpdateWithoutBillInput>
  }

  export type BillCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BillCreateWithoutTransactionsInput, BillUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BillCreateOrConnectWithoutTransactionsInput
    connect?: BillWhereUniqueInput
  }

  export type BillUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<BillCreateWithoutTransactionsInput, BillUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BillCreateOrConnectWithoutTransactionsInput
    upsert?: BillUpsertWithoutTransactionsInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutTransactionsInput, BillUpdateWithoutTransactionsInput>, BillUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletInput, UserUpdateWithoutWalletInput>, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserCreateNestedOneWithoutRequestsInput = {
    create?: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupportsInput = {
    create?: XOR<UserCreateWithoutSupportsInput, UserUncheckedCreateWithoutSupportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportsInput
    connect?: UserWhereUniqueInput
  }

  export type BillCreateNestedManyWithoutRequestInput = {
    create?: XOR<BillCreateWithoutRequestInput, BillUncheckedCreateWithoutRequestInput> | BillCreateWithoutRequestInput[] | BillUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: BillCreateOrConnectWithoutRequestInput | BillCreateOrConnectWithoutRequestInput[]
    createMany?: BillCreateManyRequestInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type BillUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<BillCreateWithoutRequestInput, BillUncheckedCreateWithoutRequestInput> | BillCreateWithoutRequestInput[] | BillUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: BillCreateOrConnectWithoutRequestInput | BillCreateOrConnectWithoutRequestInput[]
    createMany?: BillCreateManyRequestInputEnvelope
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type UserUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsInput
    upsert?: UserUpsertWithoutRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestsInput, UserUpdateWithoutRequestsInput>, UserUncheckedUpdateWithoutRequestsInput>
  }

  export type UserUpdateOneWithoutSupportsNestedInput = {
    create?: XOR<UserCreateWithoutSupportsInput, UserUncheckedCreateWithoutSupportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportsInput
    upsert?: UserUpsertWithoutSupportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportsInput, UserUpdateWithoutSupportsInput>, UserUncheckedUpdateWithoutSupportsInput>
  }

  export type BillUpdateManyWithoutRequestNestedInput = {
    create?: XOR<BillCreateWithoutRequestInput, BillUncheckedCreateWithoutRequestInput> | BillCreateWithoutRequestInput[] | BillUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: BillCreateOrConnectWithoutRequestInput | BillCreateOrConnectWithoutRequestInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutRequestInput | BillUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: BillCreateManyRequestInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutRequestInput | BillUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: BillUpdateManyWithWhereWithoutRequestInput | BillUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type BillUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<BillCreateWithoutRequestInput, BillUncheckedCreateWithoutRequestInput> | BillCreateWithoutRequestInput[] | BillUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: BillCreateOrConnectWithoutRequestInput | BillCreateOrConnectWithoutRequestInput[]
    upsert?: BillUpsertWithWhereUniqueWithoutRequestInput | BillUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: BillCreateManyRequestInputEnvelope
    set?: BillWhereUniqueInput | BillWhereUniqueInput[]
    disconnect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    delete?: BillWhereUniqueInput | BillWhereUniqueInput[]
    connect?: BillWhereUniqueInput | BillWhereUniqueInput[]
    update?: BillUpdateWithWhereUniqueWithoutRequestInput | BillUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: BillUpdateManyWithWhereWithoutRequestInput | BillUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: BillScalarWhereInput | BillScalarWhereInput[]
  }

  export type SubaccountSplitCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<SubaccountSplitCreateWithoutSubaccountInput, SubaccountSplitUncheckedCreateWithoutSubaccountInput> | SubaccountSplitCreateWithoutSubaccountInput[] | SubaccountSplitUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSubaccountInput | SubaccountSplitCreateOrConnectWithoutSubaccountInput[]
    createMany?: SubaccountSplitCreateManySubaccountInputEnvelope
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
  }

  export type SubaccountSplitUncheckedCreateNestedManyWithoutSubaccountInput = {
    create?: XOR<SubaccountSplitCreateWithoutSubaccountInput, SubaccountSplitUncheckedCreateWithoutSubaccountInput> | SubaccountSplitCreateWithoutSubaccountInput[] | SubaccountSplitUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSubaccountInput | SubaccountSplitCreateOrConnectWithoutSubaccountInput[]
    createMany?: SubaccountSplitCreateManySubaccountInputEnvelope
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
  }

  export type SubaccountSplitUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<SubaccountSplitCreateWithoutSubaccountInput, SubaccountSplitUncheckedCreateWithoutSubaccountInput> | SubaccountSplitCreateWithoutSubaccountInput[] | SubaccountSplitUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSubaccountInput | SubaccountSplitCreateOrConnectWithoutSubaccountInput[]
    upsert?: SubaccountSplitUpsertWithWhereUniqueWithoutSubaccountInput | SubaccountSplitUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: SubaccountSplitCreateManySubaccountInputEnvelope
    set?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    disconnect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    delete?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    update?: SubaccountSplitUpdateWithWhereUniqueWithoutSubaccountInput | SubaccountSplitUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: SubaccountSplitUpdateManyWithWhereWithoutSubaccountInput | SubaccountSplitUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: SubaccountSplitScalarWhereInput | SubaccountSplitScalarWhereInput[]
  }

  export type SubaccountSplitUncheckedUpdateManyWithoutSubaccountNestedInput = {
    create?: XOR<SubaccountSplitCreateWithoutSubaccountInput, SubaccountSplitUncheckedCreateWithoutSubaccountInput> | SubaccountSplitCreateWithoutSubaccountInput[] | SubaccountSplitUncheckedCreateWithoutSubaccountInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSubaccountInput | SubaccountSplitCreateOrConnectWithoutSubaccountInput[]
    upsert?: SubaccountSplitUpsertWithWhereUniqueWithoutSubaccountInput | SubaccountSplitUpsertWithWhereUniqueWithoutSubaccountInput[]
    createMany?: SubaccountSplitCreateManySubaccountInputEnvelope
    set?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    disconnect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    delete?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    update?: SubaccountSplitUpdateWithWhereUniqueWithoutSubaccountInput | SubaccountSplitUpdateWithWhereUniqueWithoutSubaccountInput[]
    updateMany?: SubaccountSplitUpdateManyWithWhereWithoutSubaccountInput | SubaccountSplitUpdateManyWithWhereWithoutSubaccountInput[]
    deleteMany?: SubaccountSplitScalarWhereInput | SubaccountSplitScalarWhereInput[]
  }

  export type SubaccountCreateNestedOneWithoutSubaccountSplitsInput = {
    create?: XOR<SubaccountCreateWithoutSubaccountSplitsInput, SubaccountUncheckedCreateWithoutSubaccountSplitsInput>
    connectOrCreate?: SubaccountCreateOrConnectWithoutSubaccountSplitsInput
    connect?: SubaccountWhereUniqueInput
  }

  export type SplitGroupCreateNestedOneWithoutSubaccountsInput = {
    create?: XOR<SplitGroupCreateWithoutSubaccountsInput, SplitGroupUncheckedCreateWithoutSubaccountsInput>
    connectOrCreate?: SplitGroupCreateOrConnectWithoutSubaccountsInput
    connect?: SplitGroupWhereUniqueInput
  }

  export type SubaccountUpdateOneRequiredWithoutSubaccountSplitsNestedInput = {
    create?: XOR<SubaccountCreateWithoutSubaccountSplitsInput, SubaccountUncheckedCreateWithoutSubaccountSplitsInput>
    connectOrCreate?: SubaccountCreateOrConnectWithoutSubaccountSplitsInput
    upsert?: SubaccountUpsertWithoutSubaccountSplitsInput
    connect?: SubaccountWhereUniqueInput
    update?: XOR<XOR<SubaccountUpdateToOneWithWhereWithoutSubaccountSplitsInput, SubaccountUpdateWithoutSubaccountSplitsInput>, SubaccountUncheckedUpdateWithoutSubaccountSplitsInput>
  }

  export type SplitGroupUpdateOneRequiredWithoutSubaccountsNestedInput = {
    create?: XOR<SplitGroupCreateWithoutSubaccountsInput, SplitGroupUncheckedCreateWithoutSubaccountsInput>
    connectOrCreate?: SplitGroupCreateOrConnectWithoutSubaccountsInput
    upsert?: SplitGroupUpsertWithoutSubaccountsInput
    connect?: SplitGroupWhereUniqueInput
    update?: XOR<XOR<SplitGroupUpdateToOneWithWhereWithoutSubaccountsInput, SplitGroupUpdateWithoutSubaccountsInput>, SplitGroupUncheckedUpdateWithoutSubaccountsInput>
  }

  export type SubaccountSplitCreateNestedManyWithoutSplitGroupInput = {
    create?: XOR<SubaccountSplitCreateWithoutSplitGroupInput, SubaccountSplitUncheckedCreateWithoutSplitGroupInput> | SubaccountSplitCreateWithoutSplitGroupInput[] | SubaccountSplitUncheckedCreateWithoutSplitGroupInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSplitGroupInput | SubaccountSplitCreateOrConnectWithoutSplitGroupInput[]
    createMany?: SubaccountSplitCreateManySplitGroupInputEnvelope
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
  }

  export type SubaccountSplitUncheckedCreateNestedManyWithoutSplitGroupInput = {
    create?: XOR<SubaccountSplitCreateWithoutSplitGroupInput, SubaccountSplitUncheckedCreateWithoutSplitGroupInput> | SubaccountSplitCreateWithoutSplitGroupInput[] | SubaccountSplitUncheckedCreateWithoutSplitGroupInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSplitGroupInput | SubaccountSplitCreateOrConnectWithoutSplitGroupInput[]
    createMany?: SubaccountSplitCreateManySplitGroupInputEnvelope
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
  }

  export type SubaccountSplitUpdateManyWithoutSplitGroupNestedInput = {
    create?: XOR<SubaccountSplitCreateWithoutSplitGroupInput, SubaccountSplitUncheckedCreateWithoutSplitGroupInput> | SubaccountSplitCreateWithoutSplitGroupInput[] | SubaccountSplitUncheckedCreateWithoutSplitGroupInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSplitGroupInput | SubaccountSplitCreateOrConnectWithoutSplitGroupInput[]
    upsert?: SubaccountSplitUpsertWithWhereUniqueWithoutSplitGroupInput | SubaccountSplitUpsertWithWhereUniqueWithoutSplitGroupInput[]
    createMany?: SubaccountSplitCreateManySplitGroupInputEnvelope
    set?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    disconnect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    delete?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    update?: SubaccountSplitUpdateWithWhereUniqueWithoutSplitGroupInput | SubaccountSplitUpdateWithWhereUniqueWithoutSplitGroupInput[]
    updateMany?: SubaccountSplitUpdateManyWithWhereWithoutSplitGroupInput | SubaccountSplitUpdateManyWithWhereWithoutSplitGroupInput[]
    deleteMany?: SubaccountSplitScalarWhereInput | SubaccountSplitScalarWhereInput[]
  }

  export type SubaccountSplitUncheckedUpdateManyWithoutSplitGroupNestedInput = {
    create?: XOR<SubaccountSplitCreateWithoutSplitGroupInput, SubaccountSplitUncheckedCreateWithoutSplitGroupInput> | SubaccountSplitCreateWithoutSplitGroupInput[] | SubaccountSplitUncheckedCreateWithoutSplitGroupInput[]
    connectOrCreate?: SubaccountSplitCreateOrConnectWithoutSplitGroupInput | SubaccountSplitCreateOrConnectWithoutSplitGroupInput[]
    upsert?: SubaccountSplitUpsertWithWhereUniqueWithoutSplitGroupInput | SubaccountSplitUpsertWithWhereUniqueWithoutSplitGroupInput[]
    createMany?: SubaccountSplitCreateManySplitGroupInputEnvelope
    set?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    disconnect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    delete?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    connect?: SubaccountSplitWhereUniqueInput | SubaccountSplitWhereUniqueInput[]
    update?: SubaccountSplitUpdateWithWhereUniqueWithoutSplitGroupInput | SubaccountSplitUpdateWithWhereUniqueWithoutSplitGroupInput[]
    updateMany?: SubaccountSplitUpdateManyWithWhereWithoutSplitGroupInput | SubaccountSplitUpdateManyWithWhereWithoutSplitGroupInput[]
    deleteMany?: SubaccountSplitScalarWhereInput | SubaccountSplitScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutTransfersInput = {
    create?: XOR<BatchCreateWithoutTransfersInput, BatchUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: BatchCreateOrConnectWithoutTransfersInput
    connect?: BatchWhereUniqueInput
  }

  export type BatchUpdateOneWithoutTransfersNestedInput = {
    create?: XOR<BatchCreateWithoutTransfersInput, BatchUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: BatchCreateOrConnectWithoutTransfersInput
    upsert?: BatchUpsertWithoutTransfersInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutTransfersInput, BatchUpdateWithoutTransfersInput>, BatchUncheckedUpdateWithoutTransfersInput>
  }

  export type TransferCreateNestedManyWithoutBatchInput = {
    create?: XOR<TransferCreateWithoutBatchInput, TransferUncheckedCreateWithoutBatchInput> | TransferCreateWithoutBatchInput[] | TransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutBatchInput | TransferCreateOrConnectWithoutBatchInput[]
    createMany?: TransferCreateManyBatchInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type BulkTransferCreateNestedManyWithoutBatchInput = {
    create?: XOR<BulkTransferCreateWithoutBatchInput, BulkTransferUncheckedCreateWithoutBatchInput> | BulkTransferCreateWithoutBatchInput[] | BulkTransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BulkTransferCreateOrConnectWithoutBatchInput | BulkTransferCreateOrConnectWithoutBatchInput[]
    createMany?: BulkTransferCreateManyBatchInputEnvelope
    connect?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<TransferCreateWithoutBatchInput, TransferUncheckedCreateWithoutBatchInput> | TransferCreateWithoutBatchInput[] | TransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutBatchInput | TransferCreateOrConnectWithoutBatchInput[]
    createMany?: TransferCreateManyBatchInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type BulkTransferUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<BulkTransferCreateWithoutBatchInput, BulkTransferUncheckedCreateWithoutBatchInput> | BulkTransferCreateWithoutBatchInput[] | BulkTransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BulkTransferCreateOrConnectWithoutBatchInput | BulkTransferCreateOrConnectWithoutBatchInput[]
    createMany?: BulkTransferCreateManyBatchInputEnvelope
    connect?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
  }

  export type TransferUpdateManyWithoutBatchNestedInput = {
    create?: XOR<TransferCreateWithoutBatchInput, TransferUncheckedCreateWithoutBatchInput> | TransferCreateWithoutBatchInput[] | TransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutBatchInput | TransferCreateOrConnectWithoutBatchInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutBatchInput | TransferUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: TransferCreateManyBatchInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutBatchInput | TransferUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutBatchInput | TransferUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type BulkTransferUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BulkTransferCreateWithoutBatchInput, BulkTransferUncheckedCreateWithoutBatchInput> | BulkTransferCreateWithoutBatchInput[] | BulkTransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BulkTransferCreateOrConnectWithoutBatchInput | BulkTransferCreateOrConnectWithoutBatchInput[]
    upsert?: BulkTransferUpsertWithWhereUniqueWithoutBatchInput | BulkTransferUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BulkTransferCreateManyBatchInputEnvelope
    set?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    disconnect?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    delete?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    connect?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    update?: BulkTransferUpdateWithWhereUniqueWithoutBatchInput | BulkTransferUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BulkTransferUpdateManyWithWhereWithoutBatchInput | BulkTransferUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BulkTransferScalarWhereInput | BulkTransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<TransferCreateWithoutBatchInput, TransferUncheckedCreateWithoutBatchInput> | TransferCreateWithoutBatchInput[] | TransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutBatchInput | TransferCreateOrConnectWithoutBatchInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutBatchInput | TransferUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: TransferCreateManyBatchInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutBatchInput | TransferUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutBatchInput | TransferUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type BulkTransferUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BulkTransferCreateWithoutBatchInput, BulkTransferUncheckedCreateWithoutBatchInput> | BulkTransferCreateWithoutBatchInput[] | BulkTransferUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BulkTransferCreateOrConnectWithoutBatchInput | BulkTransferCreateOrConnectWithoutBatchInput[]
    upsert?: BulkTransferUpsertWithWhereUniqueWithoutBatchInput | BulkTransferUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BulkTransferCreateManyBatchInputEnvelope
    set?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    disconnect?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    delete?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    connect?: BulkTransferWhereUniqueInput | BulkTransferWhereUniqueInput[]
    update?: BulkTransferUpdateWithWhereUniqueWithoutBatchInput | BulkTransferUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BulkTransferUpdateManyWithWhereWithoutBatchInput | BulkTransferUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BulkTransferScalarWhereInput | BulkTransferScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutBulkTransfersInput = {
    create?: XOR<BatchCreateWithoutBulkTransfersInput, BatchUncheckedCreateWithoutBulkTransfersInput>
    connectOrCreate?: BatchCreateOrConnectWithoutBulkTransfersInput
    connect?: BatchWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BatchUpdateOneRequiredWithoutBulkTransfersNestedInput = {
    create?: XOR<BatchCreateWithoutBulkTransfersInput, BatchUncheckedCreateWithoutBulkTransfersInput>
    connectOrCreate?: BatchCreateOrConnectWithoutBulkTransfersInput
    upsert?: BatchUpsertWithoutBulkTransfersInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutBulkTransfersInput, BatchUpdateWithoutBulkTransfersInput>, BatchUncheckedUpdateWithoutBulkTransfersInput>
  }

  export type UserCreateNestedOneWithoutCryptoWalletInput = {
    create?: XOR<UserCreateWithoutCryptoWalletInput, UserUncheckedCreateWithoutCryptoWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoWalletInput
    connect?: UserWhereUniqueInput
  }

  export type BlockchainTransactionCreateNestedManyWithoutCryptoWalletInput = {
    create?: XOR<BlockchainTransactionCreateWithoutCryptoWalletInput, BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput> | BlockchainTransactionCreateWithoutCryptoWalletInput[] | BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput | BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput[]
    createMany?: BlockchainTransactionCreateManyCryptoWalletInputEnvelope
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
  }

  export type BlockchainTransactionUncheckedCreateNestedManyWithoutCryptoWalletInput = {
    create?: XOR<BlockchainTransactionCreateWithoutCryptoWalletInput, BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput> | BlockchainTransactionCreateWithoutCryptoWalletInput[] | BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput | BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput[]
    createMany?: BlockchainTransactionCreateManyCryptoWalletInputEnvelope
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCryptoWalletNestedInput = {
    create?: XOR<UserCreateWithoutCryptoWalletInput, UserUncheckedCreateWithoutCryptoWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoWalletInput
    upsert?: UserUpsertWithoutCryptoWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCryptoWalletInput, UserUpdateWithoutCryptoWalletInput>, UserUncheckedUpdateWithoutCryptoWalletInput>
  }

  export type BlockchainTransactionUpdateManyWithoutCryptoWalletNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutCryptoWalletInput, BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput> | BlockchainTransactionCreateWithoutCryptoWalletInput[] | BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput | BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput[]
    upsert?: BlockchainTransactionUpsertWithWhereUniqueWithoutCryptoWalletInput | BlockchainTransactionUpsertWithWhereUniqueWithoutCryptoWalletInput[]
    createMany?: BlockchainTransactionCreateManyCryptoWalletInputEnvelope
    set?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    disconnect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    delete?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    update?: BlockchainTransactionUpdateWithWhereUniqueWithoutCryptoWalletInput | BlockchainTransactionUpdateWithWhereUniqueWithoutCryptoWalletInput[]
    updateMany?: BlockchainTransactionUpdateManyWithWhereWithoutCryptoWalletInput | BlockchainTransactionUpdateManyWithWhereWithoutCryptoWalletInput[]
    deleteMany?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutCryptoWalletNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutCryptoWalletInput, BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput> | BlockchainTransactionCreateWithoutCryptoWalletInput[] | BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput | BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput[]
    upsert?: BlockchainTransactionUpsertWithWhereUniqueWithoutCryptoWalletInput | BlockchainTransactionUpsertWithWhereUniqueWithoutCryptoWalletInput[]
    createMany?: BlockchainTransactionCreateManyCryptoWalletInputEnvelope
    set?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    disconnect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    delete?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    update?: BlockchainTransactionUpdateWithWhereUniqueWithoutCryptoWalletInput | BlockchainTransactionUpdateWithWhereUniqueWithoutCryptoWalletInput[]
    updateMany?: BlockchainTransactionUpdateManyWithWhereWithoutCryptoWalletInput | BlockchainTransactionUpdateManyWithWhereWithoutCryptoWalletInput[]
    deleteMany?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
  }

  export type BillCreateNestedOneWithoutBlockchainRequestInput = {
    create?: XOR<BillCreateWithoutBlockchainRequestInput, BillUncheckedCreateWithoutBlockchainRequestInput>
    connectOrCreate?: BillCreateOrConnectWithoutBlockchainRequestInput
    connect?: BillWhereUniqueInput
  }

  export type BlockchainTransactionCreateNestedManyWithoutBlockchainRequestInput = {
    create?: XOR<BlockchainTransactionCreateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput> | BlockchainTransactionCreateWithoutBlockchainRequestInput[] | BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput | BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput[]
    createMany?: BlockchainTransactionCreateManyBlockchainRequestInputEnvelope
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
  }

  export type BlockchainTransactionUncheckedCreateNestedManyWithoutBlockchainRequestInput = {
    create?: XOR<BlockchainTransactionCreateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput> | BlockchainTransactionCreateWithoutBlockchainRequestInput[] | BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput | BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput[]
    createMany?: BlockchainTransactionCreateManyBlockchainRequestInputEnvelope
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
  }

  export type EnumBlockchainTxStatusFieldUpdateOperationsInput = {
    set?: $Enums.BlockchainTxStatus
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type BillUpdateOneRequiredWithoutBlockchainRequestNestedInput = {
    create?: XOR<BillCreateWithoutBlockchainRequestInput, BillUncheckedCreateWithoutBlockchainRequestInput>
    connectOrCreate?: BillCreateOrConnectWithoutBlockchainRequestInput
    upsert?: BillUpsertWithoutBlockchainRequestInput
    connect?: BillWhereUniqueInput
    update?: XOR<XOR<BillUpdateToOneWithWhereWithoutBlockchainRequestInput, BillUpdateWithoutBlockchainRequestInput>, BillUncheckedUpdateWithoutBlockchainRequestInput>
  }

  export type BlockchainTransactionUpdateManyWithoutBlockchainRequestNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput> | BlockchainTransactionCreateWithoutBlockchainRequestInput[] | BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput | BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput[]
    upsert?: BlockchainTransactionUpsertWithWhereUniqueWithoutBlockchainRequestInput | BlockchainTransactionUpsertWithWhereUniqueWithoutBlockchainRequestInput[]
    createMany?: BlockchainTransactionCreateManyBlockchainRequestInputEnvelope
    set?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    disconnect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    delete?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    update?: BlockchainTransactionUpdateWithWhereUniqueWithoutBlockchainRequestInput | BlockchainTransactionUpdateWithWhereUniqueWithoutBlockchainRequestInput[]
    updateMany?: BlockchainTransactionUpdateManyWithWhereWithoutBlockchainRequestInput | BlockchainTransactionUpdateManyWithWhereWithoutBlockchainRequestInput[]
    deleteMany?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutBlockchainRequestNestedInput = {
    create?: XOR<BlockchainTransactionCreateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput> | BlockchainTransactionCreateWithoutBlockchainRequestInput[] | BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput[]
    connectOrCreate?: BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput | BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput[]
    upsert?: BlockchainTransactionUpsertWithWhereUniqueWithoutBlockchainRequestInput | BlockchainTransactionUpsertWithWhereUniqueWithoutBlockchainRequestInput[]
    createMany?: BlockchainTransactionCreateManyBlockchainRequestInputEnvelope
    set?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    disconnect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    delete?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    connect?: BlockchainTransactionWhereUniqueInput | BlockchainTransactionWhereUniqueInput[]
    update?: BlockchainTransactionUpdateWithWhereUniqueWithoutBlockchainRequestInput | BlockchainTransactionUpdateWithWhereUniqueWithoutBlockchainRequestInput[]
    updateMany?: BlockchainTransactionUpdateManyWithWhereWithoutBlockchainRequestInput | BlockchainTransactionUpdateManyWithWhereWithoutBlockchainRequestInput[]
    deleteMany?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
  }

  export type CryptoWalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CryptoWalletCreateWithoutTransactionsInput, CryptoWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutTransactionsInput
    connect?: CryptoWalletWhereUniqueInput
  }

  export type BlockchainRequestCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BlockchainRequestCreateWithoutTransactionsInput, BlockchainRequestUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BlockchainRequestCreateOrConnectWithoutTransactionsInput
    connect?: BlockchainRequestWhereUniqueInput
  }

  export type CryptoWalletUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CryptoWalletCreateWithoutTransactionsInput, CryptoWalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CryptoWalletCreateOrConnectWithoutTransactionsInput
    upsert?: CryptoWalletUpsertWithoutTransactionsInput
    connect?: CryptoWalletWhereUniqueInput
    update?: XOR<XOR<CryptoWalletUpdateToOneWithWhereWithoutTransactionsInput, CryptoWalletUpdateWithoutTransactionsInput>, CryptoWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type BlockchainRequestUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<BlockchainRequestCreateWithoutTransactionsInput, BlockchainRequestUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BlockchainRequestCreateOrConnectWithoutTransactionsInput
    upsert?: BlockchainRequestUpsertWithoutTransactionsInput
    disconnect?: BlockchainRequestWhereInput | boolean
    delete?: BlockchainRequestWhereInput | boolean
    connect?: BlockchainRequestWhereUniqueInput
    update?: XOR<XOR<BlockchainRequestUpdateToOneWithWhereWithoutTransactionsInput, BlockchainRequestUpdateWithoutTransactionsInput>, BlockchainRequestUncheckedUpdateWithoutTransactionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumBillStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusFilter<$PrismaModel> | $Enums.BillStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumBillStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillStatus | EnumBillStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillStatus[] | ListEnumBillStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillStatusFilter<$PrismaModel>
    _max?: NestedEnumBillStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumBlockchainTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockchainTxStatus | EnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockchainTxStatusFilter<$PrismaModel> | $Enums.BlockchainTxStatus
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumBlockchainTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlockchainTxStatus | EnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlockchainTxStatus[] | ListEnumBlockchainTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlockchainTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlockchainTxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlockchainTxStatusFilter<$PrismaModel>
    _max?: NestedEnumBlockchainTxStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type BillCreateWithoutUserInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: ProviderCreateNestedOneWithoutBillsInput
    request?: RequestCreateNestedOneWithoutBillsInput
    sponsors?: UserCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutUserInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    providerId?: string | null
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sponsors?: UserUncheckedCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestUncheckedCreateNestedOneWithoutBillInput
  }

  export type BillCreateOrConnectWithoutUserInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput>
  }

  export type BillCreateManyUserInputEnvelope = {
    data: BillCreateManyUserInput | BillCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutRequesterInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supporter?: UserCreateNestedOneWithoutSupportsInput
    bills?: BillCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    supporterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutRequesterInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput>
  }

  export type RequestCreateManyRequesterInputEnvelope = {
    data: RequestCreateManyRequesterInput | RequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutSupporterInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutRequestsInput
    bills?: BillCreateNestedManyWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutSupporterInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    requesterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutSupporterInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutSupporterInput, RequestUncheckedCreateWithoutSupporterInput>
  }

  export type RequestCreateManySupporterInputEnvelope = {
    data: RequestCreateManySupporterInput | RequestCreateManySupporterInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    balance?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    balance?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type CryptoWalletCreateWithoutUserInput = {
    id?: string
    address: string
    u2kBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BlockchainTransactionCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletUncheckedCreateWithoutUserInput = {
    id?: string
    address: string
    u2kBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutCryptoWalletInput
  }

  export type CryptoWalletCreateOrConnectWithoutUserInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
  }

  export type BillCreateWithoutSponsorsInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillsInput
    provider?: ProviderCreateNestedOneWithoutBillsInput
    request?: RequestCreateNestedOneWithoutBillsInput
    transactions?: TransactionCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutSponsorsInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    providerId?: string | null
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestUncheckedCreateNestedOneWithoutBillInput
  }

  export type BillCreateOrConnectWithoutSponsorsInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutSponsorsInput, BillUncheckedCreateWithoutSponsorsInput>
  }

  export type BillUpsertWithWhereUniqueWithoutUserInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutUserInput, BillUncheckedUpdateWithoutUserInput>
    create: XOR<BillCreateWithoutUserInput, BillUncheckedCreateWithoutUserInput>
  }

  export type BillUpdateWithWhereUniqueWithoutUserInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutUserInput, BillUncheckedUpdateWithoutUserInput>
  }

  export type BillUpdateManyWithWhereWithoutUserInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutUserInput>
  }

  export type BillScalarWhereInput = {
    AND?: BillScalarWhereInput | BillScalarWhereInput[]
    OR?: BillScalarWhereInput[]
    NOT?: BillScalarWhereInput | BillScalarWhereInput[]
    id?: StringFilter<"Bill"> | string
    billName?: StringFilter<"Bill"> | string
    description?: StringFilter<"Bill"> | string
    type?: StringFilter<"Bill"> | string
    note?: StringNullableFilter<"Bill"> | string | null
    amount?: FloatFilter<"Bill"> | number
    priority?: EnumPriorityFilter<"Bill"> | $Enums.Priority
    status?: EnumBillStatusFilter<"Bill"> | $Enums.BillStatus
    category?: StringNullableFilter<"Bill"> | string | null
    dueDate?: DateTimeNullableFilter<"Bill"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Bill"> | string | null
    userId?: StringFilter<"Bill"> | string
    providerId?: StringNullableFilter<"Bill"> | string | null
    requestId?: StringNullableFilter<"Bill"> | string | null
    createdAt?: DateTimeFilter<"Bill"> | Date | string
    updatedAt?: DateTimeFilter<"Bill"> | Date | string
  }

  export type RequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutRequesterInput, RequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<RequestCreateWithoutRequesterInput, RequestUncheckedCreateWithoutRequesterInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutRequesterInput, RequestUncheckedUpdateWithoutRequesterInput>
  }

  export type RequestUpdateManyWithWhereWithoutRequesterInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type RequestScalarWhereInput = {
    AND?: RequestScalarWhereInput | RequestScalarWhereInput[]
    OR?: RequestScalarWhereInput[]
    NOT?: RequestScalarWhereInput | RequestScalarWhereInput[]
    id?: StringFilter<"Request"> | string
    name?: StringFilter<"Request"> | string
    notes?: StringNullableFilter<"Request"> | string | null
    status?: EnumRequestStatusFilter<"Request"> | $Enums.RequestStatus
    feedback?: StringNullableFilter<"Request"> | string | null
    publicLinkId?: StringFilter<"Request"> | string
    requesterId?: StringFilter<"Request"> | string
    supporterId?: StringNullableFilter<"Request"> | string | null
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
  }

  export type RequestUpsertWithWhereUniqueWithoutSupporterInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutSupporterInput, RequestUncheckedUpdateWithoutSupporterInput>
    create: XOR<RequestCreateWithoutSupporterInput, RequestUncheckedCreateWithoutSupporterInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutSupporterInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutSupporterInput, RequestUncheckedUpdateWithoutSupporterInput>
  }

  export type RequestUpdateManyWithWhereWithoutSupporterInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutSupporterInput>
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoWalletUpsertWithoutUserInput = {
    update: XOR<CryptoWalletUpdateWithoutUserInput, CryptoWalletUncheckedUpdateWithoutUserInput>
    create: XOR<CryptoWalletCreateWithoutUserInput, CryptoWalletUncheckedCreateWithoutUserInput>
    where?: CryptoWalletWhereInput
  }

  export type CryptoWalletUpdateToOneWithWhereWithoutUserInput = {
    where?: CryptoWalletWhereInput
    data: XOR<CryptoWalletUpdateWithoutUserInput, CryptoWalletUncheckedUpdateWithoutUserInput>
  }

  export type CryptoWalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BlockchainTransactionUpdateManyWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BlockchainTransactionUncheckedUpdateManyWithoutCryptoWalletNestedInput
  }

  export type BillUpsertWithWhereUniqueWithoutSponsorsInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutSponsorsInput, BillUncheckedUpdateWithoutSponsorsInput>
    create: XOR<BillCreateWithoutSponsorsInput, BillUncheckedCreateWithoutSponsorsInput>
  }

  export type BillUpdateWithWhereUniqueWithoutSponsorsInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutSponsorsInput, BillUncheckedUpdateWithoutSponsorsInput>
  }

  export type BillUpdateManyWithWhereWithoutSponsorsInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutSponsorsInput>
  }

  export type BillCreateWithoutProviderInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillsInput
    request?: RequestCreateNestedOneWithoutBillsInput
    sponsors?: UserCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutProviderInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sponsors?: UserUncheckedCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestUncheckedCreateNestedOneWithoutBillInput
  }

  export type BillCreateOrConnectWithoutProviderInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutProviderInput, BillUncheckedCreateWithoutProviderInput>
  }

  export type BillCreateManyProviderInputEnvelope = {
    data: BillCreateManyProviderInput | BillCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type BillUpsertWithWhereUniqueWithoutProviderInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutProviderInput, BillUncheckedUpdateWithoutProviderInput>
    create: XOR<BillCreateWithoutProviderInput, BillUncheckedCreateWithoutProviderInput>
  }

  export type BillUpdateWithWhereUniqueWithoutProviderInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutProviderInput, BillUncheckedUpdateWithoutProviderInput>
  }

  export type BillUpdateManyWithWhereWithoutProviderInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutProviderInput>
  }

  export type UserCreateWithoutBillsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: RequestCreateNestedManyWithoutRequesterInput
    supports?: RequestCreateNestedManyWithoutSupporterInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutUserInput
    sponsoredBills?: BillCreateNestedManyWithoutSponsorsInput
  }

  export type UserUncheckedCreateWithoutBillsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    supports?: RequestUncheckedCreateNestedManyWithoutSupporterInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletUncheckedCreateNestedOneWithoutUserInput
    sponsoredBills?: BillUncheckedCreateNestedManyWithoutSponsorsInput
  }

  export type UserCreateOrConnectWithoutBillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
  }

  export type ProviderCreateWithoutBillsInput = {
    id?: string
    name: string
    email?: string | null
    accountNumber?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderUncheckedCreateWithoutBillsInput = {
    id?: string
    name: string
    email?: string | null
    accountNumber?: string | null
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderCreateOrConnectWithoutBillsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutBillsInput, ProviderUncheckedCreateWithoutBillsInput>
  }

  export type RequestCreateWithoutBillsInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutRequestsInput
    supporter?: UserCreateNestedOneWithoutSupportsInput
  }

  export type RequestUncheckedCreateWithoutBillsInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    requesterId: string
    supporterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateOrConnectWithoutBillsInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutBillsInput, RequestUncheckedCreateWithoutBillsInput>
  }

  export type UserCreateWithoutSponsoredBillsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutUserInput
    requests?: RequestCreateNestedManyWithoutRequesterInput
    supports?: RequestCreateNestedManyWithoutSupporterInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSponsoredBillsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    requests?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    supports?: RequestUncheckedCreateNestedManyWithoutSupporterInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSponsoredBillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSponsoredBillsInput, UserUncheckedCreateWithoutSponsoredBillsInput>
  }

  export type TransactionCreateWithoutBillInput = {
    id?: string
    amount: number
    status?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutBillInput = {
    id?: string
    amount: number
    status?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutBillInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput>
  }

  export type TransactionCreateManyBillInputEnvelope = {
    data: TransactionCreateManyBillInput | TransactionCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type BlockchainRequestCreateWithoutBillInput = {
    id?: string
    blockchainBillId?: string | null
    transactionHash?: string | null
    status?: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType?: $Enums.PaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BlockchainTransactionCreateNestedManyWithoutBlockchainRequestInput
  }

  export type BlockchainRequestUncheckedCreateWithoutBillInput = {
    id?: string
    blockchainBillId?: string | null
    transactionHash?: string | null
    status?: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType?: $Enums.PaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: BlockchainTransactionUncheckedCreateNestedManyWithoutBlockchainRequestInput
  }

  export type BlockchainRequestCreateOrConnectWithoutBillInput = {
    where: BlockchainRequestWhereUniqueInput
    create: XOR<BlockchainRequestCreateWithoutBillInput, BlockchainRequestUncheckedCreateWithoutBillInput>
  }

  export type UserUpsertWithoutBillsInput = {
    update: XOR<UserUpdateWithoutBillsInput, UserUncheckedUpdateWithoutBillsInput>
    create: XOR<UserCreateWithoutBillsInput, UserUncheckedCreateWithoutBillsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBillsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBillsInput, UserUncheckedUpdateWithoutBillsInput>
  }

  export type UserUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: RequestUpdateManyWithoutRequesterNestedInput
    supports?: RequestUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUpdateManyWithoutSponsorsNestedInput
  }

  export type UserUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    supports?: RequestUncheckedUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUncheckedUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUncheckedUpdateManyWithoutSponsorsNestedInput
  }

  export type ProviderUpsertWithoutBillsInput = {
    update: XOR<ProviderUpdateWithoutBillsInput, ProviderUncheckedUpdateWithoutBillsInput>
    create: XOR<ProviderCreateWithoutBillsInput, ProviderUncheckedCreateWithoutBillsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutBillsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutBillsInput, ProviderUncheckedUpdateWithoutBillsInput>
  }

  export type ProviderUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUpsertWithoutBillsInput = {
    update: XOR<RequestUpdateWithoutBillsInput, RequestUncheckedUpdateWithoutBillsInput>
    create: XOR<RequestCreateWithoutBillsInput, RequestUncheckedCreateWithoutBillsInput>
    where?: RequestWhereInput
  }

  export type RequestUpdateToOneWithWhereWithoutBillsInput = {
    where?: RequestWhereInput
    data: XOR<RequestUpdateWithoutBillsInput, RequestUncheckedUpdateWithoutBillsInput>
  }

  export type RequestUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutRequestsNestedInput
    supporter?: UserUpdateOneWithoutSupportsNestedInput
  }

  export type RequestUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    supporterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutSponsoredBillsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSponsoredBillsInput, UserUncheckedUpdateWithoutSponsoredBillsInput>
    create: XOR<UserCreateWithoutSponsoredBillsInput, UserUncheckedCreateWithoutSponsoredBillsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSponsoredBillsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSponsoredBillsInput, UserUncheckedUpdateWithoutSponsoredBillsInput>
  }

  export type UserUpdateManyWithWhereWithoutSponsoredBillsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSponsoredBillsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutBillInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBillInput, TransactionUncheckedUpdateWithoutBillInput>
    create: XOR<TransactionCreateWithoutBillInput, TransactionUncheckedCreateWithoutBillInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBillInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBillInput, TransactionUncheckedUpdateWithoutBillInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBillInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBillInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    billId?: StringFilter<"Transaction"> | string
    reference?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type BlockchainRequestUpsertWithoutBillInput = {
    update: XOR<BlockchainRequestUpdateWithoutBillInput, BlockchainRequestUncheckedUpdateWithoutBillInput>
    create: XOR<BlockchainRequestCreateWithoutBillInput, BlockchainRequestUncheckedCreateWithoutBillInput>
    where?: BlockchainRequestWhereInput
  }

  export type BlockchainRequestUpdateToOneWithWhereWithoutBillInput = {
    where?: BlockchainRequestWhereInput
    data: XOR<BlockchainRequestUpdateWithoutBillInput, BlockchainRequestUncheckedUpdateWithoutBillInput>
  }

  export type BlockchainRequestUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BlockchainTransactionUpdateManyWithoutBlockchainRequestNestedInput
  }

  export type BlockchainRequestUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BlockchainTransactionUncheckedUpdateManyWithoutBlockchainRequestNestedInput
  }

  export type BillCreateWithoutTransactionsInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillsInput
    provider?: ProviderCreateNestedOneWithoutBillsInput
    request?: RequestCreateNestedOneWithoutBillsInput
    sponsors?: UserCreateNestedManyWithoutSponsoredBillsInput
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutTransactionsInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    providerId?: string | null
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sponsors?: UserUncheckedCreateNestedManyWithoutSponsoredBillsInput
    blockchainRequest?: BlockchainRequestUncheckedCreateNestedOneWithoutBillInput
  }

  export type BillCreateOrConnectWithoutTransactionsInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutTransactionsInput, BillUncheckedCreateWithoutTransactionsInput>
  }

  export type BillUpsertWithoutTransactionsInput = {
    update: XOR<BillUpdateWithoutTransactionsInput, BillUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BillCreateWithoutTransactionsInput, BillUncheckedCreateWithoutTransactionsInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutTransactionsInput, BillUncheckedUpdateWithoutTransactionsInput>
  }

  export type BillUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillsNestedInput
    provider?: ProviderUpdateOneWithoutBillsNestedInput
    request?: RequestUpdateOneWithoutBillsNestedInput
    sponsors?: UserUpdateManyWithoutSponsoredBillsNestedInput
    blockchainRequest?: BlockchainRequestUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsors?: UserUncheckedUpdateManyWithoutSponsoredBillsNestedInput
    blockchainRequest?: BlockchainRequestUncheckedUpdateOneWithoutBillNestedInput
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutUserInput
    requests?: RequestCreateNestedManyWithoutRequesterInput
    supports?: RequestCreateNestedManyWithoutSupporterInput
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutUserInput
    sponsoredBills?: BillCreateNestedManyWithoutSponsorsInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    requests?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    supports?: RequestUncheckedCreateNestedManyWithoutSupporterInput
    cryptoWallet?: CryptoWalletUncheckedCreateNestedOneWithoutUserInput
    sponsoredBills?: BillUncheckedCreateNestedManyWithoutSponsorsInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutUserNestedInput
    requests?: RequestUpdateManyWithoutRequesterNestedInput
    supports?: RequestUpdateManyWithoutSupporterNestedInput
    cryptoWallet?: CryptoWalletUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUpdateManyWithoutSponsorsNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    supports?: RequestUncheckedUpdateManyWithoutSupporterNestedInput
    cryptoWallet?: CryptoWalletUncheckedUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUncheckedUpdateManyWithoutSponsorsNestedInput
  }

  export type UserCreateWithoutRequestsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutUserInput
    supports?: RequestCreateNestedManyWithoutSupporterInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutUserInput
    sponsoredBills?: BillCreateNestedManyWithoutSponsorsInput
  }

  export type UserUncheckedCreateWithoutRequestsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    supports?: RequestUncheckedCreateNestedManyWithoutSupporterInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletUncheckedCreateNestedOneWithoutUserInput
    sponsoredBills?: BillUncheckedCreateNestedManyWithoutSponsorsInput
  }

  export type UserCreateOrConnectWithoutRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
  }

  export type UserCreateWithoutSupportsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutUserInput
    requests?: RequestCreateNestedManyWithoutRequesterInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletCreateNestedOneWithoutUserInput
    sponsoredBills?: BillCreateNestedManyWithoutSponsorsInput
  }

  export type UserUncheckedCreateWithoutSupportsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    requests?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    cryptoWallet?: CryptoWalletUncheckedCreateNestedOneWithoutUserInput
    sponsoredBills?: BillUncheckedCreateNestedManyWithoutSponsorsInput
  }

  export type UserCreateOrConnectWithoutSupportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportsInput, UserUncheckedCreateWithoutSupportsInput>
  }

  export type BillCreateWithoutRequestInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillsInput
    provider?: ProviderCreateNestedOneWithoutBillsInput
    sponsors?: UserCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutBillInput
  }

  export type BillUncheckedCreateWithoutRequestInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sponsors?: UserUncheckedCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBillInput
    blockchainRequest?: BlockchainRequestUncheckedCreateNestedOneWithoutBillInput
  }

  export type BillCreateOrConnectWithoutRequestInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutRequestInput, BillUncheckedCreateWithoutRequestInput>
  }

  export type BillCreateManyRequestInputEnvelope = {
    data: BillCreateManyRequestInput | BillCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRequestsInput = {
    update: XOR<UserUpdateWithoutRequestsInput, UserUncheckedUpdateWithoutRequestsInput>
    create: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestsInput, UserUncheckedUpdateWithoutRequestsInput>
  }

  export type UserUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutUserNestedInput
    supports?: RequestUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUpdateManyWithoutSponsorsNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    supports?: RequestUncheckedUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUncheckedUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUncheckedUpdateManyWithoutSponsorsNestedInput
  }

  export type UserUpsertWithoutSupportsInput = {
    update: XOR<UserUpdateWithoutSupportsInput, UserUncheckedUpdateWithoutSupportsInput>
    create: XOR<UserCreateWithoutSupportsInput, UserUncheckedCreateWithoutSupportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportsInput, UserUncheckedUpdateWithoutSupportsInput>
  }

  export type UserUpdateWithoutSupportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutUserNestedInput
    requests?: RequestUpdateManyWithoutRequesterNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUpdateManyWithoutSponsorsNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUncheckedUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUncheckedUpdateManyWithoutSponsorsNestedInput
  }

  export type BillUpsertWithWhereUniqueWithoutRequestInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutRequestInput, BillUncheckedUpdateWithoutRequestInput>
    create: XOR<BillCreateWithoutRequestInput, BillUncheckedCreateWithoutRequestInput>
  }

  export type BillUpdateWithWhereUniqueWithoutRequestInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutRequestInput, BillUncheckedUpdateWithoutRequestInput>
  }

  export type BillUpdateManyWithWhereWithoutRequestInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutRequestInput>
  }

  export type SubaccountSplitCreateWithoutSubaccountInput = {
    id?: string
    share: number
    splitGroup: SplitGroupCreateNestedOneWithoutSubaccountsInput
  }

  export type SubaccountSplitUncheckedCreateWithoutSubaccountInput = {
    id?: string
    splitGroupId: string
    share: number
  }

  export type SubaccountSplitCreateOrConnectWithoutSubaccountInput = {
    where: SubaccountSplitWhereUniqueInput
    create: XOR<SubaccountSplitCreateWithoutSubaccountInput, SubaccountSplitUncheckedCreateWithoutSubaccountInput>
  }

  export type SubaccountSplitCreateManySubaccountInputEnvelope = {
    data: SubaccountSplitCreateManySubaccountInput | SubaccountSplitCreateManySubaccountInput[]
    skipDuplicates?: boolean
  }

  export type SubaccountSplitUpsertWithWhereUniqueWithoutSubaccountInput = {
    where: SubaccountSplitWhereUniqueInput
    update: XOR<SubaccountSplitUpdateWithoutSubaccountInput, SubaccountSplitUncheckedUpdateWithoutSubaccountInput>
    create: XOR<SubaccountSplitCreateWithoutSubaccountInput, SubaccountSplitUncheckedCreateWithoutSubaccountInput>
  }

  export type SubaccountSplitUpdateWithWhereUniqueWithoutSubaccountInput = {
    where: SubaccountSplitWhereUniqueInput
    data: XOR<SubaccountSplitUpdateWithoutSubaccountInput, SubaccountSplitUncheckedUpdateWithoutSubaccountInput>
  }

  export type SubaccountSplitUpdateManyWithWhereWithoutSubaccountInput = {
    where: SubaccountSplitScalarWhereInput
    data: XOR<SubaccountSplitUpdateManyMutationInput, SubaccountSplitUncheckedUpdateManyWithoutSubaccountInput>
  }

  export type SubaccountSplitScalarWhereInput = {
    AND?: SubaccountSplitScalarWhereInput | SubaccountSplitScalarWhereInput[]
    OR?: SubaccountSplitScalarWhereInput[]
    NOT?: SubaccountSplitScalarWhereInput | SubaccountSplitScalarWhereInput[]
    id?: StringFilter<"SubaccountSplit"> | string
    subaccountId?: StringFilter<"SubaccountSplit"> | string
    splitGroupId?: StringFilter<"SubaccountSplit"> | string
    share?: FloatFilter<"SubaccountSplit"> | number
  }

  export type SubaccountCreateWithoutSubaccountSplitsInput = {
    id?: string
    businessName: string
    bankCode: string
    accountNumber: string
    percentageCharge: number
    subaccountCode: string
    createdAt?: Date | string
    lastPaidAt?: Date | string | null
  }

  export type SubaccountUncheckedCreateWithoutSubaccountSplitsInput = {
    id?: string
    businessName: string
    bankCode: string
    accountNumber: string
    percentageCharge: number
    subaccountCode: string
    createdAt?: Date | string
    lastPaidAt?: Date | string | null
  }

  export type SubaccountCreateOrConnectWithoutSubaccountSplitsInput = {
    where: SubaccountWhereUniqueInput
    create: XOR<SubaccountCreateWithoutSubaccountSplitsInput, SubaccountUncheckedCreateWithoutSubaccountSplitsInput>
  }

  export type SplitGroupCreateWithoutSubaccountsInput = {
    id?: string
    name: string
    type: string
    currency: string
    splitCode: string
    bearerType?: string | null
    bearerSubaccount: string
    createdAt?: Date | string
  }

  export type SplitGroupUncheckedCreateWithoutSubaccountsInput = {
    id?: string
    name: string
    type: string
    currency: string
    splitCode: string
    bearerType?: string | null
    bearerSubaccount: string
    createdAt?: Date | string
  }

  export type SplitGroupCreateOrConnectWithoutSubaccountsInput = {
    where: SplitGroupWhereUniqueInput
    create: XOR<SplitGroupCreateWithoutSubaccountsInput, SplitGroupUncheckedCreateWithoutSubaccountsInput>
  }

  export type SubaccountUpsertWithoutSubaccountSplitsInput = {
    update: XOR<SubaccountUpdateWithoutSubaccountSplitsInput, SubaccountUncheckedUpdateWithoutSubaccountSplitsInput>
    create: XOR<SubaccountCreateWithoutSubaccountSplitsInput, SubaccountUncheckedCreateWithoutSubaccountSplitsInput>
    where?: SubaccountWhereInput
  }

  export type SubaccountUpdateToOneWithWhereWithoutSubaccountSplitsInput = {
    where?: SubaccountWhereInput
    data: XOR<SubaccountUpdateWithoutSubaccountSplitsInput, SubaccountUncheckedUpdateWithoutSubaccountSplitsInput>
  }

  export type SubaccountUpdateWithoutSubaccountSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    percentageCharge?: FloatFieldUpdateOperationsInput | number
    subaccountCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubaccountUncheckedUpdateWithoutSubaccountSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    percentageCharge?: FloatFieldUpdateOperationsInput | number
    subaccountCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SplitGroupUpsertWithoutSubaccountsInput = {
    update: XOR<SplitGroupUpdateWithoutSubaccountsInput, SplitGroupUncheckedUpdateWithoutSubaccountsInput>
    create: XOR<SplitGroupCreateWithoutSubaccountsInput, SplitGroupUncheckedCreateWithoutSubaccountsInput>
    where?: SplitGroupWhereInput
  }

  export type SplitGroupUpdateToOneWithWhereWithoutSubaccountsInput = {
    where?: SplitGroupWhereInput
    data: XOR<SplitGroupUpdateWithoutSubaccountsInput, SplitGroupUncheckedUpdateWithoutSubaccountsInput>
  }

  export type SplitGroupUpdateWithoutSubaccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    splitCode?: StringFieldUpdateOperationsInput | string
    bearerType?: NullableStringFieldUpdateOperationsInput | string | null
    bearerSubaccount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SplitGroupUncheckedUpdateWithoutSubaccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    splitCode?: StringFieldUpdateOperationsInput | string
    bearerType?: NullableStringFieldUpdateOperationsInput | string | null
    bearerSubaccount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubaccountSplitCreateWithoutSplitGroupInput = {
    id?: string
    share: number
    subaccount: SubaccountCreateNestedOneWithoutSubaccountSplitsInput
  }

  export type SubaccountSplitUncheckedCreateWithoutSplitGroupInput = {
    id?: string
    subaccountId: string
    share: number
  }

  export type SubaccountSplitCreateOrConnectWithoutSplitGroupInput = {
    where: SubaccountSplitWhereUniqueInput
    create: XOR<SubaccountSplitCreateWithoutSplitGroupInput, SubaccountSplitUncheckedCreateWithoutSplitGroupInput>
  }

  export type SubaccountSplitCreateManySplitGroupInputEnvelope = {
    data: SubaccountSplitCreateManySplitGroupInput | SubaccountSplitCreateManySplitGroupInput[]
    skipDuplicates?: boolean
  }

  export type SubaccountSplitUpsertWithWhereUniqueWithoutSplitGroupInput = {
    where: SubaccountSplitWhereUniqueInput
    update: XOR<SubaccountSplitUpdateWithoutSplitGroupInput, SubaccountSplitUncheckedUpdateWithoutSplitGroupInput>
    create: XOR<SubaccountSplitCreateWithoutSplitGroupInput, SubaccountSplitUncheckedCreateWithoutSplitGroupInput>
  }

  export type SubaccountSplitUpdateWithWhereUniqueWithoutSplitGroupInput = {
    where: SubaccountSplitWhereUniqueInput
    data: XOR<SubaccountSplitUpdateWithoutSplitGroupInput, SubaccountSplitUncheckedUpdateWithoutSplitGroupInput>
  }

  export type SubaccountSplitUpdateManyWithWhereWithoutSplitGroupInput = {
    where: SubaccountSplitScalarWhereInput
    data: XOR<SubaccountSplitUpdateManyMutationInput, SubaccountSplitUncheckedUpdateManyWithoutSplitGroupInput>
  }

  export type BatchCreateWithoutTransfersInput = {
    id?: string
    createdAt?: Date | string
    status: string
    bulkTransfers?: BulkTransferCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutTransfersInput = {
    id?: string
    createdAt?: Date | string
    status: string
    bulkTransfers?: BulkTransferUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutTransfersInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutTransfersInput, BatchUncheckedCreateWithoutTransfersInput>
  }

  export type BatchUpsertWithoutTransfersInput = {
    update: XOR<BatchUpdateWithoutTransfersInput, BatchUncheckedUpdateWithoutTransfersInput>
    create: XOR<BatchCreateWithoutTransfersInput, BatchUncheckedCreateWithoutTransfersInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutTransfersInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutTransfersInput, BatchUncheckedUpdateWithoutTransfersInput>
  }

  export type BatchUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bulkTransfers?: BulkTransferUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bulkTransfers?: BulkTransferUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type TransferCreateWithoutBatchInput = {
    id?: string
    name: string
    accountNumber: string
    bankName: string
    bankCode: string
    recipientCode: string
    amount: number
    reason: string
    reference?: string | null
    status: string
    createdAt?: Date | string
  }

  export type TransferUncheckedCreateWithoutBatchInput = {
    id?: string
    name: string
    accountNumber: string
    bankName: string
    bankCode: string
    recipientCode: string
    amount: number
    reason: string
    reference?: string | null
    status: string
    createdAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutBatchInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutBatchInput, TransferUncheckedCreateWithoutBatchInput>
  }

  export type TransferCreateManyBatchInputEnvelope = {
    data: TransferCreateManyBatchInput | TransferCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type BulkTransferCreateWithoutBatchInput = {
    id?: string
    amount: number
    status: string
    reference: string
    reason: string
    recipientCode: string
    transferCode: string
    createdAt?: Date | string
  }

  export type BulkTransferUncheckedCreateWithoutBatchInput = {
    id?: string
    amount: number
    status: string
    reference: string
    reason: string
    recipientCode: string
    transferCode: string
    createdAt?: Date | string
  }

  export type BulkTransferCreateOrConnectWithoutBatchInput = {
    where: BulkTransferWhereUniqueInput
    create: XOR<BulkTransferCreateWithoutBatchInput, BulkTransferUncheckedCreateWithoutBatchInput>
  }

  export type BulkTransferCreateManyBatchInputEnvelope = {
    data: BulkTransferCreateManyBatchInput | BulkTransferCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type TransferUpsertWithWhereUniqueWithoutBatchInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutBatchInput, TransferUncheckedUpdateWithoutBatchInput>
    create: XOR<TransferCreateWithoutBatchInput, TransferUncheckedCreateWithoutBatchInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutBatchInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutBatchInput, TransferUncheckedUpdateWithoutBatchInput>
  }

  export type TransferUpdateManyWithWhereWithoutBatchInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutBatchInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    name?: StringFilter<"Transfer"> | string
    accountNumber?: StringFilter<"Transfer"> | string
    bankName?: StringFilter<"Transfer"> | string
    bankCode?: StringFilter<"Transfer"> | string
    recipientCode?: StringFilter<"Transfer"> | string
    amount?: FloatFilter<"Transfer"> | number
    reason?: StringFilter<"Transfer"> | string
    reference?: StringNullableFilter<"Transfer"> | string | null
    status?: StringFilter<"Transfer"> | string
    batchId?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type BulkTransferUpsertWithWhereUniqueWithoutBatchInput = {
    where: BulkTransferWhereUniqueInput
    update: XOR<BulkTransferUpdateWithoutBatchInput, BulkTransferUncheckedUpdateWithoutBatchInput>
    create: XOR<BulkTransferCreateWithoutBatchInput, BulkTransferUncheckedCreateWithoutBatchInput>
  }

  export type BulkTransferUpdateWithWhereUniqueWithoutBatchInput = {
    where: BulkTransferWhereUniqueInput
    data: XOR<BulkTransferUpdateWithoutBatchInput, BulkTransferUncheckedUpdateWithoutBatchInput>
  }

  export type BulkTransferUpdateManyWithWhereWithoutBatchInput = {
    where: BulkTransferScalarWhereInput
    data: XOR<BulkTransferUpdateManyMutationInput, BulkTransferUncheckedUpdateManyWithoutBatchInput>
  }

  export type BulkTransferScalarWhereInput = {
    AND?: BulkTransferScalarWhereInput | BulkTransferScalarWhereInput[]
    OR?: BulkTransferScalarWhereInput[]
    NOT?: BulkTransferScalarWhereInput | BulkTransferScalarWhereInput[]
    id?: StringFilter<"BulkTransfer"> | string
    amount?: IntFilter<"BulkTransfer"> | number
    status?: StringFilter<"BulkTransfer"> | string
    reference?: StringFilter<"BulkTransfer"> | string
    reason?: StringFilter<"BulkTransfer"> | string
    recipientCode?: StringFilter<"BulkTransfer"> | string
    transferCode?: StringFilter<"BulkTransfer"> | string
    createdAt?: DateTimeFilter<"BulkTransfer"> | Date | string
    batchId?: StringFilter<"BulkTransfer"> | string
  }

  export type BatchCreateWithoutBulkTransfersInput = {
    id?: string
    createdAt?: Date | string
    status: string
    transfers?: TransferCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutBulkTransfersInput = {
    id?: string
    createdAt?: Date | string
    status: string
    transfers?: TransferUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutBulkTransfersInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutBulkTransfersInput, BatchUncheckedCreateWithoutBulkTransfersInput>
  }

  export type BatchUpsertWithoutBulkTransfersInput = {
    update: XOR<BatchUpdateWithoutBulkTransfersInput, BatchUncheckedUpdateWithoutBulkTransfersInput>
    create: XOR<BatchCreateWithoutBulkTransfersInput, BatchUncheckedCreateWithoutBulkTransfersInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutBulkTransfersInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutBulkTransfersInput, BatchUncheckedUpdateWithoutBulkTransfersInput>
  }

  export type BatchUpdateWithoutBulkTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    transfers?: TransferUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutBulkTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    transfers?: TransferUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserCreateWithoutCryptoWalletInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillCreateNestedManyWithoutUserInput
    requests?: RequestCreateNestedManyWithoutRequesterInput
    supports?: RequestCreateNestedManyWithoutSupporterInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    sponsoredBills?: BillCreateNestedManyWithoutSponsorsInput
  }

  export type UserUncheckedCreateWithoutCryptoWalletInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    googleId?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: BillUncheckedCreateNestedManyWithoutUserInput
    requests?: RequestUncheckedCreateNestedManyWithoutRequesterInput
    supports?: RequestUncheckedCreateNestedManyWithoutSupporterInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    sponsoredBills?: BillUncheckedCreateNestedManyWithoutSponsorsInput
  }

  export type UserCreateOrConnectWithoutCryptoWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCryptoWalletInput, UserUncheckedCreateWithoutCryptoWalletInput>
  }

  export type BlockchainTransactionCreateWithoutCryptoWalletInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    blockchainRequest?: BlockchainRequestCreateNestedOneWithoutTransactionsInput
  }

  export type BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    blockchainRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionCreateOrConnectWithoutCryptoWalletInput = {
    where: BlockchainTransactionWhereUniqueInput
    create: XOR<BlockchainTransactionCreateWithoutCryptoWalletInput, BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput>
  }

  export type BlockchainTransactionCreateManyCryptoWalletInputEnvelope = {
    data: BlockchainTransactionCreateManyCryptoWalletInput | BlockchainTransactionCreateManyCryptoWalletInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCryptoWalletInput = {
    update: XOR<UserUpdateWithoutCryptoWalletInput, UserUncheckedUpdateWithoutCryptoWalletInput>
    create: XOR<UserCreateWithoutCryptoWalletInput, UserUncheckedCreateWithoutCryptoWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCryptoWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCryptoWalletInput, UserUncheckedUpdateWithoutCryptoWalletInput>
  }

  export type UserUpdateWithoutCryptoWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutUserNestedInput
    requests?: RequestUpdateManyWithoutRequesterNestedInput
    supports?: RequestUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUpdateManyWithoutSponsorsNestedInput
  }

  export type UserUncheckedUpdateWithoutCryptoWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    supports?: RequestUncheckedUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    sponsoredBills?: BillUncheckedUpdateManyWithoutSponsorsNestedInput
  }

  export type BlockchainTransactionUpsertWithWhereUniqueWithoutCryptoWalletInput = {
    where: BlockchainTransactionWhereUniqueInput
    update: XOR<BlockchainTransactionUpdateWithoutCryptoWalletInput, BlockchainTransactionUncheckedUpdateWithoutCryptoWalletInput>
    create: XOR<BlockchainTransactionCreateWithoutCryptoWalletInput, BlockchainTransactionUncheckedCreateWithoutCryptoWalletInput>
  }

  export type BlockchainTransactionUpdateWithWhereUniqueWithoutCryptoWalletInput = {
    where: BlockchainTransactionWhereUniqueInput
    data: XOR<BlockchainTransactionUpdateWithoutCryptoWalletInput, BlockchainTransactionUncheckedUpdateWithoutCryptoWalletInput>
  }

  export type BlockchainTransactionUpdateManyWithWhereWithoutCryptoWalletInput = {
    where: BlockchainTransactionScalarWhereInput
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyWithoutCryptoWalletInput>
  }

  export type BlockchainTransactionScalarWhereInput = {
    AND?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
    OR?: BlockchainTransactionScalarWhereInput[]
    NOT?: BlockchainTransactionScalarWhereInput | BlockchainTransactionScalarWhereInput[]
    id?: StringFilter<"BlockchainTransaction"> | string
    transactionHash?: StringFilter<"BlockchainTransaction"> | string
    from?: StringFilter<"BlockchainTransaction"> | string
    to?: StringFilter<"BlockchainTransaction"> | string
    amount?: FloatFilter<"BlockchainTransaction"> | number
    status?: EnumBlockchainTxStatusFilter<"BlockchainTransaction"> | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringFilter<"BlockchainTransaction"> | string
    blockchainRequestId?: StringNullableFilter<"BlockchainTransaction"> | string | null
    createdAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"BlockchainTransaction"> | Date | string
  }

  export type BillCreateWithoutBlockchainRequestInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillsInput
    provider?: ProviderCreateNestedOneWithoutBillsInput
    request?: RequestCreateNestedOneWithoutBillsInput
    sponsors?: UserCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionCreateNestedManyWithoutBillInput
  }

  export type BillUncheckedCreateWithoutBlockchainRequestInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    providerId?: string | null
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sponsors?: UserUncheckedCreateNestedManyWithoutSponsoredBillsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutBlockchainRequestInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutBlockchainRequestInput, BillUncheckedCreateWithoutBlockchainRequestInput>
  }

  export type BlockchainTransactionCreateWithoutBlockchainRequestInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoWallet: CryptoWalletCreateNestedOneWithoutTransactionsInput
  }

  export type BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    cryptoWalletId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionCreateOrConnectWithoutBlockchainRequestInput = {
    where: BlockchainTransactionWhereUniqueInput
    create: XOR<BlockchainTransactionCreateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput>
  }

  export type BlockchainTransactionCreateManyBlockchainRequestInputEnvelope = {
    data: BlockchainTransactionCreateManyBlockchainRequestInput | BlockchainTransactionCreateManyBlockchainRequestInput[]
    skipDuplicates?: boolean
  }

  export type BillUpsertWithoutBlockchainRequestInput = {
    update: XOR<BillUpdateWithoutBlockchainRequestInput, BillUncheckedUpdateWithoutBlockchainRequestInput>
    create: XOR<BillCreateWithoutBlockchainRequestInput, BillUncheckedCreateWithoutBlockchainRequestInput>
    where?: BillWhereInput
  }

  export type BillUpdateToOneWithWhereWithoutBlockchainRequestInput = {
    where?: BillWhereInput
    data: XOR<BillUpdateWithoutBlockchainRequestInput, BillUncheckedUpdateWithoutBlockchainRequestInput>
  }

  export type BillUpdateWithoutBlockchainRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillsNestedInput
    provider?: ProviderUpdateOneWithoutBillsNestedInput
    request?: RequestUpdateOneWithoutBillsNestedInput
    sponsors?: UserUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUpdateManyWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutBlockchainRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsors?: UserUncheckedUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBillNestedInput
  }

  export type BlockchainTransactionUpsertWithWhereUniqueWithoutBlockchainRequestInput = {
    where: BlockchainTransactionWhereUniqueInput
    update: XOR<BlockchainTransactionUpdateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedUpdateWithoutBlockchainRequestInput>
    create: XOR<BlockchainTransactionCreateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedCreateWithoutBlockchainRequestInput>
  }

  export type BlockchainTransactionUpdateWithWhereUniqueWithoutBlockchainRequestInput = {
    where: BlockchainTransactionWhereUniqueInput
    data: XOR<BlockchainTransactionUpdateWithoutBlockchainRequestInput, BlockchainTransactionUncheckedUpdateWithoutBlockchainRequestInput>
  }

  export type BlockchainTransactionUpdateManyWithWhereWithoutBlockchainRequestInput = {
    where: BlockchainTransactionScalarWhereInput
    data: XOR<BlockchainTransactionUpdateManyMutationInput, BlockchainTransactionUncheckedUpdateManyWithoutBlockchainRequestInput>
  }

  export type CryptoWalletCreateWithoutTransactionsInput = {
    id?: string
    address: string
    u2kBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoWalletInput
  }

  export type CryptoWalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    address: string
    userId: string
    u2kBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoWalletCreateOrConnectWithoutTransactionsInput = {
    where: CryptoWalletWhereUniqueInput
    create: XOR<CryptoWalletCreateWithoutTransactionsInput, CryptoWalletUncheckedCreateWithoutTransactionsInput>
  }

  export type BlockchainRequestCreateWithoutTransactionsInput = {
    id?: string
    blockchainBillId?: string | null
    transactionHash?: string | null
    status?: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType?: $Enums.PaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: BillCreateNestedOneWithoutBlockchainRequestInput
  }

  export type BlockchainRequestUncheckedCreateWithoutTransactionsInput = {
    id?: string
    billId: string
    blockchainBillId?: string | null
    transactionHash?: string | null
    status?: $Enums.BlockchainTxStatus
    amount: number
    cryptoAmount: number
    paymentType?: $Enums.PaymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainRequestCreateOrConnectWithoutTransactionsInput = {
    where: BlockchainRequestWhereUniqueInput
    create: XOR<BlockchainRequestCreateWithoutTransactionsInput, BlockchainRequestUncheckedCreateWithoutTransactionsInput>
  }

  export type CryptoWalletUpsertWithoutTransactionsInput = {
    update: XOR<CryptoWalletUpdateWithoutTransactionsInput, CryptoWalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CryptoWalletCreateWithoutTransactionsInput, CryptoWalletUncheckedCreateWithoutTransactionsInput>
    where?: CryptoWalletWhereInput
  }

  export type CryptoWalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CryptoWalletWhereInput
    data: XOR<CryptoWalletUpdateWithoutTransactionsInput, CryptoWalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type CryptoWalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoWalletNestedInput
  }

  export type CryptoWalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    u2kBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainRequestUpsertWithoutTransactionsInput = {
    update: XOR<BlockchainRequestUpdateWithoutTransactionsInput, BlockchainRequestUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BlockchainRequestCreateWithoutTransactionsInput, BlockchainRequestUncheckedCreateWithoutTransactionsInput>
    where?: BlockchainRequestWhereInput
  }

  export type BlockchainRequestUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BlockchainRequestWhereInput
    data: XOR<BlockchainRequestUpdateWithoutTransactionsInput, BlockchainRequestUncheckedUpdateWithoutTransactionsInput>
  }

  export type BlockchainRequestUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: BillUpdateOneRequiredWithoutBlockchainRequestNestedInput
  }

  export type BlockchainRequestUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billId?: StringFieldUpdateOperationsInput | string
    blockchainBillId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    amount?: FloatFieldUpdateOperationsInput | number
    cryptoAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateManyUserInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    providerId?: string | null
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateManyRequesterInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    supporterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateManySupporterInput = {
    id?: string
    name: string
    notes?: string | null
    status?: $Enums.RequestStatus
    feedback?: string | null
    publicLinkId?: string
    requesterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneWithoutBillsNestedInput
    request?: RequestUpdateOneWithoutBillsNestedInput
    sponsors?: UserUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsors?: UserUncheckedUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUncheckedUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supporter?: UserUpdateOneWithoutSupportsNestedInput
    bills?: BillUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    supporterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    supporterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUpdateWithoutSupporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutRequestsNestedInput
    bills?: BillUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutSupporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateManyWithoutSupporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    publicLinkId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillUpdateWithoutSponsorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillsNestedInput
    provider?: ProviderUpdateOneWithoutBillsNestedInput
    request?: RequestUpdateOneWithoutBillsNestedInput
    transactions?: TransactionUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutSponsorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUncheckedUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutSponsorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateManyProviderInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    requestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillsNestedInput
    request?: RequestUpdateOneWithoutBillsNestedInput
    sponsors?: UserUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsors?: UserUncheckedUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUncheckedUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyBillInput = {
    id?: string
    amount: number
    status?: string
    reference: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutSponsoredBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUpdateManyWithoutUserNestedInput
    requests?: RequestUpdateManyWithoutRequesterNestedInput
    supports?: RequestUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSponsoredBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: BillUncheckedUpdateManyWithoutUserNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRequesterNestedInput
    supports?: RequestUncheckedUpdateManyWithoutSupporterNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    cryptoWallet?: CryptoWalletUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSponsoredBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillCreateManyRequestInput = {
    id?: string
    billName: string
    description: string
    type: string
    note?: string | null
    amount: number
    priority?: $Enums.Priority
    status?: $Enums.BillStatus
    category?: string | null
    dueDate?: Date | string | null
    paymentMethod?: string | null
    userId: string
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillsNestedInput
    provider?: ProviderUpdateOneWithoutBillsNestedInput
    sponsors?: UserUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sponsors?: UserUncheckedUpdateManyWithoutSponsoredBillsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutBillNestedInput
    blockchainRequest?: BlockchainRequestUncheckedUpdateOneWithoutBillNestedInput
  }

  export type BillUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    billName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumBillStatusFieldUpdateOperationsInput | $Enums.BillStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubaccountSplitCreateManySubaccountInput = {
    id?: string
    splitGroupId: string
    share: number
  }

  export type SubaccountSplitUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
    splitGroup?: SplitGroupUpdateOneRequiredWithoutSubaccountsNestedInput
  }

  export type SubaccountSplitUncheckedUpdateWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    splitGroupId?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
  }

  export type SubaccountSplitUncheckedUpdateManyWithoutSubaccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    splitGroupId?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
  }

  export type SubaccountSplitCreateManySplitGroupInput = {
    id?: string
    subaccountId: string
    share: number
  }

  export type SubaccountSplitUpdateWithoutSplitGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
    subaccount?: SubaccountUpdateOneRequiredWithoutSubaccountSplitsNestedInput
  }

  export type SubaccountSplitUncheckedUpdateWithoutSplitGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    subaccountId?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
  }

  export type SubaccountSplitUncheckedUpdateManyWithoutSplitGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    subaccountId?: StringFieldUpdateOperationsInput | string
    share?: FloatFieldUpdateOperationsInput | number
  }

  export type TransferCreateManyBatchInput = {
    id?: string
    name: string
    accountNumber: string
    bankName: string
    bankCode: string
    recipientCode: string
    amount: number
    reason: string
    reference?: string | null
    status: string
    createdAt?: Date | string
  }

  export type BulkTransferCreateManyBatchInput = {
    id?: string
    amount: number
    status: string
    reference: string
    reason: string
    recipientCode: string
    transferCode: string
    createdAt?: Date | string
  }

  export type TransferUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkTransferUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkTransferUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkTransferUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    recipientCode?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionCreateManyCryptoWalletInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    blockchainRequestId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionUpdateWithoutCryptoWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchainRequest?: BlockchainRequestUpdateOneWithoutTransactionsNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateWithoutCryptoWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    blockchainRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutCryptoWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    blockchainRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionCreateManyBlockchainRequestInput = {
    id?: string
    transactionHash: string
    from: string
    to: string
    amount: number
    status: $Enums.BlockchainTxStatus
    cryptoWalletId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockchainTransactionUpdateWithoutBlockchainRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoWallet?: CryptoWalletUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type BlockchainTransactionUncheckedUpdateWithoutBlockchainRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainTransactionUncheckedUpdateManyWithoutBlockchainRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    to?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumBlockchainTxStatusFieldUpdateOperationsInput | $Enums.BlockchainTxStatus
    cryptoWalletId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}